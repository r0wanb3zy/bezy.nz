<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disc Golf Scorecard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">
  <script src="https://code.jquery.com/jquery-3.6.4.min.js"></script>

  <style>
    html, body { height: 100%; margin: 0; }
    body {
      font-family: 'Economica', sans-serif;
      font-size: 22px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      min-height: 100vh;
      background-size: cover;
    }
    :root {
      --pulse-h: 210;
      --pulse-s: 85%;
      --pulse-l: 78%;
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 20px;
      table-layout: fixed;
      font-family: 'Economica', sans-serif;
    }
    table th, table td { font-weight: bold; text-align: center; padding: 5px; border-bottom: 1px solid rgba(200,200,200,0.3); }
    table td { border-right: 1px solid rgba(200,200,200,0.3); }
    table td:last-child { border-right: none; }

    #scoreTable {
      height: 100vh;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
    }

    @media screen and (orientation: portrait) {
      html, body { overflow: hidden; touch-action: none; }
      #scoreTable { overflow-y: hidden; }
    }
    @media screen and (orientation: landscape) {
      html, body { overflow: auto; touch-action: auto; }
      #scoreTable { overflow-y: auto; }
    }

    thead th {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white;
      height: 64px;
      font-size: 22px;
      border-bottom: none;
      position: sticky;
      top: 0;
      z-index: 3;
    }
    thead th .player-name {
      display: block;
      max-width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: clip;
    }
    #scoreTable.small-scores thead th .player-name {
      font-size: 18px;
      line-height: 1.1;
    }

    tbody tr:last-child td { border-bottom: none; }
    td.hole-cell, th.hole-header {
      background: #3b3b3b; color: white;
      border-right: 1px solid #666;
      position: sticky; left: 0; z-index: 2;
    }
    td.par-cell, th.par-header {
      background: #3b3b3b; color: white;
      border-right: 1px solid #666;
      position: sticky; left: 80px; z-index: 2;
    }
    .hole-cell, .par-cell { cursor: pointer; }
    .summary-row td {
      background: #f6f7f8;
      font-weight: 700;
    }
    .summary-row td.hole-cell, .summary-row td.par-cell {
      background: #3b3b3b; color: white;
    }

    /* Popup */
    #popupModal {
      display: none;
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 8px 16px 16px; z-index: 1000;
      font-family: 'Economica', sans-serif; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
      width: 320px; max-width: calc(100% - 20px);
    }
    #popupModal h2 { margin: 10px 0 6px; padding: 0; }
    #popupOptions {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 6px; justify-content: center;
      padding: 8px 0 0; box-sizing: border-box;
    }
    #popupOptions button {
      width: 100%; height: 42px; font-size: 22px; padding: 0; margin: 0;
      cursor: pointer; font-family: 'Economica', sans-serif; display: grid; place-items: center;
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px;
    }
    .close-btn {
      position: absolute; top: 0px; right: 0px;
      font-size: 40px; color: #000000; cursor: pointer; background: none; border: none;
      padding: 0; line-height: 1; width: 40px; height: 40px; text-align: center;
    }

    #overlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999; cursor: pointer;
    }

    /* Round modal */
    #roundManagementModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 10px 16px 16px; z-index: 1001;
      width: 240px; max-width: 90%; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px; text-align: center;
    }
    #roundManagementModal h2 { margin: 10px 0; }
    #roundManagementModal select, #roundManagementModal button {
      width: 100%; box-sizing: border-box; margin: 6px 0; padding: 10px; font-size: 22px; border-radius: 6px;
      border: 1px solid #333; background: #f8f9fa; cursor: pointer;
    }
    #roundManagementModal button.primary {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff; border: none;
    }
    #roundManagementModal button.danger {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%); color: #fff; border: none;
    }
    #roundManagementModal button#sortByRankBtn.active {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff; border: 1px solid #262626;
    }

    .gear {
      font-size: 20px; margin-left: 6px; cursor: pointer; color: #fff; background: none; border: none;
    }
    .to-par-badge {
      display: inline-block; margin-left: 6px; font-size: 14px; padding: 2px 6px; border-radius: 12px; color: #fff;
      background: #6b7280;
    }
  </style>
</head>
<body>
  <table id="scoreTable">
    <thead>
      <tr id="headerRow">
        <th class="hole-header">
          <button class="gear" title="Round settings" onclick="showRoundManagement()">☰</button>
        </th>
        <th class="par-header">Par</th>
        <!-- Player headers injected here -->
      </tr>
    </thead>
    <tbody id="scoreBody">
      <!-- Rows injected here -->
    </tbody>
  </table>

  <!-- Popup -->
  <div id="popupModal">
    <h2 id="popupTitle">Score</h2>
    <button class="close-btn" onclick="closePopup()">×</button>
    <div id="popupOptions"></div>
  </div>

  <!-- Round settings -->
  <div id="roundManagementModal">
    <h2>Round</h2>
    <button class="close-btn" onclick="closeRoundManagement()">×</button>

    <select id="playerCount" onchange="updatePlayerCount()">
      <option value="1">1 Player</option>
      <option value="2">2 Players</option>
      <option value="3">3 Players</option>
      <option value="4">4 Players</option>
      <option value="5">5 Players</option>
      <option value="6">6 Players</option>
      <option value="7">7 Players</option>
      <option value="8">8 Players</option>
    </select>

    <select id="holesCount" onchange="updateHolesCount()">
      <option value="9">9 Holes</option>
      <option value="18">18 Holes</option>
    </select>

    <button id="sortByRankBtn" onclick="toggleSortByRank()">Sort by Rank</button>

    <select id="themeColorSelect" onchange="setThemeColor(this.value)">
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="pink">Pink</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="green">Green</option>
      <option value="grey">Grey</option>
    </select>

    <button class="primary" onclick="setAllPars(3)">Set All Pars to 3</button>
    <button class="danger" onclick="resetScores()">Reset</button>
  </div>

  <div id="overlay"></div>

  <script>
    // ------------------------------
    // App state
    // ------------------------------
    const LS = {
      holesCount: 'dg-holesCount',
      playerCount: 'dg-playerCount',
      themeColor: 'dg-themeColor',
      sort: 'dg-sortByRankEnabled',
      name: (p) => `dg-playerName-${p}`,
      par: (h) => `dg-par-H${h}`,
      score: (p, h) => `dg-${p}-H${h}`,
    };

    const THEME_MAP = {
      blue:   { h: 210, s: 85 },
      red:    { h:   0, s: 78 },
      green:  { h: 120, s: 50 },
      pink:   { h: 330, s: 70 },
      purple: { h: 268, s: 70 },
      yellow: { h:  45, s: 90 },
      grey:   { h: 210, s:  0 }
    };
    function getThemeHS(key) { const t = THEME_MAP[key] || THEME_MAP.blue; return t; }
    let themeColor = localStorage.getItem(LS.themeColor) || 'blue';

    let holesCount = parseInt(localStorage.getItem(LS.holesCount) || '18', 10);
    if (![9, 18].includes(holesCount)) holesCount = 18;

    let playerCount = parseInt(localStorage.getItem(LS.playerCount) || '4', 10);
    playerCount = Math.min(8, Math.max(1, playerCount));

    let sortByRankEnabled = localStorage.getItem(LS.sort) === 'true';

    // For popup context
    let currentMode = null; // 'score' or 'par'
    let currentCell = null; // td element
    let currentHole = null; // number
    let currentPlayer = null; // 'P1' etc.

    // ------------------------------
    // Init
    // ------------------------------
    document.addEventListener('DOMContentLoaded', () => {
      // Settings selects
      document.getElementById('playerCount').value = String(playerCount);
      document.getElementById('holesCount').value = String(holesCount);
      const themeSel = document.getElementById('themeColorSelect');
      themeSel.value = themeColor;
      applyThemeSelectColors();

      buildTable();
      loadFromStorage();
      updateAllTotals();
      updateRanks();
    });

    window.addEventListener('resize', () => {
      clipPlayerNamesToCell();
      const table = document.getElementById("scoreTable");
      if (table) table.style.height = `${window.innerHeight}px`;
    });

    // ------------------------------
    // Build table
    // ------------------------------
    function buildTable() {
      const headerRow = document.getElementById('headerRow');
      // Clear existing player headers (keep first 2)
      while (headerRow.children.length > 2) headerRow.removeChild(headerRow.lastChild);

      for (let p = 1; p <= playerCount; p++) {
        const th = document.createElement('th');
        th.setAttribute('data-player', `P${p}`);
        const savedName = localStorage.getItem(LS.name(`P${p}`)) || `P${p}`;
        th.innerHTML = `
          <span class="player-name" title="${savedName}">${savedName}</span>
          <div id="totalP${p}"></div>
        `;
        th.addEventListener('click', () => renamePlayer(`P${p}`));
        headerRow.appendChild(th);
      }

      // Body
      const body = document.getElementById('scoreBody');
      body.innerHTML = '';

      // Hole rows
      for (let h = 1; h <= holesCount; h++) {
        const tr = document.createElement('tr');

        const tdHole = document.createElement('td');
        tdHole.className = 'hole-cell';
        tdHole.textContent = String(h);
        tr.appendChild(tdHole);

        const tdPar = document.createElement('td');
        tdPar.className = 'par-cell';
        tdPar.setAttribute('data-hole', `H${h}`);
        tdPar.addEventListener('click', () => openParPopup(tdPar));
        tdPar.textContent = '3'; // default, will be overwritten by storage load
        tr.appendChild(tdPar);

        for (let p = 1; p <= playerCount; p++) {
          const td = document.createElement('td');
          td.className = 'score-cell';
          td.setAttribute('data-player', `P${p}`);
          td.setAttribute('data-hole', `H${h}`);
          td.addEventListener('click', () => openScorePopup(td));
          tr.appendChild(td);
        }
        body.appendChild(tr);
      }

      // Summary rows
      // OUT (1-9)
      const trOut = document.createElement('tr');
      trOut.className = 'summary-row';
      const outHole = document.createElement('td'); outHole.className = 'hole-cell'; outHole.textContent = 'OUT';
      const outPar = document.createElement('td'); outPar.className = 'par-cell'; outPar.setAttribute('data-sum', 'out-par');
      trOut.appendChild(outHole); trOut.appendChild(outPar);
      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.setAttribute('data-sum', `out-P${p}`);
        trOut.appendChild(td);
      }
      body.appendChild(trOut);

      if (holesCount > 9) {
        // IN (10-18)
        const trIn = document.createElement('tr');
        trIn.className = 'summary-row';
        const inHole = document.createElement('td'); inHole.className = 'hole-cell'; inHole.textContent = 'IN';
        const inPar = document.createElement('td'); inPar.className = 'par-cell'; inPar.setAttribute('data-sum', 'in-par');
        trIn.appendChild(inHole); trIn.appendChild(inPar);
        for (let p = 1; p <= playerCount; p++) {
          const td = document.createElement('td');
          td.setAttribute('data-sum', `in-P${p}`);
          trIn.appendChild(td);
        }
        body.appendChild(trIn);
      }

      // TOTAL
      const trTot = document.createElement('tr');
      trTot.className = 'summary-row';
      const totHole = document.createElement('td'); totHole.className = 'hole-cell'; totHole.textContent = 'TOTAL';
      const totPar = document.createElement('td'); totPar.className = 'par-cell'; totPar.setAttribute('data-sum', 'total-par');
      trTot.appendChild(totHole); trTot.appendChild(totPar);
      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.setAttribute('data-sum', `total-P${p}`);
        trTot.appendChild(td);
      }
      body.appendChild(trTot);

      clipPlayerNamesToCell();
    }

    // ------------------------------
    // Storage load
    // ------------------------------
    function loadFromStorage() {
      // Pars
      for (let h = 1; h <= holesCount; h++) {
        const savedPar = parseInt(localStorage.getItem(LS.par(h)) || '3', 10);
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = String(savedPar);
      }
      // Scores
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const saved = localStorage.getItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && saved != null) td.textContent = saved;
        }
      }
      // Names
      for (let p = 1; p <= playerCount; p++) {
        const header = document.querySelector(`#headerRow th[data-player="P${p}"] .player-name`);
        const savedName = localStorage.getItem(LS.name(`P${p}`));
        if (header && savedName) header.textContent = savedName;
      }
    }

    // ------------------------------
    // Popups (Score and Par)
    // ------------------------------
    function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
    function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }
    function closePopup() {
      document.getElementById('popupModal').style.display = 'none';
      hideOverlay();
      currentCell = null; currentHole = null; currentPlayer = null; currentMode = null;
    }

    function openScorePopup(td) {
      currentMode = 'score';
      currentCell = td;
      currentHole = parseInt(td.getAttribute('data-hole').replace('H',''), 10);
      currentPlayer = td.getAttribute('data-player');

      const par = getPar(currentHole);
      document.getElementById('popupTitle').textContent = `Hole ${currentHole} • Par ${par}`;

      const optionsDiv = document.getElementById('popupOptions');
      optionsDiv.innerHTML = '';

      // Quick relative picks: -2, -1, Par, +1, +2
      const quick = [
        { label: '−2', v: par - 2 }, { label: '−1', v: par - 1 }, { label: 'Par', v: par }, { label: '+1', v: par + 1 }, { label: '+2', v: par + 2 }
      ];
      for (const q of quick) optionsDiv.appendChild(mkBtn(q.label, () => selectScore(q.v)));

      // Grid 1..10
      for (let i = 1; i <= 10; i++) optionsDiv.appendChild(mkBtn(String(i), () => selectScore(i)));

      // Clear
      optionsDiv.appendChild(mkBtn('↺', () => selectScore('')));

      document.getElementById('popupModal').style.display = 'block';
      showOverlay();
    }

    function openParPopup(td) {
      currentMode = 'par';
      currentCell = td;
      currentHole = parseInt(td.getAttribute('data-hole').replace('H',''), 10);
      currentPlayer = null;

      document.getElementById('popupTitle').textContent = `Set Par • Hole ${currentHole}`;

      const optionsDiv = document.getElementById('popupOptions');
      optionsDiv.innerHTML = '';

      // Common pars
      [2,3,4,5,6,7].forEach(v => optionsDiv.appendChild(mkBtn(String(v), () => selectPar(v))));
      optionsDiv.appendChild(mkBtn('All = 3', () => { setAllPars(3); closePopup(); }));
      optionsDiv.appendChild(mkBtn('↺', () => selectPar(3)));

      document.getElementById('popupModal').style.display = 'block';
      showOverlay();
    }

    function mkBtn(label, handler) {
      const b = document.createElement('button');
      b.type = 'button';
      b.textContent = label;
      b.onclick = (e) => { e.stopPropagation(); handler(); };
      return b;
    }

    function selectScore(val) {
      if (!currentCell || currentMode !== 'score') return;
      const hole = currentHole;
      const player = currentPlayer;
      if (val === '') {
        currentCell.textContent = '';
        localStorage.removeItem(LS.score(player, hole));
      } else {
        currentCell.textContent = String(val);
        localStorage.setItem(LS.score(player, hole), String(val));
      }
      closePopup();
      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
    }

    function selectPar(v) {
      if (!currentCell || currentMode !== 'par') return;
      const hole = currentHole;
      currentCell.textContent = String(v);
      localStorage.setItem(LS.par(hole), String(v));
      closePopup();
      updateAllTotals();
      updateRanks();
    }

    // ------------------------------
    // Round modal
    // ------------------------------
    function showRoundManagement() {
      const sortBtn = document.getElementById('sortByRankBtn');
      sortBtn.classList.toggle('active', sortByRankEnabled);
      document.getElementById('playerCount').value = String(playerCount);
      document.getElementById('holesCount').value = String(holesCount);
      document.getElementById('themeColorSelect').value = themeColor;
      applyThemeSelectColors();

      document.getElementById('roundManagementModal').style.display = 'block';
      showOverlay();
    }
    function closeRoundManagement() {
      document.getElementById('roundManagementModal').style.display = 'none';
      hideOverlay();
    }

    function updatePlayerCount() {
      const val = parseInt(document.getElementById('playerCount').value, 10);
      playerCount = Math.min(8, Math.max(1, val));
      localStorage.setItem(LS.playerCount, String(playerCount));
      rebuildPreserving();
    }

    function updateHolesCount() {
      const val = parseInt(document.getElementById('holesCount').value, 10);
      holesCount = [9,18].includes(val) ? val : 18;
      localStorage.setItem(LS.holesCount, String(holesCount));
      rebuildPreserving();
    }

    function setThemeColor(value) {
      themeColor = value || 'blue';
      localStorage.setItem(LS.themeColor, themeColor);
      applyThemeSelectColors();
      updateRanks();
    }
    function applyThemeSelectColors() {
      const select = document.querySelector('#roundManagementModal select#themeColorSelect');
      if (!select) return;
      const t = getThemeHS(themeColor);
      const L = themeColor === 'yellow' ? 32 : 34;
      select.style.color = `hsl(${t.h}, ${t.s}%, ${L}%)`;
      Array.from(select.options).forEach(opt => {
        const tt = getThemeHS(opt.value);
        opt.style.color = `hsl(${tt.h}, ${tt.s}%, ${L}%)`;
      });
    }

    function setAllPars(v) {
      for (let h = 1; h <= holesCount; h++) {
        localStorage.setItem(LS.par(h), String(v));
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = String(v);
      }
      updateAllTotals();
      updateRanks();
    }

    function resetScores() {
      // Clear scores and pars
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          localStorage.removeItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td) td.textContent = '';
        }
      }
      for (let h = 1; h <= holesCount; h++) {
        localStorage.removeItem(LS.par(h));
        const parCell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (parCell) parCell.textContent = '3';
      }
      updateAllTotals();
      updateRanks();
      closeRoundManagement();
    }

    function toggleSortByRank() {
      sortByRankEnabled = !sortByRankEnabled;
      localStorage.setItem(LS.sort, String(sortByRankEnabled));
      const btn = document.getElementById('sortByRankBtn');
      if (btn) btn.classList.toggle('active', sortByRankEnabled);
      if (sortByRankEnabled) applySortByRank();
    }

    // ------------------------------
    // Helpers
    // ------------------------------
    function getPar(h) {
      const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
      const v = parseInt(cell?.textContent || '3', 10);
      return Number.isFinite(v) ? v : 3;
    }
    function getScore(player, h) {
      const td = document.querySelector(`td.score-cell[data-player="${player}"][data-hole="H${h}"]`);
      const v = parseInt(td?.textContent || '', 10);
      return Number.isFinite(v) ? v : null;
    }
    function hasAnyEntry() {
      return Array.from(document.querySelectorAll('.score-cell')).some(td => td.textContent.trim() !== '');
    }

    function updateAllTotals() {
      // Par sums
      const outRange = [...Array(Math.min(9, holesCount)).keys()].map(i => i + 1);
      const inRange = (holesCount > 9) ? [...Array(holesCount - 9).keys()].map(i => i + 10) : [];
      const allRange = [...Array(holesCount).keys()].map(i => i + 1);

      const parOut = outRange.reduce((s, h) => s + getPar(h), 0);
      const parIn  = inRange.reduce((s, h) => s + getPar(h), 0);
      const parTot = allRange.reduce((s, h) => s + getPar(h), 0);

      const setSumCell = (key, val) => {
        const el = document.querySelector(`[data-sum="${key}"]`);
        if (el) el.textContent = String(val);
      };

      setSumCell('out-par', parOut);
      if (holesCount > 9) setSumCell('in-par', parIn);
      setSumCell('total-par', parTot);

      // Per player sums + to-par
      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const sumOut = outRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const sumIn  = inRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const sumTot = sumOut + sumIn;

        setSumCell(`out-${pid}`, sumOut);
        if (holesCount > 9) setSumCell(`in-${pid}`, sumIn);
        setSumCell(`total-${pid}`, sumTot);

        // To-par for played holes only (more informative mid-round)
        let playedPar = 0, playedStrokes = 0;
        for (let h = 1; h <= holesCount; h++) {
          const sc = getScore(pid, h);
          if (sc != null) {
            playedStrokes += sc;
            playedPar += getPar(h);
          }
        }
        const toPar = (playedPar === 0) ? 0 : (playedStrokes - playedPar);
        const header = document.querySelector(`#headerRow th[data-player="${pid}"]`);
        const totalDiv = header?.querySelector(`#total${pid}`) || header?.querySelector('div[id^="total"]');
        if (totalDiv) {
          const badgeText = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
          totalDiv.innerHTML = `${playedStrokes || ''} <span class="to-par-badge">${badgeText}</span>`;
        }
      }
    }

    // Player rank shading + clipping names
    function updateRanks() {
      const table = document.getElementById('scoreTable');
      const headers = Array.from(table.querySelectorAll('thead th')).slice(2); // players only
      const playerCountNow = headers.length;

      if (playerCountNow >= 7) table.classList.add('small-scores');
      else table.classList.remove('small-scores');

      // If no entries, clear header backgrounds to theme base
      if (!hasAnyEntry()) {
        headers.forEach(h => { h.style.background = 'linear-gradient(to bottom, #262626 0%, #3b3b3b 100%)'; });
        clipPlayerNamesToCell();
        return;
      }

      const { h: H, s: S } = getThemeHS(themeColor);
      // compute totals (played strokes) for rank coloring
      const totals = headers.map((h, idx) => {
        const pid = h.getAttribute('data-player');
        let played = 0;
        for (let i = 1; i <= holesCount; i++) {
          const sc = getScore(pid, i);
          if (sc != null) played += sc;
        }
        return { idx, pid, played };
      });

      const sorted = [...totals].sort((a,b) => a.played - b.played || a.idx - b.idx);
      // group ties
      const groups = [];
      for (const item of sorted) {
        const last = groups[groups.length - 1];
        if (!last || last.score !== item.played) groups.push({ score: item.played, members: [item.idx] });
        else last.members.push(item.idx);
      }

      const Lmax = 82, minRange = 18, maxRange = 44;
      const effectiveRanks = groups.length;
      const normalized = Math.min(1, Math.max(0, (effectiveRanks - 1) / (8 - 1)));
      const range = Math.round(minRange + (maxRange - minRange) * normalized);
      const Lmin = Math.max(28, Lmax - range);

      groups.forEach((group, g) => {
        const ratio = (effectiveRanks === 1) ? 1 : g / (effectiveRanks - 1);
        const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
        const Ltop = Math.max(18, L - 10);
        const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
        group.members.forEach(i => headers[i].style.background = gradient);
      });

      clipPlayerNamesToCell();
    }

    function clipPlayerNamesToCell() {
      const seg = (typeof Intl !== 'undefined' && Intl.Segmenter) ? new Intl.Segmenter('en', { granularity: 'grapheme' }) : null;
      const els = document.querySelectorAll('#scoreTable thead th .player-name');
      els.forEach(el => {
        const full = el.getAttribute('title') || el.textContent;
        el.textContent = full;
        if (el.scrollWidth <= el.clientWidth) return;
        const clusters = seg ? Array.from(seg.segment(full), s => s.segment) : Array.from(full);
        let low = 0, high = clusters.length, best = 0;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          el.textContent = clusters.slice(0, mid).join('');
          if (el.scrollWidth <= el.clientWidth) { best = mid; low = mid + 1; }
          else high = mid - 1;
        }
        el.textContent = clusters.slice(0, best).join('');
      });
    }

    // Sort columns by total played strokes (asc = best first)
    function applySortByRank(silent = false) {
      const table = document.getElementById('scoreTable');
      const headerRow = document.getElementById('headerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      // Build totals
      const headers = Array.from(headerRow.children).slice(2);
      if (headers.length <= 1 || !hasAnyEntry()) return;

      const players = headers.map((th, idx) => {
        const pid = th.getAttribute('data-player');
        let played = 0;
        for (let h = 1; h <= holesCount; h++) {
          const sc = getScore(pid, h);
          if (sc != null) played += sc;
        }
        return { idx, pid, played, th };
      });

      const order = [...players].sort((a,b) => a.played - b.played || a.idx - b.idx).map(p => p.idx);
      if (order.every((v, i) => v === i)) { if (!silent) updateRanks(); return; }

      // Reorder headers (keep first 2 fixed)
      const fixed = Array.from(headerRow.children).slice(0,2);
      const moving = Array.from(headerRow.children).slice(2);
      const newHeaderRow = [...fixed, ...order.map(i => moving[i])];
      headerRow.innerHTML = '';
      newHeaderRow.forEach(n => headerRow.appendChild(n));

      // Reorder each body row: first 2 fixed cells, then reorder player cells
      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixed2 = cells.slice(0,2);
        const movingCells = cells.slice(2);
        const reordered = [...fixed2, ...order.map(i => movingCells[i])];
        tr.innerHTML = '';
        reordered.forEach(c => tr.appendChild(c));
      });

      if (!silent) updateRanks();
    }

    function renamePlayer(pid) {
      const header = document.querySelector(`#headerRow th[data-player="${pid}"] .player-name`);
      const current = header?.textContent || pid;
      const name = prompt('Player name:', current);
      if (name == null) return;
      const trimmed = name.trim();
      if (!trimmed) return;
      header.textContent = trimmed;
      localStorage.setItem(LS.name(pid), trimmed);
      clipPlayerNamesToCell();
    }

    // Preserve data across rebuilds (when players/holes change)
    function rebuildPreserving() {
      const names = {};
      for (let p = 1; p <= 8; p++) {
        const k = LS.name(`P${p}`);
        const v = localStorage.getItem(k);
        if (v != null) names[`P${p}`] = v;
      }
      const pars = {};
      for (let h = 1; h <= 18; h++) {
        const k = LS.par(h);
        const v = localStorage.getItem(k);
        if (v != null) pars[h] = v;
      }
      const scores = {};
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) {
          const k = LS.score(`P${p}`, h);
          const v = localStorage.getItem(k);
          if (v != null) scores[`${p}-${h}`] = v;
        }
      }

      buildTable();

      // Restore within bounds
      for (let p = 1; p <= playerCount; p++) {
        const nm = names[`P${p}`];
        if (nm != null) {
          const header = document.querySelector(`#headerRow th[data-player="P${p}"] .player-name`);
          if (header) header.textContent = nm;
          localStorage.setItem(LS.name(`P${p}`), nm);
        }
      }
      for (let h = 1; h <= holesCount; h++) {
        const par = pars[h] ?? '3';
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) {
          cell.textContent = par;
          localStorage.setItem(LS.par(h), par);
        }
      }
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const key = `${p}-${h}`;
          const v = scores[key];
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && v != null) {
            td.textContent = v;
            localStorage.setItem(LS.score(`P${p}`, h), v);
          }
        }
      }

      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
    }

    // Overlay clicks close everything
    document.getElementById('overlay').addEventListener('click', () => {
      closePopup();
      closeRoundManagement();
    });
  </script>
</body>
</html>
