<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Golf Scorecard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">

  <style>
    /* Base */
    html, body { height: 100%; margin: 0; overflow: hidden; }
    body {
      font-family: 'Economica', sans-serif;
      font-size: 22px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      min-height: 100vh;
      background-size: cover;
    }

    :root {
      --hole-w: 30px;
      --par-w: 30px;
      --row-h: 34px; /* JS sets so rows fit exactly in the visible table area */
      --ph-color: rgba(0, 0, 0, 0.24);
    }

    /* Table base */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 20px;
      table-layout: fixed;
      font-family: 'Economica', sans-serif;
    }
    table, table th, table td { font-weight: bold; }

    /* Score table: full-screen, safe-area aware */
    #scoreTable {
      position: fixed;
      top: env(safe-area-inset-top);
      bottom: env(safe-area-inset-bottom);
      left: env(safe-area-inset-left);
      right: env(safe-area-inset-right);
      height: auto;           /* the insets define height */
      min-height: 0;
      overflow-y: auto;
      box-shadow: 0 2px 10px rgba(0,0,0,0.05);
      background: transparent;
    }

    /* Header row */
    table th {
      background: linear-gradient(to bottom, #3b3b3b 0%, #3b3b3b 100%);
      color: white;
      border-bottom: none;
      cursor: pointer;
    }
    #scoreTable thead th {
      height: 80px;
      font-size: 22px;
    }

    /* Top-left settings cell */
    #scoreTable thead th:first-child {
      background: #3b3b3b;
      color: #fff;
      border-right: 1px solid #666; /* divider between settings and Par */
      border-bottom: 1px solid #666;
    }

    /* Table cells */
    table th, table td {
      text-align: center;
      padding: 5px;
      word-wrap: break-word;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: middle;
      border-bottom: 1px solid rgba(200, 200, 200, 0.3);
    }
    table td { border-right: 1px solid rgba(200, 200, 200, 0.3); }
    table td:last-child { border-right: none; }
    table tr:last-child td { border-bottom: none; }

    /* First two columns: sticky + darker borders */
    th.hole-header, td.hole-cell {
      position: sticky; left: 0; z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--hole-w); min-width: var(--hole-w); max-width: var(--hole-w);
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
      cursor: default;
    }
    th.hole-header { cursor: pointer; }

    th.par-header, td.par-cell {
      position: sticky;
      left: calc(var(--hole-w) + 1px);
      z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--par-w); min-width: var(--par-w); max-width: var(--par-w);
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
    }
    th.par-header { border-right: none; }

    /* Make all body rows rock-solid height */
    #scoreTable tbody td, #scoreTable tbody th {
      height: var(--row-h);
      line-height: var(--row-h);
      padding-top: 0;
      padding-bottom: 0;
      font-variant-numeric: tabular-nums;
    }

    /* Summary rows (OUT/IN) dark */
    .summary-row td {
      background: #3b3b3b; color: white;
      border-bottom: 1px solid #666; border-right: 1px solid #666;
    }
    .summary-row td:last-child { border-right: none; }

    /* Header — THREE LINES */
    #scoreTable thead th .player-name {
      display: block;
      max-width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: clip;
      text-align: center;
      font-size: 22px;
      line-height: 22px;
      margin: 0;
      padding-bottom: 2px;
    }
    #scoreTable thead th div[id^="total"] {
      display: block;
      font-size: 22px;
      color: rgba(255, 255, 255, 0.95);
      margin: 0;
    }
    #scoreTable thead th .to-par-line {
      display: block;
      line-height: 1;
      margin-top: 0;
    }
    .to-par-badge {
      display: inline-block;
      font-size: 16px;
      line-height: 1;
      padding: 4px 10px;
      border-radius: 9999px;
      background: #ffffff;
      color: #000000;
      vertical-align: middle;
      margin: 0;
    }
    #scoreTable.small-scores thead th .to-par-badge { font-size: 12px; }
    #scoreTable.small-scores thead th .player-name {
      font-size: 18px;
      line-height: 18px;
      padding-bottom: 2px;
    }

    .gear {
      font-size: 20px; cursor: inherit; color: #fff; background: none; border: none;
      padding: 0; margin: 0; line-height: 1;
    }

    /* Remove bottom border under player header cells (name columns only) */
    #scoreTable thead th[data-player] {
      border-bottom: none !important;
    }
    /* Keep bottom border on the left headers */
    #scoreTable thead th.hole-header,
    #scoreTable thead th.par-header {
      border-bottom: 1px solid #666;
    }

    /* Remove right border from par cells (hole rows only) */
    #scoreTable tbody tr:not(.summary-row) td.par-cell {
      border-right: none !important;
    }
    /* Keep the OUT/IN summary par cell borders the same */
    #scoreTable tbody tr.summary-row td.par-cell {
      border-right: 1px solid #666 !important;
    }

    /* Hole lock visuals */
    #scoreBody tr.active-hole td.score-cell {
      background: rgba(0, 0, 0, 0.03);
    }
    #scoreBody tr.show-placeholders td.score-cell {
      background: rgba(0, 0, 0, 0.03);
    }
    #scoreBody tr.show-placeholders td.score-cell:empty::before {
      content: attr(data-placeholder);
      color: var(--ph-color);
      font-weight: normal;
      font-style: normal;
      pointer-events: none;
      display: block;
      width: 100%;
      line-height: var(--row-h);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Make hole number tappable to lock/unlock */
    #scoreBody tr:not(.summary-row) .hole-cell { cursor: pointer; }

    * { -webkit-tap-highlight-color: transparent; }

    /* Popup/modal: Par reset (kept) */
    #popupModal {
      display: none;
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 12px 20px;
      z-index: 1000; text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
      font-family: 'Economica', sans-serif;
    }
    #popupModal, #roundManagementModal, #playerNameModal, #scorePad { text-align: center; }
    #popupModal h2, #roundManagementModal h2, #playerNameModal h2, #scorePad h2 { margin: 15px 0; padding: 0; }

    #popupModal button {
      font-size: 24px; padding: 10px 20px; margin: 2px; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s;
    }

    /* Popup grid (Par reset) */
    #popupOptions {
      display: grid; grid-template-columns: repeat(5, 40px); gap: 5px; justify-content: center;
      padding: 10px 0; box-sizing: border-box;
    }
    #popupOptions .popup-spacer {
      width: 40px; height: 40px; visibility: hidden; pointer-events: none;
    }
    #popupOptions button {
      width: 40px; height: 40px; font-size: 24px; padding: 0; margin: 0; box-sizing: border-box;
      cursor: pointer; font-family: 'Economica', sans-serif, Arial; display: flex; justify-content: center; align-items: center;
      text-align: center; overflow: hidden; white-space: nowrap;
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s ease;
      -webkit-appearance: none; appearance: none; line-height: 1; outline: none;
    }

    .close-btn {
      position: absolute; top: 0px; right: 0px;
      font-size: 48px; color: #000000; cursor: pointer; background: none; border: none;
      padding: 0; line-height: 1; width: 40px; height: 40px; text-align: center; transition: color 0.2s ease;
    }

    /* Round management modal */
    #roundManagementModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px; text-align: center;
    }
    #roundManagementModal select {
      font-size: 24px; padding: 10px; margin: 5px 0;
      font-family: 'Economica', sans-serif; border: 1px solid #262626; border-radius: 6px;
      background: #f8f9fa; width: 100%; box-sizing: border-box;
      text-align: center; text-align-last: center; -moz-text-align-last: center;
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; padding-right: 12px;
    }
    #roundManagementModal select#playerCount {
      text-align: center; text-align-last: center; -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; background-color: #f8f9fa; padding-right: 12px;
    }
    #roundManagementModal select#playerCount::-ms-expand { display: none; }
    #roundManagementModal select#playerCount option { text-align: center; }

    #roundManagementModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #roundManagementModal button#sortByRankBtn {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }
    #roundManagementModal button#sortByRankBtn.active {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #ffffff; border: 1px solid #262626;
    }
    #roundManagementModal button#resetButton[data-confirm="true"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }

    /* Player Name Modal */
    #playerNameModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; text-align: center; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
    }
    #playerNameModal h2 { margin: 15px 0; padding: 0; }
    #playerNameModal input[type="text"] {
      font-size: 24px; padding: 10px; width: 100%; box-sizing: border-box; margin: 5px 0; text-align: center;
      font-family: 'Economica', sans-serif; border: 1px solid #d0d7de; border-radius: 6px; background: #ffffff;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); transition: border-color 0.2s ease;
    }
    #playerNameModal input[type="text"]:focus { outline: none; border: 1px solid #262626; }
    #playerNameModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #playerNameModal button[data-state="confirm"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }
    #playerNameModal button.light {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }

    /* Segmented control */
    .segmented-control {
      display: flex; width: 100%; box-sizing: border-box; margin: 5px 0;
      background: #f8f9fa; border-radius: 6px; overflow: hidden; border: 1px solid #262626;
    }
    .segmented-control input[type="radio"] { display: none; }
    .segmented-control label {
      flex: 1 1 0; padding: 10px 0; text-align: center; font-size: 24px; font-family: 'Economica', sans-serif;
      cursor: pointer; user-select: none; background: #f8f9fa; margin: 0;
    }
    .segmented-control input[type="radio"]:checked + label {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff;
    }

    /* Emoji grid */
    .emoji-grid {
      --emoji-gap: 8px;
      display: grid; grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: var(--emoji-gap); padding: 0; margin: 5px 0; width: 100%; box-sizing: border-box;
      user-select: none; -webkit-user-select: none;
    }
    #playerNameModal .emoji-grid .emoji-pick {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: #ffffff; border: none; border-radius: 6px;
      font-family: 'Economica', sans-serif; font-size: 22px;
      display: grid; place-items: center;
      width: 100%; aspect-ratio: 1 / 1; padding: 0; margin: 0; line-height: 1; cursor: pointer;
      transition: transform 0.05s ease, filter 0.1s ease;
      box-sizing: border-box; position: relative;
      -webkit-appearance: none; appearance: none; outline: none;
      padding-bottom: 2px;
    }
    #playerNameModal .emoji-grid .emoji-pick:active { transform: scale(0.95); filter: brightness(1.05); }
    .emoji-grid .emoji-pick.selected { box-shadow: 0 0 0 2px #262626 inset; }
    .emoji-grid .emoji-pick.selected::before {
      content: ""; position: absolute; inset: 0; background: rgba(0, 0, 0, 0.35);
      border-radius: 6px; pointer-events: none; z-index: 1;
    }
    .emoji-grid .emoji-pick.selected::after {
      content: attr(data-order); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%);
      font-size: 28px; font-weight: 700; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 3px rgba(0,0,0,0.7);
      pointer-events: none; z-index: 2;
    }

    /* Bulk toolbar spacing */
    .bulk-actions { display: none; margin: 5px 0 0 0; width: 100%; }
    .bulk-actions .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: center; width: 100%; }
    #playerNameModal .segmented-control { margin-top: 5px; }
    #playerNameModal .emoji-grid { margin: 5px 0 10px; }
    #playerNameModal.bulk-mode .emoji-grid { margin-bottom: 5px; }
    #playerNameModal .bulk-actions { margin-top: 0; }

    /* Overlay */
    #overlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999; cursor: pointer;
    }

    /* Drag feedback */
    th.dragging { opacity: 0.5; }

    /* Round modal: theme-colored option text */
    #roundManagementModal select#themeColorSelect {
      text-align: center; text-align-last: center; -moz-text-align-last: center;
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; background-color: #f8f9fa; padding-right: 12px;
    }
    #roundManagementModal select#themeColorSelect::-ms-expand { display: none; }
    #roundManagementModal select#themeColorSelect option { text-align: center; }

    /* Score Pad (custom popup keyboard) */
    #scorePad {
      display: none;
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 16px 20px 20px 20px; z-index: 1002;
      width: 260px; max-width: 90%; font-family: 'Economica', sans-serif;
      box-shadow: 0 8px 28px rgba(0,0,0,0.18); border-radius: 12px;
    }
    #scorePad h2 {
      font-size: 24px; margin: 10px 0 6px; padding: 0; line-height: 1.2;
    }
    #scorePad .pad-subtitle { font-size: 16px; color: #555; margin-bottom: 10px; }
    #scorePad .pad-row {
      display: grid; grid-template-columns: 1fr auto 1fr; align-items: center; gap: 10px; margin: 8px 0 12px;
    }
    #scorePad .pad-value {
      min-width: 60px; text-align: center; font-size: 40px; font-weight: 700; line-height: 1; padding: 6px 0;
      border-radius: 8px; background: #f3f4f6; color: #111827;
    }
    #scorePad .pad-btn {
      font-size: 34px; padding: 10px 0; cursor: pointer; border: none; border-radius: 8px;
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff;
      transition: filter 0.12s ease; -webkit-appearance: none; appearance: none;
    }
    #scorePad .pad-btn:active { filter: brightness(1.08); }
    #scorePad .pad-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    #scorePad .pad-actions .light {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }
    #scorePad .pad-actions button {
      font-size: 20px; padding: 10px 0; border-radius: 8px; cursor: pointer; border: none;
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff;
    }
    #scorePad .close-btn { top: -2px; right: 2px; }
  </style>
</head>
<body>

  <!-- Score Table -->
  <table id="scoreTable">
    <thead>
      <tr id="playerRow">
        <th class="hole-header" onclick="showRoundManagement()"><button class="gear" title="Round settings">☰</button></th>
        <th class="par-header" onclick="showParResetPopup()">Par</th>
        <!-- Player headers are generated dynamically -->
      </tr>
    </thead>
    <tbody id="scoreBody"></tbody>
  </table>

  <!-- Par popup -->
  <div id="popupModal">
    <h2 id="popupTitle">Select</h2>
    <span class="close-btn" onclick="closePopupModal()">×</span>
    <div id="popupOptions"></div>
  </div>

  <!-- Round Management -->
  <div id="roundManagementModal">
    <h2>Round</h2>
    <span class="close-btn" onclick="closeRoundManagement()">×</span>

    <select id="playerCount" onchange="updatePlayerCount()">
      <option value="1">1 Players</option>
      <option value="2">2 Players</option>
      <option value="3">3 Players</option>
      <option value="4">4 Players</option>
      <option value="5">5 Players</option>
      <option value="6">6 Players</option>
      <option value="7">7 Players</option>
      <option value="8">8 Players</option>
    </select>

    <div class="segmented-control" id="holesSegment">
      <input type="radio" id="holes9" name="holesCount" value="9" onchange="setHolesCount(9)">
      <label for="holes9">9 Holes</label>
      <input type="radio" id="holes18" name="holesCount" value="18" onchange="setHolesCount(18)">
      <label for="holes18">18 Holes</label>
    </div>

    <button id="sortByRankBtn" onclick="toggleSortByRank()">Sort by Rank</button>
    <select id="themeColorSelect" onchange="setThemeColor(this.value)">
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="pink">Pink</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="green">Green</option>
      <option value="grey">Grey</option>
    </select>
    <button id="resetButton" onclick="handleResetClick()">Reset</button>
  </div>

  <!-- Player Name Modal -->
  <div id="playerNameModal"></div>

  <!-- Custom Score Pad (no native keyboard) -->
  <div id="scorePad" role="dialog" aria-modal="true" aria-labelledby="padTitle">
    <h2 id="padTitle">Hole 1 — Player</h2>
    <div class="pad-subtitle" id="padSubtitle"></div>
    <span class="close-btn" onclick="closeScorePad()">×</span>
    <div class="pad-row">
      <button type="button" id="padMinus" class="pad-btn" aria-label="Decrease">−</button>
      <div id="padValue" class="pad-value">3</div>
      <button type="button" id="padPlus" class="pad-btn" aria-label="Increase">+</button>
    </div>
    <div class="pad-actions">
      <button type="button" id="padClear" class="light">Clear Score</button>
      <button type="button" id="padNext">Next Player ➜</button>
    </div>
  </div>

  <!-- Overlay -->
  <div id="overlay"></div>

  <script>
    /* ---------------- State / storage ---------------- */
    const LS = {
      holesCount: 'dg-holesCount',
      playerCount: 'dg-playerCount',
      themeColor: 'dg-themeColor',
      sort: 'dg-sortByRankEnabled',
      emojiMode: 'dg-emojiModeEnabled',
      name: (p) => `dg-playerName-${p}`,
      par:  (h) => `dg-par-H${h}`,
      score:(p,h)=> `dg-${p}-H${h}`,
    };

    const THEME_MAP = {
      blue:   { h: 210, s: 85 },
      red:    { h:   0, s: 78 },
      green:  { h: 120, s: 50 },
      pink:   { h: 330, s: 70 },
      purple: { h: 268, s: 70 },
      yellow: { h:  45, s: 90 },
      grey:   { h: 210, s:  0 }
    };
    function getThemeHS(key) { return THEME_MAP[key] || THEME_MAP.blue; }
    function getThemeTextColor(key) {
      const t = THEME_MAP[key] || THEME_MAP.blue;
      const L = key === 'yellow' ? 32 : 34;
      return `hsl(${t.h}, ${t.s}%, ${L}%)`;
    }
    function applyThemeSelectColors() {
      const select = document.querySelector('#roundManagementModal select#themeColorSelect');
      if (!select) return;
      select.style.color = getThemeTextColor(themeColor);
      Array.from(select.options).forEach(opt => { opt.style.color = getThemeTextColor(opt.value); });
    }

    const KEYCAP_DIGITS = ["0️⃣","1️⃣","2️⃣","3️⃣","4️⃣","5️⃣","6️⃣","7️⃣","8️⃣","9️⃣"];
    function numberToKeycap(n) { return KEYCAP_DIGITS[n] || String(n); }
    function keycapToNumber(str) {
      const idx = KEYCAP_DIGITS.indexOf(str);
      return idx === -1 ? null : idx;
    }
    function extractEmojis(str) {
      if (!str) return '';
      let segments;
      if (typeof Intl !== 'undefined' && Intl.Segmenter) {
        segments = Array.from(new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(str), s => s.segment);
      } else { segments = Array.from(str); }
      const rePict = /\p{Extended_Pictographic}/u;
      const reRI = /[\u{1F1E6}-\u{1F1FF}]/u;
      const reKeycap = /[#*0-9]\uFE0F?\u20E3/u;
      const reVS16 = /\uFE0F/u;
      const reTagFlag = /\u{1F3F4}[\u{E0061}-\u{E007A}]{1,14}\u{E007F}/u;
      return segments.filter(seg =>
        rePict.test(seg) || reRI.test(seg) || reKeycap.test(seg) || reVS16.test(seg) || reTagFlag.test(seg)
      ).join('');
    }

    let themeColor = localStorage.getItem(LS.themeColor) || 'blue';
    let holesCount = [9,18].includes(parseInt(localStorage.getItem(LS.holesCount),10)) ? parseInt(localStorage.getItem(LS.holesCount),10) : 18;
    let playerCount = Math.min(8, Math.max(1, parseInt(localStorage.getItem(LS.playerCount) || '4', 10)));
    let sortByRankEnabled = localStorage.getItem(LS.sort) === 'true';
    let emojiModeEnabled = localStorage.getItem(LS.emojiMode) === 'true';

    // Score pad state
    let padState = {
      mode: 'score', // 'score' | 'par'
      hole: null,    // number
      holeId: null,  // "H#"
      player: null,  // "P#"
      td: null,      // active cell td
      value: null    // number|null
    };

    // One-hole-at-a-time scoring
    let lockedHole = null; // e.g., "H3"
    function setLockedHole(holeId) {
      lockedHole = holeId;
      updateHoleLockVisuals();
      syncHolePlaceholderState();
    }
    function clearLockedHole() {
      lockedHole = null;
      updateHoleLockVisuals();
      syncHolePlaceholderState();
    }
    function updateHoleLockVisuals() {
      const rows = document.querySelectorAll('#scoreBody tr');
      rows.forEach(tr => {
        tr.classList.remove('active-hole','inactive-hole');
        if (!lockedHole) return;
        if (tr.classList.contains('summary-row')) return;
        const rowHole = tr.querySelector('td.par-cell')?.getAttribute('data-hole') || null;
        if (rowHole === lockedHole) tr.classList.add('active-hole');
      });
    }
    function getScoreCellsInHole(holeId) {
      return Array.from(document.querySelectorAll(`#scoreBody td.score-cell[data-hole="${holeId}"]`));
    }
    function clearLockedHoleIfComplete(holeNum) {
      if (!lockedHole || !holeNum) return;
      if (`H${holeNum}` === lockedHole && isHoleComplete(holeNum)) {
        clearLockedHole();
      }
    }

    /* -------- Placeholders -------- */
    function getHoleRowEl(holeId) {
      const parCell = document.querySelector(`#scoreBody td.par-cell[data-hole="${holeId}"]`);
      return parCell ? parCell.parentElement : null;
    }
    function showHolePlaceholders(holeId) {
      const target = lockedHole || holeId;
      document.querySelectorAll('#scoreBody tr.show-placeholders')
        .forEach(tr => tr.classList.remove('show-placeholders'));
      const row = getHoleRowEl(target);
      if (row) row.classList.add('show-placeholders');
    }
    function clearHolePlaceholders() {
      document.querySelectorAll('#scoreBody tr.show-placeholders')
        .forEach(tr => tr.classList.remove('show-placeholders'));
    }
    function syncHolePlaceholderState() {
      if (lockedHole) {
        showHolePlaceholders(lockedHole);
      } else if (padState.td) {
        const hid = padState.td.getAttribute('data-hole');
        if (hid) showHolePlaceholders(hid);
        else clearHolePlaceholders();
      } else {
        clearHolePlaceholders();
      }
    }
    function getPlayerDisplayName(pid) {
      const el = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      return el?.getAttribute('data-full') || el?.textContent || pid;
    }
    function getPlayerTrimmedName(pid) {
      const el = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      const trimmed = el?.textContent?.trim();
      return trimmed || getPlayerDisplayName(pid);
    }
    function updatePlaceholdersForPlayer(pid) {
      const nm = getPlayerTrimmedName(pid);
      document.querySelectorAll(`#scoreBody td.score-cell[data-player="${pid}"]`)
        .forEach(td => td.setAttribute('data-placeholder', nm));
    }
    function updateAllPlaceholders() {
      for (let p = 1; p <= playerCount; p++) updatePlaceholdersForPlayer(`P${p}`);
    }

    // Drag & drop state
    let draggedIndex = -1;

    /* ---------------- Init ---------------- */
    document.addEventListener('DOMContentLoaded', () => {
      const pcSel = document.getElementById('playerCount');
      if (pcSel) pcSel.value = String(playerCount);
      const themeSel = document.getElementById('themeColorSelect');
      if (themeSel) themeSel.value = themeColor;
      applyThemeSelectColors();

      const holes9 = document.getElementById('holes9');
      const holes18 = document.getElementById('holes18');
      if (holes9 && holes18) {
        holes9.checked = holesCount === 9;
        holes18.checked = holesCount === 18;
      }

      buildTable();
      loadFromStorage();
      updateAllTotals();
      updateRanks();
      fitRowsToViewport();

      clipPlayerNamesToCell();
      updateAllPlaceholders();

      attachDragListeners();

      const sortBtn = document.getElementById('sortByRankBtn');
      if (sortBtn) sortBtn.classList.toggle('active', sortByRankEnabled);

      initScorePad();
    });

    window.addEventListener('resize', () => {
      clipPlayerNamesToCell();
      updateAllPlaceholders();
      fitRowsToViewport();
    });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        clipPlayerNamesToCell();
        updateAllPlaceholders();
        fitRowsToViewport();
      }, 250);
    });

    function onHeaderClick(e) {
      const th = e.currentTarget;
      const pid = th.getAttribute('data-player');
      window.currentPlayer = pid;
      openPlayerModalForHeader(pid);
    }

    /* ---------------- Build ---------------- */
    function buildTable() {
      const headerRow = document.getElementById('playerRow');
      headerRow.innerHTML = `
        <th class="hole-header" onclick="showRoundManagement()"><button class="gear" title="Round settings">☰</button></th>
        <th class="par-header" onclick="showParResetPopup()">Par</th>
      `;

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        const th = document.createElement('th');
        th.setAttribute('data-player', pid);
        th.title = savedName;
        th.innerHTML = `
          <span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span>
          <div id="total${pid}"></div>
          <div class="to-par-line" id="toPar${pid}"></div>
        `;
        th.addEventListener('click', onHeaderClick);
        headerRow.appendChild(th);
      }

      const body = document.getElementById('scoreBody');
      body.innerHTML = '';

      const firstNine = Math.min(9, holesCount);
      for (let h = 1; h <= firstNine; h++) body.appendChild(makeHoleRow(h));

      // OUT summary
      const trOut = document.createElement('tr');
      trOut.className = 'summary-row';
      trOut.appendChild(makeStickyCell('hole-cell', 'OUT'));
      const outPar = document.createElement('td'); outPar.className = 'par-cell'; outPar.setAttribute('data-sum', 'out-par');
      trOut.appendChild(outPar);
      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td'); td.setAttribute('data-sum', `out-P${p}`); trOut.appendChild(td);
      }
      body.appendChild(trOut);

      if (holesCount > 9) {
        for (let h = 10; h <= holesCount; h++) body.appendChild(makeHoleRow(h));
        // IN summary
        const trIn = document.createElement('tr');
        trIn.className = 'summary-row';
        trIn.appendChild(makeStickyCell('hole-cell', 'IN'));
        const inPar = document.createElement('td'); inPar.className = 'par-cell'; inPar.setAttribute('data-sum', 'in-par');
        trIn.appendChild(inPar);
        for (let p = 1; p <= playerCount; p++) {
          const td = document.createElement('td'); td.setAttribute('data-sum', `in-P${p}`); trIn.appendChild(td);
        }
        body.appendChild(trIn);
      }

      clearLockedHole();
      updateAllPlaceholders();
    }
    function makeStickyCell(cls, text) {
      const td = document.createElement('td');
      td.className = cls;
      td.textContent = text;
      return td;
    }
    function makeHoleRow(h) {
      const tr = document.createElement('tr');

      const tdHole = document.createElement('td');
      tdHole.className = 'hole-cell';
      tdHole.textContent = String(h);
      tdHole.addEventListener('click', () => {
        const holeId = `H${h}`;
        if (!lockedHole) setLockedHole(holeId);
        else if (lockedHole === holeId) clearLockedHole();
      });
      tr.appendChild(tdHole);

      const tdPar = document.createElement('td');
      tdPar.className = 'par-cell';
      tdPar.setAttribute('data-hole', `H${h}`);
      tdPar.addEventListener('click', () => openParPad(h));
      tdPar.textContent = '3';
      tr.appendChild(tdPar);

      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.className = 'score-cell';
        td.setAttribute('data-player', `P${p}`);
        td.setAttribute('data-hole', `H${h}`);
        td.addEventListener('click', () => openScorePad(td));
        tr.appendChild(td);
      }
      return tr;
    }

    /* ---------------- Storage load ---------------- */
    function loadFromStorage() {
      // Pars
      for (let h = 1; h <= holesCount; h++) {
        const savedPar = parseInt(localStorage.getItem(LS.par(h)) || '3', 10);
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = String(savedPar);
      }
      // Scores
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const saved = localStorage.getItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && saved != null) td.textContent = saved;
        }
      }
      // Names
      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const headerName = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        const savedName = localStorage.getItem(LS.name(pid));
        if (headerName && savedName) {
          headerName.textContent = savedName;
          headerName.setAttribute('data-full', savedName);
          headerName.setAttribute('title', savedName);
        }
      }
      updateAllPlaceholders();
    }

    /* ---------------- Custom Score Pad ---------------- */
    function initScorePad() {
      const minus = document.getElementById('padMinus');
      const plus = document.getElementById('padPlus');
      const clearBtn = document.getElementById('padClear');
      const nextBtn = document.getElementById('padNext');

      minus.addEventListener('click', () => {
        if (padState.value == null) padState.value = 1;
        padState.value = Math.max(1, (parseInt(padState.value, 10) || 1) - 1);
        applyPadValue();
      });
      plus.addEventListener('click', () => {
        if (padState.value == null) padState.value = 1;
        padState.value = Math.max(1, (parseInt(padState.value, 10) || 1) + 1);
        applyPadValue();
      });
      clearBtn.addEventListener('click', () => {
        if (padState.mode !== 'score' || !padState.td) return;
        const { player, hole } = padState;
        padState.value = null;
        setScore(player, hole, null, true);
        updatePadUI();
      });
      nextBtn.addEventListener('click', () => {
        if (padState.mode !== 'score' || !padState.td) return;
        goToNextPlayerInHole();
      });
    }

    function openScorePad(td) {
      const holeId = td.getAttribute('data-hole'); // e.g. "H3"
      if (lockedHole && lockedHole !== holeId) return;

      // Lock this hole on first tap
      if (!lockedHole) setLockedHole(holeId);

      const hole = parseInt(holeId.replace('H',''), 10);
      const pid = td.getAttribute('data-player');
      const playerName = getPlayerTrimmedName(pid);
      const par = getPar(hole);

      // If empty, auto-fill with par
      if (td.textContent.trim() === '') {
        td.textContent = String(par);
        localStorage.setItem(LS.score(pid, hole), String(par));
      }

      padState.mode = 'score';
      padState.hole = hole;
      padState.holeId = holeId;
      padState.player = pid;
      padState.td = td;
      padState.value = (parseInt(td.textContent || '', 10) || null);

      const pad = document.getElementById('scorePad');
      const title = document.getElementById('padTitle');
      const subtitle = document.getElementById('padSubtitle');
      const clearBtn = document.getElementById('padClear');
      const nextBtn = document.getElementById('padNext');

      title.textContent = `Hole ${hole} — ${playerName}`;
      subtitle.textContent = 'Adjust strokes with − / +';
      clearBtn.style.display = '';
      nextBtn.style.display = '';

      updatePadUI();

      pad.style.display = 'block';
      showOverlay();
      syncHolePlaceholderState();
    }

    function openParPad(hole) {
      const holeId = `H${hole}`;
      if (lockedHole && lockedHole !== holeId) return;

      if (!lockedHole) setLockedHole(holeId);

      const parCell = document.querySelector(`.par-cell[data-hole="${holeId}"]`);
      const currentPar = parseInt(parCell?.textContent || '3', 10) || 3;

      padState.mode = 'par';
      padState.hole = hole;
      padState.holeId = holeId;
      padState.player = null;
      padState.td = parCell;
      padState.value = currentPar;

      const pad = document.getElementById('scorePad');
      const title = document.getElementById('padTitle');
      const subtitle = document.getElementById('padSubtitle');
      const clearBtn = document.getElementById('padClear');
      const nextBtn = document.getElementById('padNext');

      title.textContent = `Hole ${hole} — Par`;
      subtitle.textContent = 'Adjust par with − / +';
      clearBtn.style.display = 'none';
      nextBtn.style.display = 'none';

      updatePadUI();

      pad.style.display = 'block';
      showOverlay();
      syncHolePlaceholderState();
    }

    function updatePadUI() {
      const valEl = document.getElementById('padValue');
      valEl.textContent = padState.value == null ? '—' : String(padState.value);
      // Persist immediately
      if (padState.mode === 'score' && padState.player && padState.hole) {
        setScore(padState.player, padState.hole, padState.value, true);
      } else if (padState.mode === 'par' && padState.hole) {
        setPar(padState.hole, Math.max(1, parseInt(padState.value || 3, 10)), true);
      }
    }

    function applyPadValue() {
      updatePadUI();
      updateAllTotals();
      updateRanks();
      if (padState.mode === 'score') clearLockedHoleIfComplete(padState.hole);
    }

    function goToNextPlayerInHole() {
      const cells = getScoreCellsInHole(padState.holeId);
      const idx = cells.indexOf(padState.td);
      if (idx === -1) { closeScorePad(); return; }
      let nextIdx = idx + 1;
      let wrapped = false;
      if (nextIdx >= cells.length) { nextIdx = 0; wrapped = true; }
      const nextTd = cells[nextIdx];
      if (!nextTd) { closeScorePad(); return; }

      // If the next cell is empty, auto-fill with par
      const hole = padState.hole;
      const nextPid = nextTd.getAttribute('data-player');
      if (nextTd.textContent.trim() === '') {
        const par = getPar(hole);
        nextTd.textContent = String(par);
        localStorage.setItem(LS.score(nextPid, hole), String(par));
      }

      openScorePad(nextTd);

      if (wrapped && isHoleComplete(hole)) {
        closeScorePad();
        clearLockedHole();
      }
    }

    function closeScorePad() {
      const pad = document.getElementById('scorePad');
      pad.style.display = 'none';
      hideOverlay();
      updateAllTotals();
      updateRanks();
      clearLockedHoleIfComplete(padState.hole);
      padState = { mode: 'score', hole: null, holeId: null, player: null, td: null, value: null };
      syncHolePlaceholderState();
    }

    // Helpers to persist score/par
    function setScore(player, hole, value, quiet = false) {
      const td = document.querySelector(`td.score-cell[data-player="${player}"][data-hole="H${hole}"]`);
      if (!td) return;
      if (value == null || value === '') {
        td.textContent = '';
        localStorage.removeItem(LS.score(player, hole));
      } else {
        const n = Math.max(1, parseInt(value, 10) || 1);
        td.textContent = String(n);
        localStorage.setItem(LS.score(player, hole), String(n));
      }
      if (!quiet) { updateAllTotals(); updateRanks(); }
    }
    function setPar(hole, value, quiet = false) {
      const cell = document.querySelector(`.par-cell[data-hole="H${hole}"]`);
      if (!cell) return;
      const n = Math.max(1, parseInt(value, 10) || 3);
      cell.textContent = String(n);
      localStorage.setItem(LS.par(hole), String(n));
      if (!quiet) { updateAllTotals(); updateRanks(); }
    }

    /* ---------------- Round Management ---------------- */
    function showRoundManagement() {
      const pcSel = document.getElementById('playerCount');
      const themeSel = document.getElementById('themeColorSelect');
      const sortBtn = document.getElementById('sortByRankBtn');

      pcSel.value = String(playerCount);
      themeSel.value = themeColor;
      sortBtn.classList.toggle('active', sortByRankEnabled);

      const holes9 = document.getElementById('holes9');
      const holes18 = document.getElementById('holes18');
      if (holes9 && holes18) {
        holes9.checked = holesCount === 9;
        holes18.checked = holesCount === 18;
      }

      document.getElementById('roundManagementModal').style.display = 'block';
      applyThemeSelectColors();
      showOverlay();
      resetButtonState();
    }
    function closeRoundManagement() {
      resetButtonState();
      document.getElementById('roundManagementModal').style.display = 'none';
      hideOverlay();
    }

    let resetConfirm = false;
    function handleResetClick() {
      const btn = document.getElementById('resetButton');
      if (!resetConfirm) {
        resetConfirm = true;
        btn.textContent = 'Confirm';
        btn.setAttribute('data-confirm', 'true');
      } else {
        resetScores();
        resetButtonState();
      }
    }
    function resetButtonState() {
      resetConfirm = false;
      const btn = document.getElementById('resetButton');
      if (btn) { btn.textContent = 'Reset'; btn.removeAttribute('data-confirm'); }
    }

    function updatePlayerCount() {
      const val = parseInt(document.getElementById('playerCount').value, 10);
      const newCount = Math.min(8, Math.max(1, val));

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));
      const existing = headerRow.children.length - 2; // exclude hole + par

      // Remove extra players
      if (newCount < existing) {
        for (let i = existing; i > newCount; i--) {
          const pid = `P${i}`;
          if (headerRow.lastElementChild) headerRow.removeChild(headerRow.lastElementChild);
          rows.forEach(tr => { if (tr.lastElementChild) tr.removeChild(tr.lastElementChild); });
          localStorage.removeItem(LS.name(pid));
          for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(pid, h));
        }
      }

      // Add new players
      if (newCount > existing) {
        for (let i = existing + 1; i <= newCount; i++) {
          const pid = `P${i}`;
          const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && i <= 9 ? numberToKeycap(i) : pid);

          const th = document.createElement('th');
          th.setAttribute('data-player', pid);
          th.title = savedName;
          th.innerHTML = `
            <span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span>
            <div id="total${pid}"></div>
            <div class="to-par-line" id="toPar${pid}"></div>
          `;
          th.addEventListener('click', onHeaderClick);
          headerRow.appendChild(th);

          rows.forEach(tr => {
            const first = tr.firstElementChild;
            const isSummary = tr.classList.contains('summary-row');
            const td = document.createElement('td');
            if (!isSummary) {
              const holeNo = parseInt(tr.querySelector('.hole-cell')?.textContent || '0', 10);
              td.className = 'score-cell';
              td.setAttribute('data-player', pid);
              td.setAttribute('data-hole', `H${holeNo}`);
              td.addEventListener('click', () => openScorePad(td));
              const saved = localStorage.getItem(LS.score(pid, holeNo));
              if (saved != null) td.textContent = saved;
            } else {
              const label = first?.textContent?.trim() || '';
              if (label === 'OUT') td.setAttribute('data-sum', `out-${pid}`);
              if (label === 'IN') td.setAttribute('data-sum', `in-${pid}`);
            }
            tr.appendChild(td);
          });
        }
      }

      playerCount = newCount;
      localStorage.setItem(LS.playerCount, String(playerCount));
      updateAllTotals();
      applySortByRankIfHoleComplete(null, true);
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
      attachDragListeners();
      closeRoundManagement();
    }

    function setHolesCount(val) {
      const n = parseInt(val, 10);
      holesCount = [9, 18].includes(n) ? n : 18;
      localStorage.setItem(LS.holesCount, String(holesCount));
      rebuildPreserving();
      updateRanks();
    }

    function toggleSortByRank() {
      sortByRankEnabled = !sortByRankEnabled;
      localStorage.setItem(LS.sort, String(sortByRankEnabled));
      const btn = document.getElementById('sortByRankBtn');
      if (btn) btn.classList.toggle('active', sortByRankEnabled);
      if (sortByRankEnabled) applySortByRankIfHoleComplete(null, false);
      updateRanks();
      attachDragListeners();
    }
    function setThemeColor(value) {
      themeColor = value || 'blue';
      localStorage.setItem(LS.themeColor, themeColor);
      applyThemeSelectColors();
      updateScoreColors();
      updateToParBadgeColors();
      updateRanks();
    }

    // Only reset scores; do NOT reset pars
    function resetScores() {
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(`P${p}`, h));
      }
      document.querySelectorAll('#scoreBody td.score-cell').forEach(td => td.textContent = '');
      clearLockedHole();
      updateAllTotals();
      updateRanks();
      closeRoundManagement();
    }

    /* ---------------- Player naming ---------------- */
    function openPlayerModalForHeader(pid) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      const currentName = header?.getAttribute('data-full') || header?.textContent || pid;
      window.currentPlayer = pid;
      if (emojiModeEnabled) openEmojiPlayerModal(currentName);
      else openTextPlayerModal(currentName);
    }

    function openTextPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">×</span>
        <input type="text" id="playerNameInput"
               value="${(currentName || '').toUpperCase()}"
               autocapitalize="characters"
               inputmode="text"
               autocomplete="off" autocorrect="off" spellcheck="false"
               style="text-transform: uppercase;">
        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      const input = document.getElementById('playerNameInput');
      input.addEventListener('focus', function () {
        try { this.select(); } catch (_) {}
        try { this.setSelectionRange(0, this.value.length); } catch (_) {}
      });
      let primed = false;
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => {
          try { input.select(); } catch (_) {}
          try { input.setSelectionRange(0, input.value.length); } catch (_) {}
        });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', e => e.preventDefault());
      input.addEventListener('contextmenu', e => e.preventDefault());
      input.addEventListener('input', function(){ this.value = this.value.toUpperCase(); });
      input.addEventListener('keydown', function(e){
        if (e.key === 'Enter') {
          e.preventDefault();
          const newName = (this.value || '').trim().toUpperCase();
          if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
          closePlayerNameModal();
        }
      });
      input.addEventListener('blur', function(){
        const newName = (this.value || '').trim().toUpperCase();
        if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
      });
    }

    function openEmojiPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      const favEmojis = [
        "🍔","🩰","🌹","🌰","🔔",
        "👑","🎣","🌻","🏏","🦈",
        "🤸🏼‍♀️","🎁","🕊️","🧶","🛠️",
        "🏃"
      ];
      const grid = favEmojis.map(e => `<button type="button" class="emoji-pick" data-emoji="${e}">${e}</button>`).join('');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">×</span>
        <input type="text" id="emojiNameInput" value="${currentName || ''}"
               inputmode="text" placeholder="Pick an emoji" enterkeyhint="done"
               autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">
        <div class="emoji-grid">${grid}</div>

        <div id="bulkEmojiActions" class="bulk-actions">
          <div class="row">
            <button type="button" id="bulkCancelBtn" class="light">Cancel</button>
            <button type="button" id="bulkApplyBtn">Select</button>
          </div>
        </div>

        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      let primed = false;
      const input = document.getElementById('emojiNameInput');
      input.addEventListener('focus', function () {
        try { this.select(); } catch (_) {}
        try { this.setSelectionRange(0, this.value.length); } catch (_) {}
      });
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => {
          try { input.select(); } catch (_) {}
          try { input.setSelectionRange(0, input.value.length); } catch (_) {}
        });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', (e) => e.preventDefault());
      input.addEventListener('contextmenu', (e) => e.preventDefault());

      let autoClosed = false;
      input.addEventListener('input', function () {
        const sanitized = extractEmojis(this.value);
        if (sanitized !== this.value) this.value = sanitized;
        if (sanitized && !autoClosed) {
          if (window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          autoClosed = true;
          closePlayerNameModal();
        }
      });
      input.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          const sanitized = extractEmojis((this.value || '').trim());
          if (sanitized && window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          closePlayerNameModal();
        }
      });

      attachEmojiGridInteractions();
    }

    function setEmojiMode(enabled, reopenForPlayerId = null) {
      emojiModeEnabled = !!enabled;
      localStorage.setItem(LS.emojiMode, emojiModeEnabled ? 'true' : 'false');
      syncDefaultNamesToMode();
      if (reopenForPlayerId) openPlayerModalForHeader(reopenForPlayerId);
      updateRanks();
    }
    function toggleEmojiMode() { setEmojiMode(!emojiModeEnabled); }

    function handleRemovePlayer(button) {
      if (button.dataset.state === 'initial') {
        button.textContent = 'Confirm';
        button.dataset.state = 'confirm';
      } else {
        if (window.currentPlayer) {
          removePlayer(window.currentPlayer);
          closePlayerNameModal();
        }
      }
    }

    function removePlayer(pid) {
      const removedIdx = parseInt(pid.replace('P',''), 10) - 1;
      if (playerCount <= 1) { alert('At least one player must remain.'); return false; }

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      if (headerRow.children[removedIdx + 2]) headerRow.removeChild(headerRow.children[removedIdx + 2]);
      rows.forEach(row => { if (row.children[removedIdx + 2]) row.removeChild(row.children[removedIdx + 2]); });

      for (let p = removedIdx + 2; p <= playerCount; p++) {
        const oldPid = `P${p}`, newPid = `P${p-1}`;
        const name = localStorage.getItem(LS.name(oldPid));
        if (name != null) {
          localStorage.setItem(LS.name(newPid), name);
          localStorage.removeItem(LS.name(oldPid));
        }
        for (let h = 1; h <= 18; h++) {
          const oldKey = LS.score(oldPid, h);
          const val = localStorage.getItem(oldKey);
          localStorage.removeItem(oldKey);
          if (val != null) localStorage.setItem(LS.score(newPid, h), val);
        }
      }
      const trailingPid = `P${playerCount}`;
      localStorage.removeItem(LS.name(trailingPid));
      for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(trailingPid, h));

      playerCount -= 1;
      localStorage.setItem(LS.playerCount, String(playerCount));
      const pcSel = document.getElementById('playerCount');
      if (pcSel) pcSel.value = String(playerCount);

      for (let i = removedIdx; i < playerCount; i++) {
        const newPid = `P${i+1}`;
        const th = headerRow.children[i + 2];
        if (th) {
          const nm = localStorage.getItem(LS.name(newPid)) || newPid;
          th.setAttribute('data-player', newPid);
          th.innerHTML = `
            <span class="player-name" data-full="${nm}" title="${nm}">${nm}</span>
            <div id="total${newPid}"></div>
            <div class="to-par-line" id="toPar${newPid}"></div>
          `;
          th.addEventListener('click', onHeaderClick);
        }

        rows.forEach(row => {
          const first = row.firstElementChild;
          const label = first?.textContent?.trim() || '';
          const cell = row.children[i + 2];
          if (!cell) return;

          if (row.classList.contains('summary-row')) {
            if (label === 'OUT') cell.setAttribute('data-sum', `out-${newPid}`);
            if (label === 'IN')  cell.setAttribute('data-sum', `in-${newPid}`);
          } else {
            cell.setAttribute('data-player', newPid);
          }
        });
      }

      fitRowsToViewport();
      updateAllTotals();
      applySortByRankIfHoleComplete(null, true);
      updateRanks();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
      attachDragListeners();
      return true;
    }

    function applyPlayerName(pid, newName) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
      if (!header) return;

      let nameEl = header.querySelector('.player-name');
      if (nameEl) {
        nameEl.textContent = newName;
        nameEl.setAttribute('data-full', newName);
        nameEl.setAttribute('title', newName);
      } else {
        const totalDiv = header.querySelector(`div[id^="total"]`);
        const toParDiv = header.querySelector('.to-par-line');
        const totalHTML = totalDiv ? totalDiv.outerHTML : `<div id="total${pid}"></div>`;
        const toParHTML = toParDiv ? toParDiv.outerHTML : `<div class="to-par-line" id="toPar${pid}"></div>`;
        header.innerHTML = `<span class="player-name" data-full="${newName}" title="${newName}">${newName}</span>${totalHTML}${toParHTML}`;
      }

      header.setAttribute('data-player', pid);
      localStorage.setItem(LS.name(pid), newName);
      clipPlayerNamesToCell();
      updatePlaceholdersForPlayer(pid);
      updateRanks();
    }

    function closePlayerNameModal() {
      const modal = document.getElementById('playerNameModal');
      const btn = modal.querySelector('button[onclick^="handleRemovePlayer"]');
      if (btn) { btn.textContent = 'Remove'; btn.dataset.state = 'initial'; }
      modal.style.display = 'none';
      hideOverlay();
    }

    function attachEmojiGridInteractions() {
      const modal = document.getElementById('playerNameModal');
      const buttons = Array.from(modal.querySelectorAll('.emoji-pick'));
      const bulkBar = modal.querySelector('#bulkEmojiActions');
      const seg = modal.querySelector('.segmented-control');
      const emojiInput = modal.querySelector('#emojiNameInput');
      let bulkEmojiMode = false;
      let bulkEmojiSelection = [];
      const bulkMaxPlayers = 8;

      const enterBulk = () => {
        if (bulkEmojiMode) return;
        bulkEmojiMode = true; bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'block';
        if (seg) seg.style.display = 'none';
        if (emojiInput) emojiInput.style.display = 'none';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.add('bulk-mode');
      };
      const exitBulk = () => {
        bulkEmojiMode = false; bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'none';
        if (seg) seg.style.display = '';
        if (emojiInput) emojiInput.style.display = '';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.remove('bulk-mode');
      };
      const renumber = () => {
        buttons.forEach(b => { if (b.classList.contains('selected')) b.setAttribute('data-order', ''); });
        bulkEmojiSelection.forEach((emoji, i) => {
          const b = buttons.find(btn => btn.getAttribute('data-emoji') === emoji);
          if (b) b.setAttribute('data-order', String(i + 1));
        });
      };
      const toggleSel = (btn) => {
        const emoji = btn.getAttribute('data-emoji');
        const idx = bulkEmojiSelection.indexOf(emoji);
        if (idx !== -1) { bulkEmojiSelection.splice(idx, 1); btn.classList.remove('selected'); btn.removeAttribute('data-order'); }
        else {
          if (bulkEmojiSelection.length >= bulkMaxPlayers) return;
          bulkEmojiSelection.push(emoji); btn.classList.add('selected');
        }
        renumber();
      };
      const applyBulk = (selected) => {
        const targetCount = Math.min(bulkMaxPlayers, selected.length);
        if (targetCount < 1) return;
        emojiModeEnabled = true;
        localStorage.setItem(LS.emojiMode, 'true');

        const pcSel = document.getElementById('playerCount');
        pcSel.value = String(targetCount);
        updatePlayerCount();

        for (let i = 1; i <= targetCount; i++) applyPlayerName(`P${i}`, selected[i - 1]);
        exitBulk();
        closePlayerNameModal();
      };

      const cancelBtn = modal.querySelector('#bulkCancelBtn');
      const applyBtn = modal.querySelector('#bulkApplyBtn');
      if (cancelBtn) cancelBtn.addEventListener('click', () => exitBulk());
      if (applyBtn) applyBtn.addEventListener('click', () => { if (bulkEmojiSelection.length > 0) applyBulk(bulkEmojiSelection); });

      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (bulkEmojiMode) toggleSel(btn);
          else {
            const emoji = btn.getAttribute('data-emoji');
            if (emoji && window.currentPlayer) {
              applyPlayerName(window.currentPlayer, emoji);
              closePlayerNameModal();
            }
          }
        });
        let pressTimer = null;
        const start = () => {
          if (bulkEmojiMode) return;
          clearTimeout(pressTimer);
          pressTimer = setTimeout(() => enterBulk(), 500);
        };
        const cancel = () => { clearTimeout(pressTimer); pressTimer = null; }
        btn.addEventListener('pointerdown', start);
        btn.addEventListener('pointerup', cancel);
        btn.addEventListener('pointerleave', cancel);
        btn.addEventListener('touchstart', start, { passive: true });
        btn.addEventListener('touchend', cancel);
        btn.addEventListener('touchcancel', cancel);
        btn.addEventListener('mousedown', start);
        btn.addEventListener('mouseup', cancel);
        btn.addEventListener('mouseleave', cancel);
      });
    }

    function syncDefaultNamesToMode() {
      for (let i = 1; i <= playerCount; i++) {
        const pid = `P${i}`;
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (!header) continue;
        const displayed = (header.getAttribute('data-full') || header.textContent || '').trim();
        const stored = localStorage.getItem(LS.name(pid));
        const current = stored != null ? stored : displayed;
        let newName = current;

        if (emojiModeEnabled) {
          const m = /^P(\d{1,2})$/i.exec(current);
          if (m) {
            const n = parseInt(m[1], 10);
            if (n >= 0 && n <= 9) newName = numberToKeycap(n);
          } else if (stored == null && i <= 9) {
            newName = numberToKeycap(i);
          }
        } else {
          const n = keycapToNumber(current);
          if (n !== null) newName = `P${n}`;
        }

        if (newName !== current) {
          applyPlayerName(pid, newName);
        } else if (stored == null) {
          localStorage.setItem(LS.name(pid), current);
        }
      }
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    /* ---------------- Totals / ranks / layout ---------------- */
    function fitRowsToViewport() {
      const table = document.getElementById('scoreTable');
      if (!table) return;
      const header = table.querySelector('thead');
      const headerH = header ? header.getBoundingClientRect().height : 0;
      const rows = document.querySelectorAll('#scoreBody tr').length;

      const containerH = table.getBoundingClientRect().height; // actual visible height (safe-area aware)
      if (rows > 0) {
        const approxBorders = rows;
        const avail = Math.max(1, containerH - headerH);
        const rowH = Math.max(20, Math.floor((avail - approxBorders) / rows));
        document.documentElement.style.setProperty('--row-h', rowH + 'px');
      }
    }

    function getPar(h) {
      const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
      const v = parseInt(cell?.textContent || '3', 10);
      return Number.isFinite(v) ? v : 3;
    }
    function getScore(player, h) {
      const td = document.querySelector(`td.score-cell[data-player="${player}"][data-hole="H${h}"]`);
      const v = parseInt(td?.textContent || '', 10);
      return Number.isFinite(v) ? v : null;
    }
    function hasAnyEntry() {
      return Array.from(document.querySelectorAll('.score-cell')).some(td => td.textContent.trim() !== '');
    }

    function updateScoreColors() {
      const { h: H, s: S } = getThemeHS(themeColor);
      const themeText = (l = 40) => `hsl(${H}, ${S}%, ${l}%)`;
      const grey = '#808080';
      document.querySelectorAll('#scoreBody td.score-cell').forEach(td => {
        const txt = td.textContent.trim();
        if (!txt) { td.style.color = ''; return; }
        const score = parseInt(txt, 10);
        if (!Number.isFinite(score)) { td.style.color = ''; return; }
        const holeAttr = td.getAttribute('data-hole') || '';
        const hole = parseInt(holeAttr.replace('H',''), 10);
        const par = Number.isFinite(hole) ? getPar(hole) : 3;
        if (score < par) td.style.color = themeText(40);
        else if (score > par) td.style.color = grey;
        else td.style.color = '#000000';
      });
    }

    function updateAllTotals() {
      const outRange = [...Array(Math.min(9, holesCount)).keys()].map(i => i + 1);
      const inRange  = (holesCount > 9) ? [...Array(holesCount - 9).keys()].map(i => i + 10) : [];

      const parOut = outRange.reduce((s, h) => s + getPar(h), 0);
      const parIn  = inRange.reduce((s, h) => s + getPar(h), 0);

      const setSumCell = (key, val) => {
        const el = document.querySelector(`[data-sum="${key}"]`);
        if (el) el.textContent = String(val);
      };
      setSumCell('out-par', parOut);
      if (holesCount > 9) setSumCell('in-par', parIn);

      const any = hasAnyEntry();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const sumOut = outRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const sumIn  = inRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const played = [...outRange, ...inRange];
        let playedPar = 0, playedStrokes = 0, hasScore = false;
        for (const h of played) {
          const sc = getScore(pid, h);
          if (sc != null) { hasScore = true; playedStrokes += sc; playedPar += getPar(h); }
        }
        setSumCell(`out-${pid}`, sumOut);
        if (holesCount > 9) setSumCell(`in-${pid}`, sumIn);

        const totalDiv = document.getElementById(`total${pid}`);
        const toParDiv = document.getElementById(`toPar${pid}`);
        if (!totalDiv || !toParDiv) continue;

        if (hasScore) {
          const toPar = (playedPar === 0) ? 0 : (playedStrokes - playedPar);
          const tp = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);

          totalDiv.innerHTML = `<span class="strokes">${playedStrokes}</span>`;
          toParDiv.innerHTML = `<span class="to-par-badge" data-value="${toPar}">${tp}</span>`;
        } else {
          if (any) {
            totalDiv.innerHTML = `<span class="strokes">0</span>`;
            toParDiv.innerHTML = `<span class="to-par-badge" data-value="0">E</span>`;
          } else {
            totalDiv.innerHTML = '';
            toParDiv.innerHTML = '';
          }
        }
      }

      updateScoreColors();
      updateToParBadgeColors();
    }

    function updateToParBadgeColors() {
      const { h: H, s: S } = getThemeHS(themeColor);
      const themeText = `hsl(${H}, ${S}%, 40%)`;
      const grey = '#808080';

      document.querySelectorAll('#scoreTable thead th .to-par-badge').forEach(badge => {
        const raw = badge.getAttribute('data-value');
        const val = raw != null ? parseInt(raw, 10) : NaN;

        if (!Number.isFinite(val) || val === 0) {
          badge.style.color = '#000000';
        } else if (val > 0) {
          badge.style.color = grey;
        } else {
          badge.style.color = themeText;
        }
      });
    }

    function updateRanks() {
      const table = document.getElementById('scoreTable');
      const headers = Array.from(table.querySelectorAll('thead th')).slice(2);
      const count = headers.length;

      if (count >= 7) table.classList.add('small-scores');
      else table.classList.remove('small-scores');

      headers.forEach(h => {
        h.style.background = '';
        h.querySelectorAll('small').forEach(s => s.remove());
      });

      const any = hasAnyEntry();
      if (!any) { clipPlayerNamesToCell(); return; }

      const totals = headers.map(h => {
        const pid = h.getAttribute('data-player');
        let sum = 0, hasScore = false;
        for (let i = 1; i <= holesCount; i++) {
          const sc = getScore(pid, i);
          if (sc != null) { hasScore = true; sum += sc; }
        }
        const rankValue = hasScore ? sum : Number.POSITIVE_INFINITY;
        return { h, pid, sum, hasScore, rankValue };
      });

      const sorted = [...totals].sort((a, b) => a.rankValue - b.rankValue);

      const groups = [];
      for (const item of sorted) {
        const last = groups[groups.length - 1];
        if (!last || last.score !== item.rankValue) groups.push({ score: item.rankValue, members: [item.pid] });
        else last.members.push(item.pid);
      }

      const { h: H, s: S } = getThemeHS(themeColor);
      const Lmax = 82, minRange = 18, maxRange = 44;
      const effective = groups.length;
      const normalized = Math.min(1, Math.max(0, (effective - 1) / (8 - 1)));
      const range = Math.round(minRange + (maxRange - minRange) * normalized);
      const Lmin = Math.max(28, Lmax - range);

      groups.forEach((group, g) => {
        const ratio = (effective === 1) ? 0 : g / (effective - 1);
        const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
        const Ltop = Math.max(18, L - 10);
        const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
        group.members.forEach(pid => {
          const th = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
          if (th) th.style.background = gradient;
        });
      });

      clipPlayerNamesToCell();
    }

    function clipPlayerNamesToCell() {
      const seg = (typeof Intl !== 'undefined' && Intl.Segmenter)
        ? new Intl.Segmenter('en', { granularity: 'grapheme' })
        : null;
      const els = document.querySelectorAll('#scoreTable thead th .player-name');
      els.forEach(el => {
        const full = el.getAttribute('data-full') ?? el.textContent;
        el.setAttribute('data-full', full);
        el.textContent = full;

        if (el.scrollWidth > el.clientWidth) {
          const clusters = seg ? Array.from(seg.segment(full), s => s.segment) : Array.from(full);
          let low = 0, high = clusters.length, best = 0;
          while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            el.textContent = clusters.slice(0, mid).join('');
            if (el.scrollWidth <= el.clientWidth) { best = mid; low = mid + 1; }
            else high = mid - 1;
          }
          el.textContent = clusters.slice(0, best).join('');
        }

        const th = el.closest('th[data-player]');
        const pid = th?.getAttribute('data-player');
        if (pid) updatePlaceholdersForPlayer(pid);
      });
    }

    /* ---------------- Resort gating: only after a hole is complete ---------------- */
    function isHoleComplete(h) {
      if (!h || h < 1 || h > holesCount) return false;
      for (let p = 1; p <= playerCount; p++) {
        if (getScore(`P${p}`, h) == null) return false;
      }
      return true;
    }
    function isAnyHoleComplete() {
      for (let h = 1; h <= holesCount; h++) {
        if (isHoleComplete(h)) return true;
      }
      return false;
    }
    function applySortByRankIfHoleComplete(targetHole = null, silent = true) {
      if (!sortByRankEnabled) return;
      if (targetHole != null) {
        if (!isHoleComplete(targetHole)) return;
      } else {
        if (!isAnyHoleComplete()) return;
      }
      applySortByRank(silent);
    }

    /* ---------------- Sort by rank (reindex left->right) ---------------- */
    function applySortByRank(silent = false) {
      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));
      const headers = Array.from(headerRow.children).slice(2);
      if (headers.length <= 1 || !hasAnyEntry()) return;

      const players = headers.map((th, idx) => {
        const pid = th.getAttribute('data-player');
        let sum = 0, hasScore = false;
        for (let h = 1; h <= holesCount; h++) {
          const sc = getScore(pid, h);
          if (sc != null) { hasScore = true; sum += sc; }
        }
        const rankValue = hasScore ? sum : Number.POSITIVE_INFINITY;
        return { idx, pid, rankValue };
      });

      const order = [...players].sort((a,b) => a.rankValue - b.rankValue || a.idx - b.idx).map(p => p.idx);
      if (order.every((v, i) => v === i)) { if (!silent) updateRanks(); return; }

      const playerData = [];
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        const name = localStorage.getItem(LS.name(pid)) ||
          (document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`)?.textContent?.trim() || pid);
        const scores = {};
        for (let h = 1; h <= holesCount; h++) {
          const v = localStorage.getItem(LS.score(pid, h));
          scores[h] = (v != null) ? v : null;
        }
        playerData.push({ name, scores });
      }

      const fixed = Array.from(headerRow.children).slice(0,2);
      const moving = Array.from(headerRow.children).slice(2);
      headerRow.innerHTML = '';
      fixed.forEach(n => headerRow.appendChild(n));
      order.forEach(i => headerRow.appendChild(moving[i]));

      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixed2 = cells.slice(0,2);
        const movingCells = cells.slice(2);
        tr.innerHTML = '';
        fixed2.forEach(c => tr.appendChild(c));
        order.forEach(i => tr.appendChild(movingCells[i]));
      });

      const newData = order.map(i => playerData[i]);

      for (let i = 0; i < playerCount; i++) {
        const newPid = `P${i+1}`;
        const th = headerRow.children[i + 2];

        const strokesText = th.querySelector('div[id^="total"]')?.textContent || '';
        th.setAttribute('data-player', newPid);
        th.innerHTML = `
          <span class="player-name" data-full="${newData[i].name}" title="${newData[i].name}">${newData[i].name}</span>
          <div id="total${newPid}">${strokesText}</div>
          <div class="to-par-line" id="toPar${newPid}"></div>
        `;
        th.addEventListener('click', onHeaderClick);

        rows.forEach(row => {
          const first = row.firstElementChild;
          const label = first?.textContent?.trim() || '';
          const cell = row.children[i + 2];
          if (!cell) return;
          if (!row.classList.contains('summary-row')) {
            cell.setAttribute('data-player', newPid);
          } else {
            if (label === 'OUT') cell.setAttribute('data-sum', `out-${newPid}`);
            if (label === 'IN')  cell.setAttribute('data-sum', `in-${newPid}`);
          }
        });
      }

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        localStorage.removeItem(LS.name(pid));
        for (let h = 1; h <= holesCount; h++) localStorage.removeItem(LS.score(pid, h));
      }
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        localStorage.setItem(LS.name(pid), newData[i].name);
        for (let h = 1; h <= holesCount; h++) {
          const v = newData[i].scores[h];
          if (v != null) localStorage.setItem(LS.score(pid, h), v);
        }
      }

      attachDragListeners();
      updateAllTotals();
      if (!silent) updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    /* ---------------- Rebuild preserving (used for holes toggle) ---------------- */
    function rebuildPreserving() {
      const names = {};
      for (let p = 1; p <= 8; p++) {
        const k = LS.name(`P${p}`);
        const v = localStorage.getItem(k);
        if (v != null) names[`P${p}`] = v;
      }
      const pars = {};
      for (let h = 1; h <= 18; h++) {
        const k = LS.par(h);
        const v = localStorage.getItem(k);
        if (v != null) pars[h] = v;
      }
      const scores = {};
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) {
          const k = LS.score(`P${p}`, h);
          const v = localStorage.getItem(k);
          if (v != null) scores[`${p}-${h}`] = v;
        }
      }

      buildTable();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const nm = names[pid] || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        localStorage.setItem(LS.name(pid), nm);
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (header) {
          header.textContent = nm;
          header.setAttribute('data-full', nm);
          header.setAttribute('title', nm);
        }
        const th = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
        if (th) th.addEventListener('click', onHeaderClick);
      }
      for (let h = 1; h <= holesCount; h++) {
        const v = pars[h] ?? '3';
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) {
          cell.textContent = v;
          localStorage.setItem(LS.par(h), v);
        }
      }
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const key = `${p}-${h}`;
          const v = scores[key];
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && v != null) {
            td.textContent = v;
            localStorage.setItem(LS.score(`P${p}`, h), v);
          }
        }
      }

      updateAllPlaceholders();
      updateAllTotals();
      applySortByRankIfHoleComplete(null, true);
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      attachDragListeners();
    }

    /* ---------------- Drag & Drop ---------------- */
    function attachDragListeners() {
      const headers = document.querySelectorAll('#scoreTable thead th[data-player]');
      headers.forEach((header, index) => {
        header.draggable = true;

        header.removeEventListener('dragstart', header._dragStartHandler);
        header.removeEventListener('dragover', header._dragOverHandler);
        header.removeEventListener('drop', header._dropHandler);
        header.removeEventListener('dragend', header._dragEndHandler);

        header._dragStartHandler = (event) => handleDragStart(event, index);
        header._dragOverHandler = (event) => handleDragOver(event);
        header._dropHandler = (event) => handleDrop(event, index);
        header._dragEndHandler = (event) => handleDragEnd(event);

        header.addEventListener('dragstart', header._dragStartHandler);
        header.addEventListener('dragover', header._dragOverHandler);
        header.addEventListener('drop', header._dropHandler);
        header.addEventListener('dragend', header._dragEndHandler);
      });
    }

    function handleDragStart(event, index) {
      draggedIndex = index;
      event.currentTarget.classList.add('dragging');
      if (event.dataTransfer) {
        event.dataTransfer.effectAllowed = 'move';
        try { event.dataTransfer.setData('text/plain', ''); } catch (_) {}
      }
    }

    function handleDragOver(event) {
      event.preventDefault();
      if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
    }

    function handleDrop(event, dropIndex) {
      event.preventDefault();

      if (sortByRankEnabled) {
        draggedIndex = -1;
        return;
      }

      if (draggedIndex === -1 || draggedIndex === dropIndex) {
        draggedIndex = -1;
        return;
      }

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      const playerData = [];
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        const name = localStorage.getItem(LS.name(pid)) ||
          (document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`)?.textContent?.trim() || pid);
        const scores = {};
        for (let h = 1; h <= holesCount; h++) {
          const v = localStorage.getItem(LS.score(pid, h));
          scores[h] = (v != null) ? v : null;
        }
        playerData.push({ name, scores });
      }

      const fixed = Array.from(headerRow.children).slice(0,2);
      const playerHeaders = Array.from(headerRow.children).slice(2);
      const [draggedHeader] = playerHeaders.splice(draggedIndex, 1);
      playerHeaders.splice(dropIndex, 0, draggedHeader);
      headerRow.innerHTML = '';
      fixed.forEach(h => headerRow.appendChild(h));
      playerHeaders.forEach(h => headerRow.appendChild(h));

      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixedCells = cells.slice(0, 2);
        const playerCells = cells.slice(2);
        const [draggedCell] = playerCells.splice(draggedIndex, 1);
        playerCells.splice(dropIndex, 0, draggedCell);
        tr.innerHTML = '';
        fixedCells.forEach(c => tr.appendChild(c));
        playerCells.forEach(c => tr.appendChild(c));
      });

      const [draggedData] = playerData.splice(draggedIndex, 1);
      playerData.splice(dropIndex, 0, draggedData);

      for (let i = 0; i < playerCount; i++) {
        const newPid = `P${i+1}`;
        const th = headerRow.children[i + 2];
        const strokesText = th.querySelector('div[id^="total"]')?.textContent || '';

        th.setAttribute('data-player', newPid);
        const nm = playerData[i].name;
        th.innerHTML = `
          <span class="player-name" data-full="${nm}" title="${nm}">${nm}</span>
          <div id="total${newPid}">${strokesText}</div>
          <div class="to-par-line" id="toPar${newPid}"></div>
        `;
        th.addEventListener('click', onHeaderClick);

        rows.forEach(row => {
          const first = row.firstElementChild;
          const label = first?.textContent?.trim() || '';
          const cell = row.children[i + 2];
          if (!cell) return;
          if (!row.classList.contains('summary-row')) {
            cell.setAttribute('data-player', newPid);
          } else {
            if (label === 'OUT') cell.setAttribute('data-sum', `out-${newPid}`);
            if (label === 'IN')  cell.setAttribute('data-sum', `in-${newPid}`);
          }
        });
      }

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        localStorage.removeItem(LS.name(pid));
        for (let h = 1; h <= holesCount; h++) localStorage.removeItem(LS.score(pid, h));
      }
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        localStorage.setItem(LS.name(pid), playerData[i].name);
        for (let h = 1; h <= holesCount; h++) {
          const v = playerData[i].scores[h];
          if (v != null) localStorage.setItem(LS.score(pid, h), v);
        }
      }

      draggedIndex = -1;
      attachDragListeners();
      updateAllTotals();
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    function handleDragEnd(event) {
      event.currentTarget.classList.remove('dragging');
      draggedIndex = -1;
    }

    /* ---------------- Pars popup ---------------- */
    function showParResetPopup() {
      const modal = document.getElementById('popupModal');
      const title = document.getElementById('popupTitle');
      const options = document.getElementById('popupOptions');

      title.textContent = 'Par';
      options.innerHTML = `
        <button id="resetParsBtn"
                style="width: 100%; height: auto; padding: 10px 20px; font-size: 24px; grid-column: 1 / -1;">
          Reset Pars
        </button>
      `;

      document.getElementById('resetParsBtn').onclick = () => {
        resetAllParsToThree();
        closePopupModal();
      };

      modal.style.display = 'block';
      showOverlay();
    }

    function resetAllParsToThree() {
      for (let h = 1; h <= holesCount; h++) {
        localStorage.setItem(LS.par(h), '3');
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = '3';
      }
      updateAllTotals();
    }

    function closePopupModal() {
      const modal = document.getElementById('popupModal');
      modal.style.display = 'none';
      hideOverlay();
    }

    /* ---------------- Overlay ---------------- */
    function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
    function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }
    document.getElementById('overlay').addEventListener('click', () => {
      closeRoundManagement();
      closePlayerNameModal();
      closePopupModal();
      closeScorePad();
    });
  </script>
</body>
</html>