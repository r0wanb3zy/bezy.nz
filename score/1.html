<!DOCTYPE html>
<html lang="en">
<head>
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/js/bootstrap.bundle.min.js"></script>
<link type="text/css" rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha3/dist/css/bootstrap.min.css"/>
    <!-- Meta -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Title + Font -->
    <title>Scorecard</title>
    <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">

    <style>
        /* ---------------------------------------
           Base / Layout
        --------------------------------------- */
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* keep table area scrollable, not page */
        }

        body {
            font-family: 'Economica', sans-serif;
            font-size: 22px;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
            background: linear-gradient(135deg, #f0f2f5 0%, #ffffff 100%) no-repeat;
            background-size: cover;
            display: flex;
            flex-direction: column;
        }

        h1 { text-align: center; }

        /* Scrollable area for score rows (header stays sticky) */
        .score-container {
            flex: 1;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }

        /* ---------------------------------------
           Table
        --------------------------------------- */
        table {
            width: 100%;
            table-layout: fixed;
            border-collapse: collapse;
            font-size: 20px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        table th, table td {
            border: none;
            text-align: center;
            padding: 5px;
            word-wrap: break-word;
            cursor: pointer;
            border-bottom: 1px solid rgba(200, 200, 200, 0.3);
        }

        table th {
            background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
            color: white;
        }

        /* Round number / header control column */
        table th:first-child {
            background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
            font-weight: bold;
            width: 30px;
            min-width: 30px;
            max-width: 30px;
            overflow: hidden;
            color: white;
            border-bottom: 1px solid #666;
        }

        table td:first-child {
            background: #3b3b3b;
            font-weight: bold;
            width: 30px;
            min-width: 30px;
            max-width: 30px;
            overflow: hidden;
            color: white;
            border-bottom: 1px solid #666;
        }

        /* Header metrics */
        .sticky-header th {
            height: 80px;
            font-family: 'Economica', sans-serif;
            font-size: 22px;
        }

        .sticky-header th span.score {
            font-size: 22px;
            font-family: 'Economica', sans-serif;
        }

        .sticky-header th small {
            font-size: 16px;
            font-family: 'Economica', sans-serif;
            color: rgba(255, 255, 255, 0.8);
        }

        /* Tight row height for scored rows (not the input row) */
        #scoreBody tr:not(:last-child) td:not(:first-child) {
            max-height: 5px;
            height: 5px;
            line-height: 5px;
            overflow: hidden;
        }

        #scoreBody tr td:not(:first-child) {
            font-weight: bold;
        }

        /* ---------------------------------------
           Inputs
        --------------------------------------- */
        table input {
            width: 100%;
            box-sizing: border-box;
            padding: 8px;
            text-align: center;
            font-size: inherit;
            font-family: 'Economica', sans-serif;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            background: #ffffff;
            box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
        }

        table input::placeholder {
            font-family: 'Economica', sans-serif;
            font-size: 16px;
            text-align: center;
            line-height: 16px;
            color: #6b7280;
            opacity: 0.8;
        }

        table input:focus {
            outline: none;
            border-color: #262626;
            box-shadow: 0 0 5px rgba(51, 51, 51, 0.5);
        }

        /* Remove spinners for number inputs on webkit */
        table input[type="number"]::-webkit-outer-spin-button,
        table input[type="number"]::-webkit-inner-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }

        /* Fixed height for number inputs */
        table input[type="number"] {
            width: 100%;
            box-sizing: border-box;
            height: 40px;
            line-height: 40px;
            padding: 0 8px;
            text-align: center;
            font-size: inherit;
            font-family: 'Economica', sans-serif;
            border: 1px solid #d0d7de;
            border-radius: 6px;
            background: #ffffff;
            box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
        }

        /* Number input placeholder metrics */
        table input[type="number"]::placeholder {
            font: inherit;
            line-height: inherit;
            text-align: center;
            color: #6b7280;
            opacity: 0.8;
        }

        /* Bottom input row: placeholders look lighter */
        #scoreTable tbody tr:last-child input[type="number"]::placeholder { opacity: 0.5; color: rgba(107, 114, 128, 0.5); }
        #scoreTable tbody tr:last-child input[type="number"]::-webkit-input-placeholder { opacity: 0.5; }
        #scoreTable tbody tr:last-child input[type="number"]::-moz-placeholder { opacity: 0.5; }
        #scoreTable tbody tr:last-child input[type="number"]:-ms-input-placeholder { opacity: 0.5; }
        #scoreTable tbody tr:last-child input[type="number"]::-ms-input-placeholder { opacity: 0.5; }

        /* ---------------------------------------
           Modals / Overlay
        --------------------------------------- */
        .popup-modal {
            display: none;
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            background: #ffffff;
            border: none;
            padding: 5px 20px 20px 20px;
            z-index: 1000;
            width: 200px;
            max-width: 90%;
            text-align: center;
            font-family: 'Economica', sans-serif;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border-radius: 10px;
        }

        /* Ensure player modal is centered like the others */
        #playerManagementModal {
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .popup-modal input[type="text"] {
            font-size: 24px;
            padding: 10px;
            width: 100%;
            box-sizing: border-box;
            margin: 5px 0;
            text-align: center;
            font-family: 'Economica', sans-serif;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f8f9fa;
        }

        .popup-modal input[type="text"]:focus {
            outline: none;
            border: 1px solid #262626;
        }

        .popup-modal select {
            font-size: 24px;
            padding: 10px;
            margin: 5px 0;
            font-family: 'Economica', sans-serif;
            border: 1px solid #ddd;
            border-radius: 6px;
            background: #f8f9fa;
            width: 100%;
            box-sizing: border-box;
        }

        /* Slightly stronger border for round-management select */
        #roundManagementModal select {
            border: 1px solid #333;
        }

        .popup-modal button {
            font-size: 24px;
            padding: 10px 20px;
            margin: 5px 0;
            cursor: pointer;
            font-family: 'Economica', sans-serif;
            background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
            color: white;
            border: none;
            border-radius: 6px;
            transition: background 0.2s;
            width: 100%;
            box-sizing: border-box;
        }

        /* Destructive confirm state */
        .popup-modal button[data-state="confirm"] {
            background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
        }

        /* Light variant (Cancel / toggle-like) */
        .popup-modal button.light {
            background: #f8f9fa;
            color: #0f172a;
            border: 1px solid #262626;
        }

        /* Sort-by-rank button styles + active state */
        #roundManagementModal button#sortByRankBtn {
            background: #f8f9fa;
            color: #0f172a;
            border: 1px solid #262626;
        }
        #roundManagementModal button#sortByRankBtn.active {
            background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
            color: #ffffff;
            border: 1px solid #262626;
        }

        /* Modal headings spacing */
        #playerManagementModal h2,
        #roundManagementModal h2,
        #deleteRoundModal h2 {
            margin-top: 15px;
            margin-bottom: 15px;
            padding: 0;
        }

        /* ---------------------------------------
           Segmented control (Name/Emoji, Low/High)
        --------------------------------------- */
        .segmented-control {
            display: flex;
            width: 100%;
            box-sizing: border-box;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 6px;
            overflow: hidden;
            border: 1px solid #262626; /* crisp border without seams */
            box-shadow: none;
            -webkit-background-clip: padding-box;
            background-clip: padding-box;
        }
        .segmented-control input[type="radio"] { display: none; }
        .segmented-control label {
            flex: 1 1 0;
            padding: 10px 0;
            text-align: center;
            font-size: 24px;
            font-family: 'Economica', sans-serif;
            cursor: pointer;
            user-select: none;
            background: #f8f9fa;
            margin: 0;
        }
        .segmented-control input[type="radio"]:checked + label {
            background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
            color: #fff;
        }

        /* Close X button */
        .close-btn {
            position: absolute;
            top: 0px;
            right: 0px;
            font-size: 48px;
            color: #000000;
            cursor: pointer;
            background: none;
            border: none;
            padding: 0;
            line-height: 1;
            width: 40px;
            height: 40px;
            text-align: center;
            transition: color 0.2s ease;
        }

        /* Emoji scaling helper (if needed) */
        .scaled-emoji {
            transform: scale(.75);
            transform-origin: center;
            display: inline-block;
        }

        /* Remove tap highlight (mobile) */
        * { -webkit-tap-highlight-color: transparent; }

        /* Overlay behind modals */
        #overlay {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 999;
            cursor: pointer;
        }

        /* ---------------------------------------
           Sticky header
        --------------------------------------- */
        .sticky-header {
            position: sticky;
            top: 0;
            z-index: 10;
            background: #fff;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }
        .sticky-header table { margin-bottom: 0; }

        /* Make main table flush to header */
        #scoreTable { margin-top: 0; }

        /* Drag feedback */
        th.dragging { opacity: 0.5; background: rgba(0, 0, 0, 0.2); }
        th.drag-over { border-left: 2px solid #333; }

        /* ---------------------------------------
           Emoji grid (player emoji picker)
        --------------------------------------- */
        .emoji-grid {
            --emoji-gap: 8px;
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: var(--emoji-gap);
            padding: 0;
            margin: 5px 0;
            width: 100%;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        .emoji-grid .emoji-pick {
            background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
            color: #ffffff;
            border: none;
            border-radius: 6px;
            font-family: 'Economica', sans-serif;
            font-size: 22px;
            display: grid;
            place-items: center;
            width: 100%;
            aspect-ratio: 1 / 1;
            padding: 0;
            margin: 0;
            line-height: 1;
            cursor: pointer;
            transition: transform 0.05s ease, filter 0.1s ease;
            box-sizing: border-box;
            position: relative;
        }

        .emoji-grid .emoji-pick:active {
            transform: scale(0.95);
            filter: brightness(1.05);
        }

        /* Selected state with dim overlay (number sits above) */
        .emoji-grid .emoji-pick.selected {
            box-shadow: 0 0 0 2px #262626 inset;
        }
        .emoji-grid .emoji-pick.selected::before {
            content: "";
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.35);
            border-radius: 6px;
            pointer-events: none;
            z-index: 1;
        }
        .emoji-grid .emoji-pick.selected::after {
            content: attr(data-order);
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -55%);
            font-size: 28px;
            font-weight: 700;
            color: #fff;
            text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 3px rgba(0,0,0,0.7);
            pointer-events: none;
            z-index: 2;
        }

        /* Bulk actions (shown during emoji multi-select) */
        .bulk-actions {
            display: none;
            margin: 5px 0 0 0;
            width: 100%;
        }
        .bulk-actions .row {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            align-items: center;
            width: 100%;
        }

        /* Suppress iOS callout on these text inputs */
        #emojiNameInput { -webkit-touch-callout: none; }
        #playerNameInput { -webkit-touch-callout: none; }

        /* ---------------------------------------
           Responsive: small score font for many players
        --------------------------------------- */
        @media (max-width: 480px) {
            .sticky-header.small-scores th span.score {
                font-size: 18px;
                line-height: 1.2;
            }
            #scoreTable.small-scores thead th { padding: 3px; }
            #scoreTable.small-scores thead th span.score { font-size: 16px; line-height: 1.2; }
            #scoreTable.small-scores thead th small { font-size: 12px; }
            #scoreTable.small-scores tbody td { font-size: 16px; }

            /* Smaller inputs in the bottom row on tiny screens */
            #scoreTable.small-scores tbody tr:last-child input[type="number"] {
                font-size: 14px;
                height: 32px;
                line-height: 32px;
                padding: 0 6px;
            }
            #scoreTable.small-scores tbody tr:last-child input[type="number"]::placeholder {
                font: inherit;
                line-height: inherit;
            }
        }

        /* Center text + remove native arrow for Players dropdown */
        #roundManagementModal select#playerCount {
            text-align: center;
            text-align-last: center;
            -moz-text-align-last: center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none !important;
            background-color: #f8f9fa;
            padding-right: 12px;
        }
        #roundManagementModal select#playerCount::-ms-expand { display: none; }
        #roundManagementModal select#playerCount option { text-align: center; }

        /* Center text + remove native arrow for Theme Colour dropdown */
        #roundManagementModal select#themeColorSelect {
            text-align: center;
            text-align-last: center;
            -moz-text-align-last: center;
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            background-image: none !important;
            background-color: #f8f9fa;
            padding-right: 12px;
        }
        #roundManagementModal select#themeColorSelect::-ms-expand { display: none; }
        #roundManagementModal select#themeColorSelect option {
            text-align: center; /* fixed stray period */
        }

        /* Spacing tweaks inside player modal for bulk mode */
        #playerManagementModal .segmented-control { margin-top: 5px; }
        #playerManagementModal .emoji-grid { margin: 5px 0 10px; }
        #playerManagementModal.bulk-mode .emoji-grid { margin-bottom: 5px; }
        #playerManagementModal .bulk-actions { margin-top: 0; }

        /* Truncate long player names (header only): no ellipsis, no half glyphs (JS clips) */
        #playerRow th .player-name {
            display: block;
            max-width: 100%;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: clip; /* no "..." */
        }

        /* Only shrink player names when 7+ players (JS adds .small-scores on header/table) */
        .sticky-header.small-scores #playerRow th .player-name {
            font-size: 18px;
            line-height: 1.1;
        }
    </style>
</head>
<body>
    <!-- Sticky header with player names / totals -->
    <div class="sticky-header">
        <table>
            <thead>
                <tr id="playerRow">
                    <th>#</th>
                </tr>
            </thead>
        </table>
    </div>

    <!-- Scrollable scores table -->
    <div class="score-container">
        <table id="scoreTable">
            <tbody id="scoreBody"></tbody>
        </table>
    </div>

    <!-- Modals -->
    <div id="playerManagementModal" class="popup-modal"></div>
    <div id="roundManagementModal" class="popup-modal"></div>
    <div id="deleteRoundModal" class="popup-modal"></div>

    <!-- Overlay -->
    <div id="overlay"></div>

    <script>
        /* ---------------------------------------
           Globals / Bootstrapping
        --------------------------------------- */
        // Explicit globals (pre-declared for clarity)
        let players = [];
        let rounds = [];

        // On first load, set default players/rounds; otherwise load saved state
        if (!localStorage.getItem('initialized')) {
            players = [
                { name: "P1", totalScore: 0, roundScores: [] },
                { name: "P2", totalScore: 0, roundScores: [] },
                { name: "P3", totalScore: 0, roundScores: [] },
                { name: "P4", totalScore: 0, roundScores: [] }
            ].map(p => ({ ...p, name: p.name.toUpperCase() }));
            rounds = [];
            localStorage.setItem('initialized', 'true');
            localStorage.setItem('players', JSON.stringify(players));
            localStorage.setItem('rounds', JSON.stringify(rounds));
        } else {
            players = JSON.parse(localStorage.getItem('players')) || [];
            rounds = JSON.parse(localStorage.getItem('rounds')) || [];
        }

        // User preferences / UI state
        let scoringMode = localStorage.getItem('scoringMode') || 'lowest';
        let unsubmittedScores = JSON.parse(localStorage.getItem('unsubmittedScores')) || {};
        let sortByRankEnabled = localStorage.getItem('sortByRankEnabled') === 'true';
        let emojiModeEnabled = localStorage.getItem('emojiModeEnabled') === 'true';
        let themeColor = localStorage.getItem('themeColor') || 'blue';

        // Emoji bulk selection state
        let bulkEmojiMode = false;
        let bulkEmojiSelection = [];
        const bulkMaxPlayers = 8;

        /* ---------------------------------------
           Helpers (Keycap digits / Theme)
        --------------------------------------- */
        const KEYCAP_DIGITS = ["0️⃣","1️⃣","2️⃣","3️⃣","4️⃣","5️⃣","6️⃣","7️⃣","8️⃣","9️⃣"];
        function numberToKeycap(n) { return KEYCAP_DIGITS[n] || String(n); }
        function keycapToNumber(str) {
            const idx = KEYCAP_DIGITS.indexOf(str);
            return idx === -1 ? null : idx;
        }

        const THEME_MAP = {
            blue:   { h: 210, s: 85 },
            red:    { h:   0, s: 78 },
            green:  { h: 120, s: 50 },
            pink:   { h: 330, s: 70 },
            purple: { h: 268, s: 70 },
            yellow: { h:  45, s: 90 },
            grey:   { h: 210, s:  0 }
        };
        function getThemeHS() {
            return THEME_MAP[themeColor] || THEME_MAP.blue;
        }
        function getThemeTextColor(key) {
            const t = THEME_MAP[key] || THEME_MAP.blue;
            const L = key === 'yellow' ? 32 : 34; // darker for readability on light bg
            return `hsl(${t.h}, ${t.s}%, ${L}%)`;
        }
        function setThemeColor(value) {
            themeColor = value || 'blue';
            localStorage.setItem('themeColor', themeColor);
            updateUI();               // update header shading immediately
            applyThemeSelectColors(); // recolor dropdown options
        }
        function applyThemeSelectColors() {
            const select = document.querySelector('#roundManagementModal select#themeColorSelect');
            if (!select) return;
            select.style.color = getThemeTextColor(themeColor);
            Array.from(select.options).forEach(opt => {
                opt.style.color = getThemeTextColor(opt.value);
            });
        }

        /* ---------------------------------------
           Persistence
        --------------------------------------- */
        function saveData() {
            localStorage.setItem('players', JSON.stringify(players));
            localStorage.setItem('rounds', JSON.stringify(rounds));
            localStorage.setItem('scoringMode', scoringMode);
            localStorage.setItem('sortByRankEnabled', sortByRankEnabled);
            localStorage.setItem('emojiModeEnabled', emojiModeEnabled);
            localStorage.setItem('themeColor', themeColor);
        }

        function saveUnsubmittedScores() {
            const inputs = document.querySelectorAll("#scoreTable input[type='number']");
            unsubmittedScores = {};
            inputs.forEach((input, index) => {
                unsubmittedScores[players[index].name] = input.value;
            });
            localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
        }

        /* ---------------------------------------
           Keyboard helpers (mobile)
        --------------------------------------- */
        function hideKeyboard() {
            try {
                if (document.activeElement && typeof document.activeElement.blur === 'function') {
                    document.activeElement.blur();
                }
                const inputs = document.querySelectorAll("#scoreTable input[type='number']");
                inputs.forEach(inp => { try { inp.blur(); } catch (_) {} });
            } catch (_) {}
        }

        function setEnterKeyHints(inputNodeList) {
            const inputs = Array.from(inputNodeList || document.querySelectorAll("#scoreTable input[type='number']"));
            const filled = inputs.length > 0 && inputs.every(inp => inp.value.trim() !== '');
            const hint = filled ? 'go' : 'next';
            inputs.forEach(inp => {
                inp.setAttribute('enterkeyhint', hint);
                if ('enterKeyHint' in inp) {
                    try { inp.enterKeyHint = hint; } catch (_) {}
                }
            });
        }

        /* ---------------------------------------
           Players / Names / Emoji
        --------------------------------------- */
        // Switch default labels between P# and keycap emoji (keeps unsubmitted scores aligned)
        function syncDefaultNamesToMode() {
            let changed = false;
            players.forEach((p) => {
                const name = (p.name || '').trim();

                if (emojiModeEnabled) {
                    // P# -> keycap emoji when turning emoji mode on
                    const m = /^P(\d{1,2})$/i.exec(name);
                    if (m) {
                        const n = parseInt(m[1], 10);
                        if (n >= 0 && n <= 9) {
                            const emoji = numberToKeycap(n);
                            if (name !== emoji) {
                                if (unsubmittedScores[name] !== undefined) {
                                    unsubmittedScores[emoji] = unsubmittedScores[name];
                                    delete unsubmittedScores[name];
                                }
                                p.name = emoji;
                                changed = true;
                            }
                        }
                    }
                } else {
                    // keycap emoji -> P# when turning emoji mode off
                    const n = keycapToNumber(name);
                    if (n !== null) {
                        const pn = `P${n}`.toUpperCase();
                        if (name !== pn) {
                            if (unsubmittedScores[name] !== undefined) {
                                unsubmittedScores[pn] = unsubmittedScores[name];
                                delete unsubmittedScores[name];
                            }
                            p.name = pn;
                            changed = true;
                        }
                    }
                }
            });
            if (changed) {
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
                saveData();
            }
        }

        // Rename a player and carry over any typed-but-not-submitted score
        function renamePlayer(index, newName) {
            const oldName = players[index].name;
            players[index].name = newName;
            if (unsubmittedScores[oldName] !== undefined) {
                unsubmittedScores[newName] = unsubmittedScores[oldName];
                delete unsubmittedScores[oldName];
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
            }
            saveData();
            updateUI();
        }

        // Remove a player (and their column) safely
        function removePlayer(index) {
            if (players.length <= 1) {
                alert("At least one player must remain.");
                return false;
            }
            players.splice(index, 1);
            rounds.forEach(round => round.splice(index, 1));
            saveData();
            updateUI();
            return true;
        }

        // Toggle emoji mode; optionally re-open the correct modal after switching
        function setEmojiMode(enabled, reopenIndex = null) {
            emojiModeEnabled = !!enabled;
            localStorage.setItem('emojiModeEnabled', emojiModeEnabled);
            syncDefaultNamesToMode();
            saveData();
            updateUI();

            if (reopenIndex !== null) {
                if (emojiModeEnabled) createEmojiPlayerDialog(reopenIndex);
                else createPlayerManagementDialog(reopenIndex);
            }
        }
        function toggleEmojiMode() { setEmojiMode(!emojiModeEnabled); }

        /* ---------------------------------------
           Rounds / Scores
        --------------------------------------- */
        // Add a round using values from the bottom input row
        function addRoundScores() {
            // Close the mobile keyboard on submission
            hideKeyboard();

            const scores = [];
            const inputs = document.querySelectorAll("#scoreTable input[type='number']");

            inputs.forEach((input, index) => {
                const score = parseInt(input.value) || 0;
                scores[index] = score;
                players[index].roundScores.push(score);
                players[index].totalScore = players[index].roundScores.reduce((a, b) => a + b, 0);
            });

            rounds.push(scores);
            saveData();

            // Clear the bottom inputs after submission
            unsubmittedScores = {};
            localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
            updateUI();
            inputs.forEach(input => input.value = '');

            // Scroll to the last row for convenience
            const scoreBody = document.getElementById("scoreBody");
            const lastRow = scoreBody.lastElementChild;
            if (lastRow) lastRow.scrollIntoView({ behavior: 'smooth', block: 'end' });
        }

        // Update a single score (contenteditable cell), then recalc totals
        function updateScore(roundIndex, playerIndex, newScore) {
            const score = parseInt(newScore) || 0;

            if (rounds[roundIndex] && rounds[roundIndex][playerIndex] !== undefined) {
                rounds[roundIndex][playerIndex] = score;

                if (players[playerIndex] && players[playerIndex].roundScores[roundIndex] !== undefined) {
                    players[playerIndex].roundScores[roundIndex] = score;
                    players[playerIndex].totalScore = players[playerIndex].roundScores.reduce((a, b) => a + b, 0);
                }
            }
            saveData();
            updateUI();
        }

        // Reset scores/rounds (keeps names in the same mode)
        function handleResetScores(button) {
            if (button.dataset.state === 'initial') {
                button.textContent = 'Confirm';
                button.dataset.state = 'confirm';
            } else {
                players.forEach(player => {
                    player.roundScores = [];
                    player.totalScore = 0;
                    player.name = player.name.toUpperCase(); // normalized before sync
                });
                rounds = [];
                unsubmittedScores = {};
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));

                // Respect current emoji/text mode
                syncDefaultNamesToMode();

                saveData();
                updateUI();
                closePopup('roundManagementModal');
            }
        }

        // Delete a round and recompute totals
        function deleteRound(roundIndex) {
            rounds.splice(roundIndex, 1);
            players.forEach(player => {
                player.roundScores.splice(roundIndex, 1);
                player.totalScore = player.roundScores.reduce((a, b) => a + b, 0);
            });
            saveData();
            updateUI();
            closePopup('deleteRoundModal');
        }

        // Utility: check if all bottom-row inputs are filled
        function allInputsFilled(inputs) {
            return Array.from(inputs).every(input => input.value.trim() !== '');
        }

        /* ---------------------------------------
           Sorting / Ranking / Theme shading
        --------------------------------------- */
        // Sort players (and each round) by current rank
        function applySortByRank(silent = false) {
            if (players.length <= 1 || rounds.length === 0) {
                if (!silent) updateUI();
                return;
            }

            const indices = players
                .map((p, i) => ({ i, score: p.totalScore }))
                .sort((a, b) => scoringMode === "highest" ? (b.score - a.score) : (a.score - b.score))
                .map(o => o.i);

            players = indices.map(i => players[i]);
            rounds = rounds.map(round => indices.map(i => round[i] ?? 0));

            saveData();
            if (!silent) updateUI();
        }

        // Compute rank text ("1st", "2nd", …) for a given total
        function getRank(score) {
            if (players.length === 1) return "1st";
            const sortedPlayers = [...players];
            if (scoringMode === "highest") {
                sortedPlayers.sort((a, b) => b.totalScore - a.totalScore);
            } else {
                sortedPlayers.sort((a, b) => a.totalScore - b.totalScore);
            }
            const rank = sortedPlayers.findIndex(player => player.totalScore === score) + 1;
            let suffix = 'th';
            if (rank % 10 === 1 && rank % 100 !== 11) suffix = 'st';
            if (rank % 10 === 2 && rank % 100 !== 12) suffix = 'nd';
            if (rank % 10 === 3 && rank % 100 !== 13) suffix = 'rd';
            return rank + suffix;
        }

        // Apply header shading based on ranks and selected theme color
        function updateRankings() {
            const playerRow = document.getElementById("playerRow");
            const columns = Array.from(playerRow.children).slice(1); // skip first (#) col

            // Clear previous bg
            columns.forEach((th) => { th.style.background = ''; });

            const { h: H, s: S } = getThemeHS();

            // Single player: just color if there are rounds
            if (players.length === 1) {
                if (rounds.length > 0) {
                    const Lmax = 82, range = 36;
                    const Lmin = Lmax - range;
                    const L = Lmin;
                    const Ltop = Math.max(18, L - 10);
                    const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
                    if (columns[0]) columns[0].style.background = gradient;
                }
                return;
            }

            if (rounds.length === 0) return;

            // Group players by equal totals (ties share a color)
            const scored = players.map((p, i) => ({ index: i, score: p.totalScore }))
                                  .sort((a, b) => scoringMode === "highest" ? (b.score - a.score) : (a.score - b.score));
            const groups = [];
            for (const item of scored) {
                const last = groups[groups.length - 1];
                if (!last || last.score !== item.score) {
                    groups.push({ score: item.score, members: [item.index] });
                } else {
                    last.members.push(item.index);
                }
            }

            // Shade range scales with distinct ranks
            const Lmax = 82;
            const minRange = 18;
            const maxRange = 44;
            const effectiveRanks = groups.length;

            if (effectiveRanks === 1) {
                const darkestL = Math.max(28, Lmax - maxRange);
                const Ltop = Math.max(18, darkestL - 10);
                const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${darkestL}%) 100%)`;
                columns.forEach(th => th.style.background = gradient);
                return;
            }

            const maxRanksForScaling = 8;
            const normalized = Math.min(1, Math.max(0, (effectiveRanks - 1) / (maxRanksForScaling - 1)));
            const range = Math.round(minRange + (maxRange - minRange) * normalized);
            const Lmin = Math.max(28, Lmax - range);

            // Apply gradients from best to worst
            groups.forEach((group, g) => {
                const ratio = g / (effectiveRanks - 1);
                const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
                const Ltop = Math.max(18, L - 10);
                const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
                group.members.forEach(idx => {
                    const th = columns[idx];
                    if (th) th.style.background = gradient;
                });
            });
        }

        /* ---------------------------------------
           UI Building
        --------------------------------------- */

        // Grapheme-aware fit: clip names to whole characters (no ellipsis, no half-glyphs)
        function clipPlayerNamesToCell() {
            const seg = (typeof Intl !== 'undefined' && Intl.Segmenter)
                ? new Intl.Segmenter('en', { granularity: 'grapheme' })
                : null;

            const els = document.querySelectorAll('#playerRow th .player-name');
            els.forEach(el => {
                const full = el.getAttribute('data-full') ?? el.textContent;
                el.setAttribute('data-full', full);
                el.textContent = full;

                if (el.scrollWidth <= el.clientWidth) return;

                const clusters = seg
                    ? Array.from(seg.segment(full), s => s.segment)
                    : Array.from(full); // fallback (may split emoji)

                let low = 0, high = clusters.length, best = 0;
                while (low <= high) {
                    const mid = Math.floor((low + high) / 2);
                    el.textContent = clusters.slice(0, mid).join('');
                    if (el.scrollWidth <= el.clientWidth) {
                        best = mid;
                        low = mid + 1;
                    } else {
                        high = mid - 1;
                    }
                }
                el.textContent = clusters.slice(0, best).join('');
            });
        }

        // Build header + scores table, wire up inputs
        function updateUI() {
            // Keep sorted (if enabled) before rendering
            if (sortByRankEnabled && players.length > 1 && rounds.length > 0) {
                applySortByRank(true);
            }

            const playerRow = document.getElementById("playerRow");
            const scoreTable = document.getElementById("scoreTable");
            const stickyHeader = document.querySelector(".sticky-header");

            // Compact font if many players
            if (players.length >= 7) {
                scoreTable.classList.add("small-scores");
                stickyHeader.classList.add("small-scores");
            } else {
                scoreTable.classList.remove("small-scores");
                stickyHeader.classList.remove("small-scores");
            }

            // Header: first cell opens Round dialog
            playerRow.innerHTML = `<th onclick="event.stopPropagation(); createRoundManagementDialog()">☰</th>`;

            // Header: player name, total, rank
            players.forEach((player, index) => {
                playerRow.innerHTML += `
                    <th draggable="true" 
                        ondragstart="handleDragStart(event, ${index})"
                        ondragover="handleDragOver(event)"
                        ondrop="handleDrop(event, ${index})"
                        ondragend="handleDragEnd(event)"
                        onclick="handlePlayerNameClick(event, ${index})"
                        title="${player.name}">
                        <span class="player-name">${player.name}</span>
                        <span class="score">${player.totalScore === 0 && rounds.length === 0 ? '' : (player.totalScore === 0 ? '0' : player.totalScore)}</span>
                        ${rounds.length > 0 ? `<br><small>${getRank(player.totalScore)}</small>` : ''}
                    </th>
                `;
            });

            // Body: scored rounds + bottom input row
            const scoreBody = document.getElementById("scoreBody");
            scoreBody.innerHTML = "";

            // Scored rounds (click on first cell to delete round)
            rounds.forEach((round, roundIndex) => {
                const row = document.createElement("tr");
                row.innerHTML = `<td onclick="createDeleteRoundDialog(${roundIndex})">${roundIndex + 1}</td>`;

                players.forEach((_, playerIndex) => {
                    const displayScore = round[playerIndex] !== undefined
                        ? (round[playerIndex] == 0
                            ? '<img src="https://r0wanb3zy.github.io/bezy.nz/score/assets/images/scorecard-icon-01.svg" style="width: 15px; height: 15px;" alt="Zero Score">'
                            : round[playerIndex])
                        : '<img src="/score/assets/images/scorecard-icon-01.svg" style="width: 15px; height: 15px;" alt="Zero Score">';

                    row.innerHTML += `
                        <td contenteditable="true" inputmode="numeric"
                            onclick="selectText(this)"
                            onblur="updateScore(${roundIndex}, ${playerIndex}, this.innerText)">
                            ${displayScore}
                        </td>`;
                });

                scoreBody.appendChild(row);
            });

            // Bottom input row (click + to submit)
            const inputRow = document.createElement('tr');
            inputRow.innerHTML = `<td onclick="addRoundScores()">＋</td>`;
            players.forEach((player) => {
                const savedValue = unsubmittedScores[player.name] || '';
                inputRow.innerHTML += `<td><input type="number" placeholder="${player.name}" inputmode="numeric" enterkeyhint="next" value="${savedValue}" /></td>`;
            });
            scoreBody.appendChild(inputRow);

            // Apply rank shading
            updateRankings();

            // Fit player names to header cell width (no half glyphs, no ellipsis)
            clipPlayerNamesToCell();

            // Wire keyboard interactions for inputs (Enter/Go to submit / Next to move)
            const inputs = document.querySelectorAll("#scoreTable input[type='number']");
            setEnterKeyHints(inputs);

            inputs.forEach((input, index) => {
                input.addEventListener('input', function () {
                    saveUnsubmittedScores();
                    setEnterKeyHints(inputs);
                });

                input.addEventListener('keydown', function(event) {
                    if (event.key === 'Enter' || event.keyCode === 13) {
                        event.preventDefault();
                        const allFilled = allInputsFilled(inputs);
                        if (allFilled) {
                            addRoundScores(); // also closes keyboard
                        } else {
                            // Move to the next empty input after this one; fallback to the first empty
                            const after = Array.from(inputs).slice(index + 1);
                            const nextEmpty = after.find(inp => inp.value.trim() === '') || Array.from(inputs).find(inp => inp.value.trim() === '');
                            if (nextEmpty) nextEmpty.focus();
                        }
                    }
                });
            });
        }

        /* ---------------------------------------
           Modals
        --------------------------------------- */
        // Player modal (text name version)
        function createPlayerManagementDialog(index) {
            const modal = document.getElementById('playerManagementModal');
            modal.innerHTML = `
                <h2>Player</h2>
                <span class="close-btn" onclick="closePopup('playerManagementModal')">×</span>
                <input
                    type="text"
                    id="playerNameInput"
                    value="${players[index].name}"
                    autocapitalize="characters"
                    inputmode="text"
                    style="text-transform: uppercase;"
                    autocomplete="off"
                    autocorrect="off"
                    spellcheck="false"
                >
                <div class="segmented-control">
                    <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, ${index})">
                    <label for="playerMode-name">Name</label>
                    <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, ${index})">
                    <label for="playerMode-emoji">Emoji</label>
                </div>
                <button onclick="handleRemovePlayer(this, ${index})" data-state="initial">Remove</button>
            `;
            modal.style.display = 'block';
            showOverlay();

            const input = modal.querySelector('#playerNameInput');

            // Auto-select contents on focus
            input.addEventListener('focus', function () {
                try { this.select(); } catch (_) {}
                try { this.setSelectionRange(0, this.value.length); } catch (_) {}
            });

            // Make the first tap focus/select without scrolling
            let primed = false;
            const primeFocus = (e) => {
                if (primed) return;
                primed = true;
                e.preventDefault();
                try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
                requestAnimationFrame(() => {
                    try { input.select(); } catch (_) {}
                    try { input.setSelectionRange(0, input.value.length); } catch (_) {}
                });
            };
            input.addEventListener('pointerdown', primeFocus, { passive: false });
            input.addEventListener('touchstart', primeFocus, { passive: false });
            input.addEventListener('mousedown', primeFocus);

            // Reduce mobile quirks
            input.addEventListener('contextmenu', (e) => e.preventDefault());
            input.addEventListener('mouseup', (e) => e.preventDefault());

            // Force uppercase as user types
            input.addEventListener('input', function () {
                this.value = this.value.toUpperCase();
            });

            // Save on Enter
            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const newName = (input.value || '').trim().toUpperCase();
                    if (newName && newName !== players[index].name) renamePlayer(index, newName);
                    closePopup('playerManagementModal');
                }
            });

            // Save on blur
            input.addEventListener('blur', function () {
                const newName = (input.value || '').trim().toUpperCase();
                if (newName && newName !== players[index].name) renamePlayer(index, newName);
            });
        }

        // Player modal (emoji version) with optional bulk selection flow
        function createEmojiPlayerDialog(index) {
            const modal = document.getElementById('playerManagementModal');
            const favEmojis = [
                "🍔","🩰","🌹","🌰","🔔",
                "👑","🎣","🌻","🏏","🦈",
                "🤸🏼‍♀️","🎁","🕊️","🧶","🛠️",
                "🏃‍➡️"
            ];
            const grid = favEmojis.map(e => `<button type="button" class="emoji-pick" data-emoji="${e}">${e}</button>`).join('');

            modal.innerHTML = `
                <h2>Player</h2>
                <span class="close-btn" onclick="closePopup('playerManagementModal')">×</span>
                <input
                    type="text"
                    id="emojiNameInput"
                    value="${players[index].name}"
                    inputmode="text"
                    placeholder="Pick an emoji"
                    enterkeyhint="done"
                    autocapitalize="off"
                    autocomplete="off"
                    autocorrect="off"
                    spellcheck="false"
                >
                <div class="emoji-grid">${grid}</div>

                <!-- Bulk multi-select toolbar (hidden until long-press) -->
                <div id="bulkEmojiActions" class="bulk-actions">
                  <div class="row">
                    <button type="button" id="bulkCancelBtn" class="light">Cancel</button>
                    <button type="button" id="bulkApplyBtn">Select</button>
                  </div>
                </div>

                <div class="segmented-control">
                    <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, ${index})">
                    <label for="playerMode-name">Name</label>
                    <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, ${index})">
                    <label for="playerMode-emoji">Emoji</label>
                </div>
                <button onclick="handleRemovePlayer(this, ${index})" data-state="initial">Remove</button>
            `;
            modal.style.display = 'block';
            showOverlay();

            // Reset bulk state on open
            bulkEmojiMode = false;
            bulkEmojiSelection = [];
            modal.classList.remove('bulk-mode');

            const input = modal.querySelector('#emojiNameInput');

            // First tap focuses + selects (mobile-friendly)
            let primed = false;
            const primeFocus = (e) => {
                if (primed) return;
                primed = true;
                e.preventDefault();
                try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
                requestAnimationFrame(() => {
                    try { input.select(); } catch (_) {}
                    try { input.setSelectionRange(0, input.value.length); } catch (_) {}
                });
            };
            input.addEventListener('pointerdown', primeFocus, { passive: false });
            input.addEventListener('touchstart', primeFocus, { passive: false });
            input.addEventListener('mousedown', primeFocus);

            input.addEventListener('mouseup', (e) => e.preventDefault());
            input.addEventListener('contextmenu', (e) => e.preventDefault());

            // Auto-close after typing a valid emoji (single-select mode)
            let autoClosed = false;
            input.addEventListener('input', function () {
                const sanitized = extractEmojis(this.value);
                if (sanitized !== this.value) this.value = sanitized;
                if (sanitized && !autoClosed && !bulkEmojiMode) {
                    renamePlayer(index, sanitized);
                    autoClosed = true;
                    closePopup('playerManagementModal');
                }
            });

            // Enter -> save (single-select mode)
            input.addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && !bulkEmojiMode) {
                    updatePlayerNameEmoji(index);
                }
            });

            // Set up grid interactions for tap (single) and long-press (bulk)
            attachEmojiGridInteractions(index);
        }

        // Extract only emoji-like graphemes from a string
        function extractEmojis(str) {
            if (!str) return '';
            let segments;
            if (typeof Intl !== 'undefined' && Intl.Segmenter) {
                segments = Array.from(new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(str), s => s.segment);
            } else {
                segments = Array.from(str);
            }
            const rePict = /\p{Extended_Pictographic}/u;
            const reRI = /[\u{1F1E6}-\u{1F1FF}]/u;
            const reKeycap = /[#*0-9]\uFE0F?\u20E3/u;
            const reVS16 = /\uFE0F/u;
            const reTagFlag = /\u{1F3F4}[\u{E0061}-\u{E007A}]{1,14}\u{E007F}/u;

            return segments
                .filter(seg => rePict.test(seg) || reRI.test(seg) || reKeycap.test(seg) || reVS16.test(seg) || reTagFlag.test(seg))
                .join('');
        }

        function setEmojiFromButton(btn, index) {
            const emoji = btn.getAttribute('data-emoji') || '';
            if (emoji) {
                renamePlayer(index, emoji);
                closePopup('playerManagementModal');
            }
        }

        function updatePlayerNameEmoji(index) {
            const input = document.getElementById('emojiNameInput');
            const newName = extractEmojis((input.value || '').trim());
            if (newName && newName !== players[index].name) {
                renamePlayer(index, newName);
            }
            closePopup('playerManagementModal');
        }

        // Wire up per-emoji interactions, long-press to enter bulk mode
        function attachEmojiGridInteractions(index) {
            const modal = document.getElementById('playerManagementModal');
            const buttons = Array.from(modal.querySelectorAll('.emoji-pick'));
            const bulkBar = modal.querySelector('#bulkEmojiActions');
            const seg = modal.querySelector('.segmented-control');
            const emojiInput = modal.querySelector('#emojiNameInput');

            const enterBulkEmojiMode = () => {
                if (bulkEmojiMode) return;
                bulkEmojiMode = true;
                bulkEmojiSelection = [];
                if (bulkBar) bulkBar.style.display = 'block';
                if (seg) seg.style.display = 'none';
                if (emojiInput) emojiInput.style.display = 'none';
                buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
                modal.classList.add('bulk-mode');
            };

            const exitBulkEmojiMode = () => {
                bulkEmojiMode = false;
                bulkEmojiSelection = [];
                if (bulkBar) bulkBar.style.display = 'none';
                if (seg) seg.style.display = '';
                if (emojiInput) emojiInput.style.display = '';
                buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
                modal.classList.remove('bulk-mode');
            };

            const renumberSelection = () => {
                // Clear and reapply order numbers for selected emojis
                buttons.forEach(b => {
                    if (b.classList.contains('selected')) b.setAttribute('data-order', '');
                });
                bulkEmojiSelection.forEach((emoji, i) => {
                    const b = buttons.find(btn => btn.getAttribute('data-emoji') === emoji);
                    if (b) b.setAttribute('data-order', String(i + 1));
                });
            };

            const toggleEmojiSelection = (btn) => {
                const emoji = btn.getAttribute('data-emoji');
                const idx = bulkEmojiSelection.indexOf(emoji);
                if (idx !== -1) {
                    bulkEmojiSelection.splice(idx, 1);
                    btn.classList.remove('selected');
                    btn.removeAttribute('data-order');
                } else {
                    if (bulkEmojiSelection.length >= bulkMaxPlayers) return;
                    bulkEmojiSelection.push(emoji);
                    btn.classList.add('selected');
                }
                renumberSelection();
            };

            const applyBulkEmojiPlayers = (selected) => {
                const targetCount = Math.min(bulkMaxPlayers, selected.length);
                if (targetCount < 1) return;

                // Turn on emoji mode for bulk selection
                emojiModeEnabled = true;
                localStorage.setItem('emojiModeEnabled', 'true');

                const currentCount = players.length;

                // Expand/shrink players to match selected count
                if (targetCount > currentCount) {
                    for (let i = currentCount; i < targetCount; i++) {
                        const newName = selected[i] || (emojiModeEnabled ? numberToKeycap(i + 1) : `P${i + 1}`.toUpperCase());
                        players.push({
                            name: newName,
                            totalScore: 0,
                            roundScores: Array(rounds.length).fill(0)
                        });
                    }
                    rounds.forEach(round => {
                        for (let i = round.length; i < targetCount; i++) round.push(0);
                    });
                } else if (targetCount < currentCount) {
                    players = players.slice(0, targetCount);
                    rounds.forEach(round => round.length = targetCount);
                }

                // Remap unsubmitted scores by new names
                const oldUnsubmitted = { ...unsubmittedScores };
                const newUnsubmitted = {};
                for (let i = 0; i < targetCount; i++) {
                    const oldName = players[i].name;
                    const newName = selected[i];
                    players[i].name = newName;
                    if (oldUnsubmitted[oldName] !== undefined) {
                        newUnsubmitted[newName] = oldUnsubmitted[oldName];
                    }
                }
                unsubmittedScores = newUnsubmitted;
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));

                saveData();
                updateUI();
            };

            // Toolbar buttons (Cancel / Select)
            const cancelBtn = modal.querySelector('#bulkCancelBtn');
            const applyBtn = modal.querySelector('#bulkApplyBtn');
            if (cancelBtn) cancelBtn.addEventListener('click', () => { exitBulkEmojiMode(); });
            if (applyBtn) applyBtn.addEventListener('click', () => {
                if (bulkEmojiSelection.length > 0) applyBulkEmojiPlayers(bulkEmojiSelection);
                exitBulkEmojiMode();
                closePopup('playerManagementModal');
            });

            // Button interactions (tap vs long-press)
            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    if (bulkEmojiMode) toggleEmojiSelection(btn);
                    else setEmojiFromButton(btn, index);
                });

                // Long-press (0.5s) to enter bulk mode
                let pressTimer = null;
                const start = () => {
                    if (bulkEmojiMode) return;
                    clearTimeout(pressTimer);
                    pressTimer = setTimeout(() => {
                        enterBulkEmojiMode();
                        // Now user can tap to select multiple
                    }, 500);
                };
                const cancel = () => {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                };

                btn.addEventListener('pointerdown', start);
                btn.addEventListener('pointerup', cancel);
                btn.addEventListener('pointerleave', cancel);
                btn.addEventListener('touchstart', start, { passive: true });
                btn.addEventListener('touchend', cancel);
                btn.addEventListener('touchcancel', cancel);
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', cancel);
                btn.addEventListener('mouseleave', cancel);
            });
        }

        // Player menu click (open right modal for current mode)
        function handlePlayerNameClick(event, index) {
            event.stopPropagation();
            closeAllPopups();
            if (emojiModeEnabled) createEmojiPlayerDialog(index);
            else createPlayerManagementDialog(index);
        }

        // Simple text-mode update (used by Enter key)
        function updatePlayerName(index, closeModal = true) {
            const input = document.getElementById('playerNameInput');
            if (!input) return;
            const newName = (input.value || '').trim().toUpperCase();
            if (newName && newName !== players[index].name) renamePlayer(index, newName);
            if (closeModal) closePopup('playerManagementModal');
        }

        // Round management (players count, high/low, theme, sort)
        function createRoundManagementDialog() {
            const modal = document.getElementById('roundManagementModal');
            modal.innerHTML = `
                <h2>Round</h2>
                <span class="close-btn" onclick="closePopup('roundManagementModal')">×</span>

                <select id="playerCount" onchange="updatePlayerCount()">
                    ${[1,2,3,4,5,6,7,8].map(i => `<option value="${i}" ${players.length === i ? 'selected' : ''}>${i} Players</option>`).join('')}
                </select>

                <div class="segmented-control">
                    <input type="radio" id="lowest" name="scoringMode" value="lowest" ${scoringMode === 'lowest' ? 'checked' : ''} onchange="scoringMode = 'lowest'; saveData(); updateUI();">
                    <label for="lowest">Low</label>
                    <input type="radio" id="highest" name="scoringMode" value="highest" ${scoringMode === 'highest' ? 'checked' : ''} onchange="scoringMode = 'highest'; saveData(); updateUI();">
                    <label for="highest">High</label>
                </div>

                <button id="sortByRankBtn" class="${sortByRankEnabled ? 'active' : ''}" onclick="toggleSortByRank()">Sort by Rank</button>

                <select id="themeColorSelect" onchange="setThemeColor(this.value)">
                    ${[
                        {v:'blue', t:'Blue'},
                        {v:'purple', t:'Purple'},
                        {v:'pink', t:'Pink'},
                        {v:'red', t:'Red'},
                        {v:'yellow', t:'Yellow'},
                        {v:'green', t:'Green'},
                        {v:'grey', t:'Grey'}
                    ].map(opt => `<option value="${opt.v}" ${themeColor === opt.v ? 'selected' : ''} style="color:${getThemeTextColor(opt.v)};">${opt.t}</option>`).join('')}
                </select>

                <button onclick="handleResetScores(this)" data-state="initial">Reset</button>
            `;
            modal.style.display = 'block';
            showOverlay();
            applyThemeSelectColors();
        }

        function toggleSortByRank() {
            sortByRankEnabled = !sortByRankEnabled;
            localStorage.setItem('sortByRankEnabled', sortByRankEnabled);
            const btn = document.getElementById('sortByRankBtn');
            if (btn) btn.classList.toggle('active', sortByRankEnabled);
            if (sortByRankEnabled) applySortByRank(true);
            updateUI();
        }

        // Update player count (adds/removes players + aligns rounds)
        function updatePlayerCount() {
            const newCount = parseInt(document.getElementById('playerCount').value);
            if (newCount > players.length) {
                for (let i = players.length; i < newCount; i++) {
                    const newLabel = emojiModeEnabled ? numberToKeycap(i + 1) : `P${i + 1}`.toUpperCase();
                    players.push({
                        name: newLabel,
                        totalScore: 0,
                        roundScores: Array(rounds.length).fill(0)
                    });
                    rounds.forEach(round => round.push(0));
                }
            } else if (newCount < players.length) {
                players = players.slice(0, newCount);
                rounds.forEach(round => round.length = newCount);
            }
            saveData();
            updateUI();
            closePopup('roundManagementModal');
        }

        // Confirmation dialog for deleting a round
        function createDeleteRoundDialog(roundIndex) {
            const modal = document.getElementById('deleteRoundModal');
            modal.innerHTML = `
                <h2>Round ${roundIndex + 1}</h2>
                <span class="close-btn" onclick="closePopup('deleteRoundModal')">×</span>
                <button onclick="deleteRound(${roundIndex})">Delete</button>
            `;
            modal.style.display = 'block';
            showOverlay();
        }

        // Contenteditable utility: select text on click
        function selectText(element) {
            const range = document.createRange();
            range.selectNodeContents(element);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }

        /* ---------------------------------------
           Modal / Overlay helpers
        --------------------------------------- */
        function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
        function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }

        function closePopup(modalId) {
            document.getElementById(modalId).style.display = 'none';
            hideOverlay();
        }

        function closeAllPopups() {
            document.getElementById('playerManagementModal').style.display = 'none';
            document.getElementById('roundManagementModal').style.display = 'none';
            document.getElementById('deleteRoundModal').style.display = 'none';
            hideOverlay();
        }

        // Overlay tap closes any open modal
        document.getElementById('overlay').addEventListener('click', closeAllPopups);

        // Remove player (with 2-tap confirm)
        function handleRemovePlayer(button, index) {
            if (button.dataset.state === 'initial') {
                button.textContent = 'Confirm';
                button.dataset.state = 'confirm';
            } else {
                removePlayer(index);
                closePopup('playerManagementModal');
            }
        }

        /* ---------------------------------------
           Drag & Drop (reorder players)
        --------------------------------------- */
        let draggedIndex = -1;

        function handleDragStart(event, index) {
            draggedIndex = index;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const target = event.target.closest('th');
            if (target && target !== event.currentTarget && !target.textContent.includes('☰')) {
                target.classList.add('drag-over');
            }
        }

        function handleDrop(event, dropIndex) {
            event.preventDefault();
            if (draggedIndex !== -1 && draggedIndex !== dropIndex) {
                const [draggedPlayer] = players.splice(draggedIndex, 1);
                players.splice(dropIndex, 0, draggedPlayer);

                rounds.forEach(round => {
                    const [draggedScore] = round.splice(draggedIndex, 1);
                    round.splice(dropIndex, 0, draggedScore);
                });

                saveData();
                updateUI();
            }
            const ths = document.querySelectorAll('#playerRow th');
            ths.forEach(th => th.classList.remove('drag-over'));
            draggedIndex = -1;
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            const ths = document.querySelectorAll('#playerRow th');
            ths.forEach(th => th.classList.remove('drag-over'));
            draggedIndex = -1;
        }

        /* ---------------------------------------
           Init
        --------------------------------------- */
        syncDefaultNamesToMode();
        updateUI();

        // Re-fit names when the window resizes or fonts finish loading
        window.addEventListener('resize', clipPlayerNamesToCell);
        if (window.document && document.fonts && document.fonts.addEventListener) {
            document.fonts.addEventListener('loadingdone', clipPlayerNamesToCell);
        } else {
            window.addEventListener('load', clipPlayerNamesToCell);
        }
    </script>
</body>
</html>
