<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Golf Scorecard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">

  <style>
    /* Base */
    html, body { height: 100%; margin: 0; }
    body {
      font-family: 'Economica', sans-serif;
      font-size: 22px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      min-height: 100vh;
      background-size: cover;
      overflow: hidden;             /* Prevent page scroll/creep */
      overscroll-behavior: none;
      -webkit-text-size-adjust: 100%;
    }

    :root {
      --hole-w: 30px;
      --par-w: 30px;
      --row-h: 34px;   /* JS updates this so all rows fit exactly */
      --header-h: 80px;
      --app-h: 100dvh; /* JS updates to VisualViewport height for stability */

      --ph-color: rgba(0, 0, 0, 0.24);
    }

    /* Fixed full-viewport app container (no padding to avoid over-height) */
    #app {
      position: fixed;
      inset: 0;
      height: var(--app-h);
      overflow: hidden;
      box-sizing: border-box;
      will-change: height;
    }

    /* Table base */
    table {
      width: 100%;
      height: 100%;            /* Fill app container */
      border-collapse: collapse;
      font-size: 20px;
      table-layout: fixed;
      font-family: 'Economica', sans-serif;
    }
    table, table th, table td { font-weight: bold; }

    /* Score table shell */
    #scoreTable {
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      overflow: hidden; /* No inner scroll; rows fit the space */
    }

    /* Header row */
    table th {
      background: linear-gradient(to bottom, #3b3b3b 0%, #3b3b3b 100%);
      color: white;
      border-bottom: none;
      cursor: pointer;
    }
    #scoreTable thead th {
      height: var(--header-h);
      font-size: 22px;
    }

    /* Top-left settings cell */
    #scoreTable thead th:first-child {
      background: #3b3b3b;
      color: #fff;
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
    }

    /* Cell base */
    table th, table td {
      text-align: center;
      padding: 5px;
      word-wrap: break-word;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: middle;
      border-bottom: 1px solid rgba(200, 200, 200, 0.3);
    }
    table td { border-right: 1px solid rgba(200, 200, 200, 0.3); }
    table td:last-child { border-right: none; }
    table tr:last-child td { border-bottom: none; }

    /* Sticky first two columns */
    th.hole-header, td.hole-cell {
      position: sticky; left: 0; z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--hole-w); min-width: var(--hole-w); max-width: var(--hole-w);
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
      cursor: default;
    }
    th.hole-header { cursor: pointer; }

    th.par-header, td.par-cell {
      position: sticky;
      left: calc(var(--hole-w) + 1px);
      z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--par-w); min-width: var(--par-w); max-width: var(--par-w);
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
    }
    th.par-header { border-right: none; }

    /* Rock-solid body row height */
    #scoreTable tbody td, #scoreTable tbody th {
      height: var(--row-h);
      line-height: var(--row-h);
      padding-top: 0;
      padding-bottom: 0;
      font-variant-numeric: tabular-nums;
    }

    /* Summary rows */
    .summary-row td {
      background: #3b3b3b; color: white;
      border-bottom: 1px solid #666; border-right: 1px solid #666;
    }
    .summary-row td:last-child { border-right: none; }

    /* Header content */
    #scoreTable thead th .player-name {
      display: block;
      max-width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: clip;
      text-align: center;
      font-size: 22px;
      line-height: 22px;
      margin: 0;
      padding-bottom: 2px;
    }
    #scoreTable thead th div[id^="total"] {
      display: block;
      font-size: 22px;
      color: rgba(255, 255, 255, 0.95);
      margin: 0;
    }
    #scoreTable thead th .to-par-line {
      display: block;
      line-height: 1;
      margin-top: 0;
    }
    .to-par-badge {
      display: inline-block;
      font-size: 16px;
      line-height: 1;
      padding: 4px 10px;
      border-radius: 9999px;
      background: #ffffff;
      color: #000000;
      vertical-align: middle;
      margin: 0;
    }
    #scoreTable.small-scores thead th .to-par-badge { font-size: 12px; }
    #scoreTable.small-scores thead th .player-name {
      font-size: 18px;
      line-height: 18px;
      padding-bottom: 2px;
    }

    .gear {
      font-size: 20px; cursor: inherit; color: #fff; background: none; border: none;
      padding: 0; margin: 0; line-height: 1;
    }

    /* Inline editing */
    #scoreBody td.editing {
      outline: 2px solid #000;
      outline-offset: -2px;
      box-shadow: none;
    }
    #scoreBody td.score-cell.editing { position: relative; }
    .inline-number {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      background: transparent;
      text-align: center;
      font: inherit;
      color: inherit;
      line-height: var(--row-h);
      padding: 0; margin: 0;
      -moz-appearance: textfield;
      appearance: textfield;
      caret-color: transparent;
      user-select: none; -webkit-user-select: none;
      cursor: default;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }
    .inline-number::selection, .inline-number::-moz-selection { background: transparent; }
    .inline-number::-webkit-outer-spin-button, .inline-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

    /* Popup/modal */
    #popupModal {
      display: none;
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 12px 20px;
      z-index: 1000; text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
      font-family: 'Economica', sans-serif;
    }
    #popupModal, #roundManagementModal { text-align: center; }
    #popupModal h2, #roundManagementModal h2, #playerNameModal h2 { margin: 15px 0; padding: 0; }

    #popupModal button {
      font-size: 24px; padding: 10px 20px; margin: 2px; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s;
    }

    /* Popup grid */
    #popupOptions {
      display: grid; grid-template-columns: repeat(5, 40px); gap: 5px; justify-content: center;
      padding: 10px 0; box-sizing: border-box;
    }
    #popupOptions .popup-spacer {
      width: 40px; height: 40px; visibility: hidden; pointer-events: none;
    }
    #popupOptions button {
      width: 40px; height: 40px; font-size: 24px; padding: 0; margin: 0; box-sizing: border-box;
      cursor: pointer; font-family: 'Economica', sans-serif, Arial; display: flex; justify-content: center; align-items: center;
      text-align: center; overflow: hidden; white-space: nowrap;
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s ease;
      -webkit-appearance: none; appearance: none; line-height: 1; outline: none;
    }

    .close-btn {
      position: absolute; top: 0px; right: 0px;
      font-size: 48px; color: #000000; cursor: pointer; background: none; border: none;
      padding: 0; line-height: 1; width: 40px; height: 40px; text-align: center; transition: color 0.2s ease;
    }

    /* Round management modal */
    #roundManagementModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px; text-align: center;
    }
    #roundManagementModal select {
      font-size: 24px; padding: 10px; margin: 5px 0;
      font-family: 'Economica', sans-serif; border: 1px solid #262626; border-radius: 6px;
      background: #f8f9fa; width: 100%; box-sizing: border-box;
      text-align: center; text-align-last: center; -moz-text-align-last: center;
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; padding-right: 12px;
    }
    #roundManagementModal select#playerCount { text-align: center; text-align-last: center; }
    #roundManagementModal select#playerCount::-ms-expand { display: none; }
    #roundManagementModal select#playerCount option { text-align: center; }

    #roundManagementModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #roundManagementModal button#sortByRankBtn {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }
    #roundManagementModal button#sortByRankBtn.active {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #ffffff; border: 1px solid #262626;
    }
    #roundManagementModal button#resetButton[data-confirm="true"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }

    /* Player Name Modal */
    #playerNameModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; text-align: center; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
    }
    #playerNameModal h2 { margin: 15px 0; padding: 0; }
    #playerNameModal input[type="text"] {
      font-size: 24px; padding: 10px; width: 100%; box-sizing: border-box; margin: 5px 0; text-align: center;
      font-family: 'Economica', sans-serif; border: 1px solid #d0d7de; border-radius: 6px; background: #ffffff;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); transition: border-color 0.2s ease;
    }
    #playerNameModal input[type="text"]:focus { outline: none; border: 1px solid #262626; }
    #playerNameModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #playerNameModal button[data-state="confirm"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }
    #playerNameModal button.light {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }

    /* Segmented control */
    .segmented-control {
      display: flex; width: 100%; box-sizing: border-box; margin: 5px 0;
      background: #f8f9fa; border-radius: 6px; overflow: hidden; border: 1px solid #262626;
    }
    .segmented-control input[type="radio"] { display: none; }
    .segmented-control label {
      flex: 1 1 0; padding: 10px 0; text-align: center; font-size: 24px; font-family: 'Economica', sans-serif;
      cursor: pointer; user-select: none; background: #f8f9fa; margin: 0;
    }
    .segmented-control input[type="radio"]:checked + label {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff;
    }

    /* Emoji grid */
    .emoji-grid {
      --emoji-gap: 8px;
      display: grid; grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: var(--emoji-gap); padding: 0; margin: 5px 0; width: 100%; box-sizing: border-box;
      user-select: none; -webkit-user-select: none;
    }
    #playerNameModal .emoji-grid .emoji-pick {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: #ffffff; border: none; border-radius: 6px;
      font-family: 'Economica', sans-serif; font-size: 22px;
      display: grid; place-items: center;
      width: 100%; aspect-ratio: 1 / 1; padding: 0; margin: 0; line-height: 1; cursor: pointer;
      transition: transform 0.05s ease, filter 0.1s ease;
      box-sizing: border-box; position: relative;
      -webkit-appearance: none; appearance: none; outline: none;
      padding-bottom: 2px;
    }
    #playerNameModal .emoji-grid .emoji-pick:active { transform: scale(0.95); filter: brightness(1.05); }
    .emoji-grid .emoji-pick.selected { box-shadow: 0 0 0 2px #262626 inset; }
    .emoji-grid .emoji-pick.selected::before {
      content: ""; position: absolute; inset: 0; background: rgba(0, 0, 0, 0.35);
      border-radius: 6px; pointer-events: none; z-index: 1;
    }
    .emoji-grid .emoji-pick.selected::after {
      content: attr(data-order); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%);
      font-size: 28px; font-weight: 700; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 3px rgba(0,0,0,0.7);
      pointer-events: none; z-index: 2;
    }

    .bulk-actions { display: none; margin: 5px 0 0 0; width: 100%; }
    .bulk-actions .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: center; width: 100%; }

    /* Overlay */
    #overlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999; cursor: pointer;
    }

    /* Drag feedback */
    th.dragging { opacity: 0.5; }

    /* Round modal: theme-colored option text */
    #roundManagementModal select#themeColorSelect {
      text-align: center; text-align-last: center;
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; background-color: #f8f9fa; padding-right: 12px;
    }
    #roundManagementModal select#themeColorSelect::-ms-expand { display: none; }
    #roundManagementModal select#themeColorSelect option { text-align: center; }

    * { -webkit-tap-highlight-color: transparent; }

    /* Remove bottom border under player header cells (name columns only) */
    #scoreTable thead th[data-player] { border-bottom: none !important; }
    /* Keep bottom border on the left headers */
    #scoreTable thead th.hole-header, #scoreTable thead th.par-header { border-bottom: 1px solid #666; }

    /* Remove right border from par cells (hole rows only) */
    #scoreTable tbody tr:not(.summary-row) td.par-cell { border-right: none !important; }
    #scoreTable tbody tr.summary-row td.par-cell { border-right: 1px solid #666 !important; }

    /* Hole lock visuals */
    #scoreBody tr.active-hole td.score-cell { background: rgba(0, 0, 0, 0.03); }
    #scoreBody tr.show-placeholders td.score-cell { background: rgba(0, 0, 0, 0.03); }

    /* Placeholders */
    #scoreBody tr.show-placeholders td.score-cell:empty::before {
      content: attr(data-placeholder);
      color: var(--ph-color);
      font-weight: normal;
      font-style: normal;
      pointer-events: none;
      display: block;
      width: 100%;
      line-height: var(--row-h);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .inline-number::placeholder { color: var(--ph-color); opacity: 1; }
    #scoreBody tr:not(.summary-row) .hole-cell { cursor: pointer; }
  </style>
</head>
<body>

  <!-- Fixed, full-viewport app container -->
  <div id="app">
    <!-- Score Table -->
    <table id="scoreTable">
      <thead>
        <tr id="playerRow">
          <th class="hole-header" onclick="showRoundManagement()"><button class="gear" title="Round settings">☰</button></th>
          <th class="par-header" onclick="showParResetPopup()">Par</th>
          <th data-player="P1" title="🩰" draggable="true">
            <span class="player-name" data-full="🩰" title="🩰">🩰</span>
            <div id="totalP1"></div>
            <div class="to-par-line" id="toParP1"></div>
          </th>
          <th data-player="P2" title="🌹" draggable="true">
            <span class="player-name" data-full="🌹" title="🌹">🌹</span>
            <div id="totalP2"></div>
            <div class="to-par-line" id="toParP2"></div>
          </th>
          <th data-player="P3" title="3️⃣" draggable="true">
            <span class="player-name" data-full="3️⃣" title="3️⃣">3️⃣</span>
            <div id="totalP3"></div>
            <div class="to-par-line" id="toParP3"></div>
          </th>
        </tr>
      </thead>
      <tbody id="scoreBody">
        <tr><td class="hole-cell">1</td><td class="par-cell" data-hole="H1">3</td><td class="score-cell" data-player="P1" data-hole="H1"></td><td class="score-cell" data-player="P2" data-hole="H1"></td><td class="score-cell" data-player="P3" data-hole="H1"></td></tr>
        <tr><td class="hole-cell">2</td><td class="par-cell" data-hole="H2">3</td><td class="score-cell" data-player="P1" data-hole="H2"></td><td class="score-cell" data-player="P2" data-hole="H2"></td><td class="score-cell" data-player="P3" data-hole="H2"></td></tr>
        <tr><td class="hole-cell">3</td><td class="par-cell" data-hole="H3">3</td><td class="score-cell" data-player="P1" data-hole="H3"></td><td class="score-cell" data-player="P2" data-hole="H3"></td><td class="score-cell" data-player="P3" data-hole="H3"></td></tr>
        <tr><td class="hole-cell">4</td><td class="par-cell" data-hole="H4">3</td><td class="score-cell" data-player="P1" data-hole="H4"></td><td class="score-cell" data-player="P2" data-hole="H4"></td><td class="score-cell" data-player="P3" data-hole="H4"></td></tr>
        <tr><td class="hole-cell">5</td><td class="par-cell" data-hole="H5">3</td><td class="score-cell" data-player="P1" data-hole="H5"></td><td class="score-cell" data-player="P2" data-hole="H5"></td><td class="score-cell" data-player="P3" data-hole="H5"></td></tr>
        <tr><td class="hole-cell">6</td><td class="par-cell" data-hole="H6">3</td><td class="score-cell" data-player="P1" data-hole="H6"></td><td class="score-cell" data-player="P2" data-hole="H6"></td><td class="score-cell" data-player="P3" data-hole="H6"></td></tr>
        <tr><td class="hole-cell">7</td><td class="par-cell" data-hole="H7">3</td><td class="score-cell" data-player="P1" data-hole="H7"></td><td class="score-cell" data-player="P2" data-hole="H7"></td><td class="score-cell" data-player="P3" data-hole="H7"></td></tr>
        <tr><td class="hole-cell">8</td><td class="par-cell" data-hole="H8">3</td><td class="score-cell" data-player="P1" data-hole="H8"></td><td class="score-cell" data-player="P2" data-hole="H8"></td><td class="score-cell" data-player="P3" data-hole="H8"></td></tr>
        <tr><td class="hole-cell">9</td><td class="par-cell" data-hole="H9">3</td><td class="score-cell" data-player="P1" data-hole="H9"></td><td class="score-cell" data-player="P2" data-hole="H9"></td><td class="score-cell" data-player="P3" data-hole="H9"></td></tr>
        <tr class="summary-row"><td class="hole-cell">OUT</td><td class="par-cell" data-sum="out-par">27</td><td data-sum="out-P1">0</td><td data-sum="out-P2">0</td><td data-sum="out-P3">0</td></tr>
        <tr><td class="hole-cell">10</td><td class="par-cell" data-hole="H10">3</td><td class="score-cell" data-player="P1" data-hole="H10"></td><td class="score-cell" data-player="P2" data-hole="H10"></td><td class="score-cell" data-player="P3" data-hole="H10"></td></tr>
        <tr><td class="hole-cell">11</td><td class="par-cell" data-hole="H11">3</td><td class="score-cell" data-player="P1" data-hole="H11"></td><td class="score-cell" data-player="P2" data-hole="H11"></td><td class="score-cell" data-player="P3" data-hole="H11"></td></tr>
        <tr><td class="hole-cell">12</td><td class="par-cell" data-hole="H12">3</td><td class="score-cell" data-player="P1" data-hole="H12"></td><td class="score-cell" data-player="P2" data-hole="H12"></td><td class="score-cell" data-player="P3" data-hole="H12"></td></tr>
        <tr><td class="hole-cell">13</td><td class="par-cell" data-hole="H13">3</td><td class="score-cell" data-player="P1" data-hole="H13"></td><td class="score-cell" data-player="P2" data-hole="H13"></td><td class="score-cell" data-player="P3" data-hole="H13"></td></tr>
        <tr><td class="hole-cell">14</td><td class="par-cell" data-hole="H14">3</td><td class="score-cell" data-player="P1" data-hole="H14"></td><td class="score-cell" data-player="P2" data-hole="H14"></td><td class="score-cell" data-player="P3" data-hole="H14"></td></tr>
        <tr><td class="hole-cell">15</td><td class="par-cell" data-hole="H15">3</td><td class="score-cell" data-player="P1" data-hole="H15"></td><td class="score-cell" data-player="P2" data-hole="H15"></td><td class="score-cell" data-player="P3" data-hole="H15"></td></tr>
        <tr><td class="hole-cell">16</td><td class="par-cell" data-hole="H16">3</td><td class="score-cell" data-player="P1" data-hole="H16"></td><td class="score-cell" data-player="P2" data-hole="H16"></td><td class="score-cell" data-player="P3" data-hole="H16"></td></tr>
        <tr><td class="hole-cell">17</td><td class="par-cell" data-hole="H17">3</td><td class="score-cell" data-player="P1" data-hole="H17"></td><td class="score-cell" data-player="P2" data-hole="H17"></td><td class="score-cell" data-player="P3" data-hole="H17"></td></tr>
        <tr><td class="hole-cell">18</td><td class="par-cell" data-hole="H18">3</td><td class="score-cell" data-player="P1" data-hole="H18"></td><td class="score-cell" data-player="P2" data-hole="H18"></td><td class="score-cell" data-player="P3" data-hole="H18"></td></tr>
        <tr class="summary-row"><td class="hole-cell">IN</td><td class="par-cell" data-sum="in-par">27</td><td data-sum="in-P1">0</td><td data-sum="in-P2">0</td><td data-sum="in-P3">0</td></tr>
      </tbody>
    </table>
  </div>

  <!-- Popup -->
  <div id="popupModal">
    <h2 id="popupTitle">Select</h2>
    <span class="close-btn" onclick="closePopupModal()">×</span>
    <div id="popupOptions"></div>
  </div>

  <!-- Round Management -->
  <div id="roundManagementModal">
    <h2>Round</h2>
    <span class="close-btn" onclick="closeRoundManagement()">×</span>

    <select id="playerCount" onchange="updatePlayerCount()">
      <option value="1">1 Players</option>
      <option value="2">2 Players</option>
      <option value="3">3 Players</option>
      <option value="4">4 Players</option>
      <option value="5">5 Players</option>
      <option value="6">6 Players</option>
      <option value="7">7 Players</option>
      <option value="8">8 Players</option>
    </select>

    <div class="segmented-control" id="holesSegment">
      <input type="radio" id="holes9" name="holesCount" value="9" onchange="setHolesCount(9)">
      <label for="holes9">9 Holes</label>
      <input type="radio" id="holes18" name="holesCount" value="18" onchange="setHolesCount(18)">
      <label for="holes18">18 Holes</label>
    </div>

    <button id="sortByRankBtn" onclick="toggleSortByRank()">Sort by Rank</button>
    <select id="themeColorSelect" onchange="setThemeColor(this.value)" style="color: rgb(13, 87, 160);">
      <option value="blue" style="color: rgb(13, 87, 160);">Blue</option>
      <option value="purple" style="color: rgb(83, 26, 147);">Purple</option>
      <option value="pink" style="color: rgb(147, 26, 87);">Pink</option>
      <option value="red" style="color: rgb(154, 19, 19);">Red</option>
      <option value="yellow" style="color: rgb(155, 118, 8);">Yellow</option>
      <option value="green" style="color: rgb(43, 130, 43);">Green</option>
      <option value="grey" style="color: rgb(87, 87, 87);">Grey</option>
    </select>
    <button id="resetButton" onclick="handleResetClick()">Reset</button>
  </div>

  <!-- Player Name Modal -->
  <div id="playerNameModal"></div>

  <!-- Overlay -->
  <div id="overlay"></div>

  <script>
    /* ---------------- State / storage ---------------- */
    const LS = {
      holesCount: 'dg-holesCount',
      playerCount: 'dg-playerCount',
      themeColor: 'dg-themeColor',
      sort: 'dg-sortByRankEnabled',
      emojiMode: 'dg-emojiModeEnabled',
      name: (p) => `dg-playerName-${p}`,
      par:  (h) => `dg-par-H${h}`,
      score:(p,h)=> `dg-${p}-H${h}`,
    };

    const THEME_MAP = {
      blue:   { h: 210, s: 85 },
      red:    { h:   0, s: 78 },
      green:  { h: 120, s: 50 },
      pink:   { h: 330, s: 70 },
      purple: { h: 268, s: 70 },
      yellow: { h:  45, s: 90 },
      grey:   { h: 210, s:  0 }
    };
    function getThemeHS(key) { return THEME_MAP[key] || THEME_MAP.blue; }
    function getThemeTextColor(key) {
      const t = THEME_MAP[key] || THEME_MAP.blue;
      const L = key === 'yellow' ? 32 : 34;
      return `hsl(${t.h}, ${t.s}%, ${L}%)`;
    }
    function applyThemeSelectColors() {
      const select = document.querySelector('#roundManagementModal select#themeColorSelect');
      if (!select) return;
      select.style.color = getThemeTextColor(themeColor);
      Array.from(select.options).forEach(opt => { opt.style.color = getThemeTextColor(opt.value); });
    }

    const KEYCAP_DIGITS = ["0️⃣","1️⃣","2️⃣","3️⃣","4️⃣","5️⃣","6️⃣","7️⃣","8️⃣","9️⃣"];
    function numberToKeycap(n) { return KEYCAP_DIGITS[n] || String(n); }
    function keycapToNumber(str) {
      const idx = KEYCAP_DIGITS.indexOf(str);
      return idx === -1 ? null : idx;
    }
    function extractEmojis(str) {
      if (!str) return '';
      let segments;
      if (typeof Intl !== 'undefined' && Intl.Segmenter) {
        segments = Array.from(new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(str), s => s.segment);
      } else { segments = Array.from(str); }
      const rePict = /\p{Extended_Pictographic}/u;
      const reRI = /[\u{1F1E6}-\u{1F1FF}]/u;
      const reKeycap = /[#*0-9]\uFE0F?\u20E3/u;
      const reVS16 = /\uFE0F/u;
      const reTagFlag = /\u{1F3F4}[\u{E0061}-\u{E007A}]{1,14}\u{E007F}/u;
      return segments.filter(seg =>
        rePict.test(seg) || reRI.test(seg) || reKeycap.test(seg) || reVS16.test(seg) || reTagFlag.test(seg)
      ).join('');
    }

    let themeColor = localStorage.getItem(LS.themeColor) || 'blue';
    let holesCount = [9,18].includes(parseInt(localStorage.getItem(LS.holesCount),10)) ? parseInt(localStorage.getItem(LS.holesCount),10) : 18;
    let playerCount = Math.min(8, Math.max(1, parseInt(localStorage.getItem(LS.playerCount) || '4', 10)));
    let sortByRankEnabled = localStorage.getItem(LS.sort) === 'true';
    let emojiModeEnabled = localStorage.getItem(LS.emojiMode) === 'true';

    // Inline edit state
    let activeCell = null;
    let activeInput = null;
    let activeMode = null; // 'score' | 'par'
    let resetConfirm = false;

    // NEW: remember if lock was created by this click
    let lockPrimedHole = null; // e.g., "H3"

    // One-hole-at-a-time scoring
    let lockedHole = null; // e.g., "H3"
    function setLockedHole(holeId) {
      lockedHole = holeId;
      updateHoleLockVisuals();
      syncHolePlaceholderState();
    }
    function clearLockedHole() {
      lockedHole = null;
      updateHoleLockVisuals();
      syncHolePlaceholderState();
    }
    function updateHoleLockVisuals() {
      const rows = document.querySelectorAll('#scoreBody tr');
      rows.forEach(tr => {
        tr.classList.remove('active-hole','inactive-hole');
        if (!lockedHole) return;
        if (tr.classList.contains('summary-row')) return;
        const rowHole = tr.querySelector('td.par-cell')?.getAttribute('data-hole') || null;
        if (rowHole === lockedHole) tr.classList.add('active-hole');
      });
    }
    function getScoreCellsInHole(holeId) {
      return Array.from(document.querySelectorAll(`#scoreBody td.score-cell[data-hole="${holeId}"]`));
    }
    function getNextEmptyScoreCellInHole(currentTd, currentDisplayText) {
      const holeId = lockedHole || currentTd.getAttribute('data-hole');
      const cells = getScoreCellsInHole(holeId);
      const idx = cells.indexOf(currentTd);

      const treatCurrentAsEmpty = String(currentDisplayText ?? '').trim() === '';
      const isEmpty = (td) => td.textContent.trim() === '';

      const empties = cells.filter(td => td === currentTd ? treatCurrentAsEmpty : isEmpty(td));
      if (empties.length === 0) return null;

      const after = empties.find(td => cells.indexOf(td) > idx);
      return after || empties[0];
    }
    function clearLockedHoleIfComplete(holeNum) {
      if (!lockedHole || !holeNum) return;
      if (`H${holeNum}` === lockedHole && isHoleComplete(holeNum)) {
        clearLockedHole();
      }
    }
    function isHoleEmpty(h) {
      if (!h || h < 1 || h > holesCount) return false;
      for (let p = 1; p <= playerCount; p++) {
        if (getScore(`P${p}`, h) != null) return false;
      }
      return true;
    }
    function updateEnterKeyHintForInput(input, td) {
      try {
        const next = getNextEmptyScoreCellInHole(td, input.value);
        input.setAttribute('enterkeyhint', next ? 'next' : 'done');
      } catch (_) {}
    }

    /* -------- Placeholders -------- */
    function getHoleRowEl(holeId) {
      const parCell = document.querySelector(`#scoreBody td.par-cell[data-hole="${holeId}"]`);
      return parCell ? parCell.parentElement : null;
    }
    function showHolePlaceholders(holeId) {
      const target = lockedHole || holeId;
      document.querySelectorAll('#scoreBody tr.show-placeholders')
        .forEach(tr => tr.classList.remove('show-placeholders'));
      const row = getHoleRowEl(target);
      if (row) row.classList.add('show-placeholders');
    }
    function clearHolePlaceholders() {
      document.querySelectorAll('#scoreBody tr.show-placeholders')
        .forEach(tr => tr.classList.remove('show-placeholders'));
    }
    function syncHolePlaceholderState() {
      if (lockedHole) {
        showHolePlaceholders(lockedHole);
      } else if (activeCell) {
        const hid = activeCell.getAttribute('data-hole');
        if (hid) showHolePlaceholders(hid);
        else clearHolePlaceholders();
      } else {
        clearHolePlaceholders();
      }
    }
    function getPlayerDisplayName(pid) {
      const el = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      return el?.getAttribute('data-full') || el?.textContent || pid;
    }
    function getPlayerTrimmedName(pid) {
      const el = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      const trimmed = el?.textContent?.trim();
      return trimmed || getPlayerDisplayName(pid);
    }
    function updatePlaceholdersForPlayer(pid) {
      const nm = getPlayerTrimmedName(pid);
      document.querySelectorAll(`#scoreBody td.score-cell[data-player="${pid}"]`)
        .forEach(td => td.setAttribute('data-placeholder', nm));
      if (activeInput && activeMode === 'score' && activeCell?.getAttribute('data-player') === pid) {
        activeInput.placeholder = nm;
      }
    }
    function updateAllPlaceholders() {
      for (let p = 1; p <= playerCount; p++) updatePlaceholdersForPlayer(`P${p}`);
    }

    // Outside tap management
    let suppressNextCellEditClick = false;
    let suppressClickTimeout = null;
    let isApplyingInline = false;

    // Drag & drop state
    let draggedIndex = -1;

    /* ---------------- VisualViewport sync (stable height, no translate) ---------------- */
    function syncAppViewport() {
      const vv = window.visualViewport;
      if (vv) {
        document.documentElement.style.setProperty('--app-h', Math.round(vv.height) + 'px');
      } else {
        document.documentElement.style.setProperty('--app-h', window.innerHeight + 'px');
      }
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    /* ---------------- Init ---------------- */
    document.addEventListener('DOMContentLoaded', () => {
      const pcSel = document.getElementById('playerCount');
      if (pcSel) pcSel.value = String(playerCount);
      const themeSel = document.getElementById('themeColorSelect');
      if (themeSel) themeSel.value = themeColor;
      applyThemeSelectColors();

      const holes9 = document.getElementById('holes9');
      const holes18 = document.getElementById('holes18');
      if (holes9 && holes18) {
        holes9.checked = holesCount === 9;
        holes18.checked = holesCount === 18;
      }

      buildTable();
      loadFromStorage();
      updateAllTotals();
      updateRanks();

      // First layout pass + Viewport sizing
      syncAppViewport();

      // Clip headers then sync placeholders
      clipPlayerNamesToCell();
      updateAllPlaceholders();

      attachDragListeners();

      const sortBtn = document.getElementById('sortByRankBtn');
      if (sortBtn) sortBtn.classList.toggle('active', sortByRankEnabled);

      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', syncAppViewport);
        window.visualViewport.addEventListener('scroll', syncAppViewport);
      }
    });

    window.addEventListener('resize', () => { syncAppViewport(); });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => { syncAppViewport(); }, 250);
    });

    function onHeaderClick(e) {
      const th = e.currentTarget;
      const pid = th.getAttribute('data-player');
      window.currentPlayer = pid;
      openPlayerModalForHeader(pid);
    }

    /* ---------------- Build ---------------- */
    function buildTable() {
      const headerRow = document.getElementById('playerRow');
      headerRow.innerHTML = `
        <th class="hole-header" onclick="showRoundManagement()"><button class="gear" title="Round settings">☰</button></th>
        <th class="par-header" onclick="showParResetPopup()">Par</th>
      `;

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        const th = document.createElement('th');
        th.setAttribute('data-player', pid);
        th.title = savedName;
        th.innerHTML = `
          <span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span>
          <div id="total${pid}"></div>
          <div class="to-par-line" id="toPar${pid}"></div>
        `;
        th.addEventListener('click', onHeaderClick);
        headerRow.appendChild(th);
      }

      const body = document.getElementById('scoreBody');
      body.innerHTML = '';

      const firstNine = Math.min(9, holesCount);
      for (let h = 1; h <= firstNine; h++) body.appendChild(makeHoleRow(h));

      // OUT summary
      const trOut = document.createElement('tr');
      trOut.className = 'summary-row';
      trOut.appendChild(makeStickyCell('hole-cell', 'OUT'));
      const outPar = document.createElement('td'); outPar.className = 'par-cell'; outPar.setAttribute('data-sum', 'out-par');
      trOut.appendChild(outPar);
      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td'); td.setAttribute('data-sum', `out-P${p}`); trOut.appendChild(td);
      }
      body.appendChild(trOut);

      if (holesCount > 9) {
        for (let h = 10; h <= holesCount; h++) body.appendChild(makeHoleRow(h));
        // IN summary
        const trIn = document.createElement('tr');
        trIn.className = 'summary-row';
        trIn.appendChild(makeStickyCell('hole-cell', 'IN'));
        const inPar = document.createElement('td'); inPar.className = 'par-cell'; inPar.setAttribute('data-sum', 'in-par');
        trIn.appendChild(inPar);
        for (let p = 1; p <= playerCount; p++) {
          const td = document.createElement('td'); td.setAttribute('data-sum', `in-P${p}`); trIn.appendChild(td);
        }
        body.appendChild(trIn);
      }

      clearLockedHole();
      updateAllPlaceholders();
    }
    function makeStickyCell(cls, text) {
      const td = document.createElement('td');
      td.className = cls;
      td.textContent = text;
      return td;
    }
    function makeHoleRow(h) {
      const tr = document.createElement('tr');

      const tdHole = document.createElement('td');
      tdHole.className = 'hole-cell';
      tdHole.textContent = String(h);
      tdHole.addEventListener('click', () => {
        const holeId = `H${h}`;
        if (!lockedHole) setLockedHole(holeId);
        else if (lockedHole === holeId) clearLockedHole();
      });
      tr.appendChild(tdHole);

      const tdPar = document.createElement('td');
      tdPar.className = 'par-cell';
      tdPar.setAttribute('data-hole', `H${h}`);
      tdPar.addEventListener('click', () => startInlineEdit(tdPar, 'par'));
      tdPar.textContent = '3';
      tr.appendChild(tdPar);

      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.className = 'score-cell';
        td.setAttribute('data-player', `P${p}`);
        td.setAttribute('data-hole', `H${h}`);
        td.addEventListener('click', () => startInlineEdit(td, 'score'));
        tr.appendChild(td);
      }
      return tr;
    }

    /* ---------------- Storage load ---------------- */
    function loadFromStorage() {
      // Pars
      for (let h = 1; h <= holesCount; h++) {
        const savedPar = parseInt(localStorage.getItem(LS.par(h)) || '3', 10);
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = String(savedPar);
      }
      // Scores
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const saved = localStorage.getItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && saved != null) td.textContent = saved;
        }
      }
      // Names
      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const headerName = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        const savedName = localStorage.getItem(LS.name(pid));
        if (headerName && savedName) {
          headerName.textContent = savedName;
          headerName.setAttribute('data-full', savedName);
          headerName.setAttribute('title', savedName);
        }
      }
      updateAllPlaceholders();
    }

    /* ---------------- Inline editing ---------------- */
    function startInlineEdit(td, mode, options = {}) {
      const holeId = td.getAttribute('data-hole');

      if (mode === 'score') {
        if (lockedHole && lockedHole !== holeId) return;
        if (!lockedHole && holeId) {
          setLockedHole(holeId);
          lockPrimedHole = holeId;
        } else {
          lockPrimedHole = null;
        }
      } else if (mode === 'par') {
        if (lockedHole && lockedHole !== holeId) return;
      }

      if (holeId) showHolePlaceholders(holeId);

      const preserveKeyboard = !!options.preserveKeyboard;
      const prevCell = activeCell;
      const prevInput = activeInput;
      const prevDisplayText = options.prevDisplayText;

      if (!preserveKeyboard) endInlineEdit(true);

      const prevText = td.textContent.trim();
      activeCell = td;
      activeMode = mode;

      const input = document.createElement('input');
      input.type = 'number';
      input.className = 'inline-number';
      input.inputMode = 'numeric';
      input.autocomplete = 'off';
      input.autocorrect = 'off';
      input.spellcheck = false;
      input.value = prevText;
      input.setAttribute('enterkeyhint', mode === 'score' ? 'next' : 'done');
      input._edited = false;
      input._clearedOnFirstInsert = false;

      if (mode === 'score') {
        const pid = td.getAttribute('data-player');
        if (pid) input.placeholder = getPlayerTrimmedName(pid);
      }

      td.dataset.prev = prevText;
      td.textContent = '';
      td.classList.add('editing');
      td.appendChild(input);

      input.addEventListener('beforeinput', (e) => {
        if (!input._clearedOnFirstInsert && e.inputType && e.inputType.startsWith('insert')) {
          input.value = '';
          input._clearedOnFirstInsert = true;
        }
      });
      input.addEventListener('keydown', (e) => {
        if (!input._clearedOnFirstInsert && e.key && e.key.length === 1 && /[0-9]/.test(e.key)) {
          input.value = '';
          input._clearedOnFirstInsert = true;
        }
        if (e.key === 'Enter') {
          e.preventDefault();
          applyInlineEdit(input.value, true);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelInlineEdit();
        }
      });
      input.addEventListener('input', () => {
        input._edited = true;
        updateEnterKeyHintForInput(input, td);
      });
      input.addEventListener('blur', () => {
        if (input !== activeInput) return;
        applyInlineEdit(input.value, false);
      });

      activeInput = input;
      try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
      updateEnterKeyHintForInput(input, td);

      if (preserveKeyboard && prevInput && prevCell) {
        prevCell.classList.remove('editing');
        delete prevCell.dataset.prev;
        if (prevInput.parentElement) prevInput.parentElement.removeChild(prevInput);
        if (prevDisplayText !== undefined) prevCell.textContent = prevDisplayText;
      }
    }

    function getNextScoreCell(currentTd) {
      const cells = Array.from(document.querySelectorAll('#scoreBody td.score-cell'));
      const idx = cells.indexOf(currentTd);
      if (idx !== -1) return cells[idx + 1] || null;
      return null;
    }

    function applyInlineEdit(val, advanceOnEnter) {
      if (!activeCell || !activeInput || isApplyingInline) return;
      isApplyingInline = true;

      const td = activeCell;
      const mode = activeMode;
      const hole = parseInt(td.getAttribute('data-hole')?.replace('H','') || '0', 10) || null;
      const player = td.getAttribute('data-player') || null;
      const trimmed = String(val ?? '').trim();
      const prevText = td.dataset.prev ?? '';
      const userTyped = !!activeInput._edited;

      let displayText = prevText;
      if (mode === 'score') {
        if (!userTyped && trimmed === '') {
          displayText = prevText;
        } else if (trimmed === '') {
          displayText = '';
          if (player && hole) localStorage.removeItem(LS.score(player, hole));
        } else {
          const n = Math.max(0, parseInt(trimmed, 10) || 0);
          displayText = String(n);
          if (player && hole) localStorage.setItem(LS.score(player, hole), displayText);
        }

        if (hole && lockPrimedHole === `H${hole}` && !userTyped) {
          if (isHoleEmpty(hole)) clearLockedHole();
          lockPrimedHole = null;
        }
      } else if (mode === 'par') {
        if (!userTyped && trimmed === '') {
          displayText = prevText || '3';
        } else if (trimmed === '') {
          displayText = '3';
          if (hole) localStorage.setItem(LS.par(hole), '3');
        } else {
          const n = Math.max(1, parseInt(trimmed, 10) || 3);
          displayText = String(n);
          if (hole) localStorage.setItem(LS.par(hole), displayText);
        }
      }

      let nextCell = null;
      if (advanceOnEnter && mode === 'score') {
        nextCell = getNextEmptyScoreCellInHole(td, displayText);
      }

      if (nextCell) {
        startInlineEdit(nextCell, 'score', { preserveKeyboard: true, prevDisplayText: displayText });
        updateAllTotals();
        if (sortByRankEnabled && mode === 'score' && hole) applySortByRankIfHoleComplete(hole, true);
        updateRanks();
        clearLockedHoleIfComplete(hole);
        isApplyingInline = false;
        return;
      }

      td.textContent = displayText;
      endInlineEdit(false);
      updateAllTotals();
      if (sortByRankEnabled && mode === 'score' && hole) applySortByRankIfHoleComplete(hole, true);
      updateRanks();
      clearLockedHoleIfComplete(hole);
      isApplyingInline = false;
    }

    function cancelInlineEdit() {
      if (!activeCell) return;
      if (activeMode === 'score') {
        const holeId = activeCell.getAttribute('data-hole');
        const h = parseInt(holeId?.replace('H','') || '0', 10);
        if (lockPrimedHole === holeId && h && isHoleEmpty(h)) clearLockedHole();
        lockPrimedHole = null;
      }
      if (activeCell.dataset.prev != null) activeCell.textContent = activeCell.dataset.prev;
      endInlineEdit(false);
    }

    function endInlineEdit(clearOnly) {
      if (activeCell) {
        activeCell.classList.remove('editing');
        delete activeCell.dataset.prev;
      }
      if (activeInput && activeInput.parentElement) activeInput.parentElement.removeChild(activeInput);
      activeCell = null; activeInput = null; activeMode = null;
      if (!clearOnly) fitRowsToViewport();
      syncHolePlaceholderState();
    }

    /* ---------------- Outside tap handling ---------------- */
    document.addEventListener('pointerdown', (e) => {
      if (activeInput && !activeInput.contains(e.target)) {
        const cellHit = e.target.closest('td.score-cell, td.par-cell');
        if (cellHit) {
          suppressNextCellEditClick = true;
          clearTimeout(suppressClickTimeout);
          suppressClickTimeout = setTimeout(() => { suppressNextCellEditClick = false; }, 300);
        }
        applyInlineEdit(activeInput.value, false);
      }
    }, true);

    document.addEventListener('click', (e) => {
      if (suppressNextCellEditClick && e.target.closest('td.score-cell, td.par-cell')) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        suppressNextCellEditClick = false;
      }
    }, true);

    /* ---------------- Round Management ---------------- */
    function showRoundManagement() {
      const pcSel = document.getElementById('playerCount');
      const themeSel = document.getElementById('themeColorSelect');
      const sortBtn = document.getElementById('sortByRankBtn');

      pcSel.value = String(playerCount);
      themeSel.value = themeColor;
      sortBtn.classList.toggle('active', sortByRankEnabled);

      const holes9 = document.getElementById('holes9');
      const holes18 = document.getElementById('holes18');
      if (holes9 && holes18) {
        holes9.checked = holesCount === 9;
        holes18.checked = holesCount === 18;
      }

      document.getElementById('roundManagementModal').style.display = 'block';
      applyThemeSelectColors();
      showOverlay();
      resetButtonState();
    }
    function closeRoundManagement() {
      resetButtonState();
      document.getElementById('roundManagementModal').style.display = 'none';
      hideOverlay();
    }

    function handleResetClick() {
      const btn = document.getElementById('resetButton');
      if (!resetConfirm) {
        resetConfirm = true;
        btn.textContent = 'Confirm';
        btn.setAttribute('data-confirm', 'true');
      } else {
        resetScores();
        resetButtonState();
      }
    }
    function resetButtonState() {
      resetConfirm = false;
      const btn = document.getElementById('resetButton');
      if (btn) { btn.textContent = 'Reset'; btn.removeAttribute('data-confirm'); }
    }

    function updatePlayerCount() {
      const val = parseInt(document.getElementById('playerCount').value, 10);
      const newCount = Math.min(8, Math.max(1, val));

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));
      const existing = headerRow.children.length - 2; // exclude hole + par

      if (newCount < existing) {
        for (let i = existing; i > newCount; i--) {
          const pid = `P${i}`;
          if (headerRow.lastElementChild) headerRow.removeChild(headerRow.lastElementChild);
          rows.forEach(tr => { if (tr.lastElementChild) tr.removeChild(tr.lastElementChild); });
          localStorage.removeItem(LS.name(pid));
          for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(pid, h));
        }
      }

      if (newCount > existing) {
        for (let i = existing + 1; i <= newCount; i++) {
          const pid = `P${i}`;
          const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && i <= 9 ? numberToKeycap(i) : pid);

          const th = document.createElement('th');
          th.setAttribute('data-player', pid);
          th.title = savedName;
          th.innerHTML = `
            <span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span>
            <div id="total${pid}"></div>
            <div class="to-par-line" id="toPar${pid}"></div>
          `;
          th.addEventListener('click', onHeaderClick);
          headerRow.appendChild(th);

          rows.forEach(tr => {
            const first = tr.firstElementChild;
            const isSummary = tr.classList.contains('summary-row');
            const td = document.createElement('td');
            if (!isSummary) {
              const holeNo = parseInt(tr.querySelector('.hole-cell')?.textContent || '0', 10);
              td.className = 'score-cell';
              td.setAttribute('data-player', pid);
              td.setAttribute('data-hole', `H${holeNo}`);
              td.addEventListener('click', () => startInlineEdit(td, 'score'));
              const saved = localStorage.getItem(LS.score(pid, holeNo));
              if (saved != null) td.textContent = saved;
            } else {
              const label = first?.textContent?.trim() || '';
              if (label === 'OUT') td.setAttribute('data-sum', `out-${pid}`);
              if (label === 'IN') td.setAttribute('data-sum', `in-${pid}`);
            }
            tr.appendChild(td);
          });
        }
      }

      playerCount = newCount;
      localStorage.setItem(LS.playerCount, String(playerCount));
      updateAllTotals();
      applySortByRankIfHoleComplete(null, true);
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
      attachDragListeners();
      closeRoundManagement();
    }

    function setHolesCount(val) {
      const n = parseInt(val, 10);
      holesCount = [9, 18].includes(n) ? n : 18;
      localStorage.setItem(LS.holesCount, String(holesCount));
      rebuildPreserving();
      updateRanks();
    }

    function toggleSortByRank() {
      sortByRankEnabled = !sortByRankEnabled;
      localStorage.setItem(LS.sort, String(sortByRankEnabled));
      const btn = document.getElementById('sortByRankBtn');
      if (btn) btn.classList.toggle('active', sortByRankEnabled);
      if (sortByRankEnabled) applySortByRankIfHoleComplete(null, false);
      updateRanks();
      attachDragListeners();
    }
    function setThemeColor(value) {
      themeColor = value || 'blue';
      localStorage.setItem(LS.themeColor, themeColor);
      applyThemeSelectColors();
      updateScoreColors();
      updateToParBadgeColors();
      updateRanks();
    }

    function resetScores() {
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(`P${p}`, h));
      }
      document.querySelectorAll('#scoreBody td.score-cell').forEach(td => td.textContent = '');
      clearLockedHole();
      updateAllTotals();
      updateRanks();
      closeRoundManagement();
    }

    /* ---------------- Player naming ---------------- */
    function openPlayerModalForHeader(pid) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      const currentName = header?.getAttribute('data-full') || header?.textContent || pid;
      window.currentPlayer = pid;
      if (emojiModeEnabled) openEmojiPlayerModal(currentName);
      else openTextPlayerModal(currentName);
    }

    function openTextPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">×</span>
        <input type="text" id="playerNameInput"
               value="${(currentName || '').toUpperCase()}"
               autocapitalize="characters"
               inputmode="text"
               autocomplete="off" autocorrect="off" spellcheck="false"
               style="text-transform: uppercase;">
        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      const input = document.getElementById('playerNameInput');
      input.addEventListener('focus', function () {
        try { this.select(); } catch (_) {}
        try { this.setSelectionRange(0, this.value.length); } catch (_) {}
      });
      let primed = false;
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => {
          try { input.select(); } catch (_) {}
          try { input.setSelectionRange(0, input.value.length); } catch (_) {}
        });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', e => e.preventDefault());
      input.addEventListener('contextmenu', e => e.preventDefault());
      input.addEventListener('input', function(){ this.value = this.value.toUpperCase(); });
      input.addEventListener('keydown', function(e){
        if (e.key === 'Enter') {
          e.preventDefault();
          const newName = (this.value || '').trim().toUpperCase();
          if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
          closePlayerNameModal();
        }
      });
      input.addEventListener('blur', function(){
        const newName = (this.value || '').trim().toUpperCase();
        if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
      });
    }

    function openEmojiPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      const favEmojis = [
        "🍔","🩰","🌹","🌰","🔔",
        "👑","🎣","🌻","🏏","🦈",
        "🤸🏼‍♀️","🎁","🕊️","🧶","🛠️",
        "🏃"
      ];
      const grid = favEmojis.map(e => `<button type="button" class="emoji-pick" data-emoji="${e}">${e}</button>`).join('');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">×</span>
        <input type="text" id="emojiNameInput" value="${currentName || ''}"
               inputmode="text" placeholder="Pick an emoji" enterkeyhint="done"
               autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">
        <div class="emoji-grid">${grid}</div>

        <div id="bulkEmojiActions" class="bulk-actions">
          <div class="row">
            <button type="button" id="bulkCancelBtn" class="light">Cancel</button>
            <button type="button" id="bulkApplyBtn">Select</button>
          </div>
        </div>

        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      let primed = false;
      const input = document.getElementById('emojiNameInput');
      input.addEventListener('focus', function () {
        try { this.select(); } catch (_) {}
        try { this.setSelectionRange(0, this.value.length); } catch (_) {}
      });
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => {
          try { input.select(); } catch (_) {}
          try { input.setSelectionRange(0, input.value.length); } catch (_) {}
        });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', (e) => e.preventDefault());
      input.addEventListener('contextmenu', (e) => e.preventDefault());

      let autoClosed = false;
      input.addEventListener('input', function () {
        const sanitized = extractEmojis(this.value);
        if (sanitized !== this.value) this.value = sanitized;
        if (sanitized && !autoClosed) {
          if (window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          autoClosed = true;
          closePlayerNameModal();
        }
      });
      input.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          const sanitized = extractEmojis((this.value || '').trim());
          if (sanitized && window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          closePlayerNameModal();
        }
      });

      attachEmojiGridInteractions();
    }

    function setEmojiMode(enabled, reopenForPlayerId = null) {
      emojiModeEnabled = !!enabled;
      localStorage.setItem(LS.emojiMode, emojiModeEnabled ? 'true' : 'false');
      syncDefaultNamesToMode();
      if (reopenForPlayerId) openPlayerModalForHeader(reopenForPlayerId);
      updateRanks();
    }
    function toggleEmojiMode() { setEmojiMode(!emojiModeEnabled); }

    function handleRemovePlayer(button) {
      if (button.dataset.state === 'initial') {
        button.textContent = 'Confirm';
        button.dataset.state = 'confirm';
      } else {
        if (window.currentPlayer) {
          removePlayer(window.currentPlayer);
          closePlayerNameModal();
        }
      }
    }

    function removePlayer(pid) {
      const removedIdx = parseInt(pid.replace('P',''), 10) - 1;
      if (playerCount <= 1) { alert('At least one player must remain.'); return false; }

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      if (headerRow.children[removedIdx + 2]) headerRow.removeChild(headerRow.children[removedIdx + 2]);
      rows.forEach(row => { if (row.children[removedIdx + 2]) row.removeChild(row.children[removedIdx + 2]); });

      for (let p = removedIdx + 2; p <= playerCount; p++) {
        const oldPid = `P${p}`, newPid = `P${p-1}`;
        const name = localStorage.getItem(LS.name(oldPid));
        if (name != null) {
          localStorage.setItem(LS.name(newPid), name);
          localStorage.removeItem(LS.name(oldPid));
        }
        for (let h = 1; h <= 18; h++) {
          const oldKey = LS.score(oldPid, h);
          const val = localStorage.getItem(oldKey);
          localStorage.removeItem(oldKey);
          if (val != null) localStorage.setItem(LS.score(newPid, h), val);
        }
      }
      const trailingPid = `P${playerCount}`;
      localStorage.removeItem(LS.name(trailingPid));
      for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(trailingPid, h));

      playerCount -= 1;
      localStorage.setItem(LS.playerCount, String(playerCount));
      const pcSel = document.getElementById('playerCount');
      if (pcSel) pcSel.value = String(playerCount);

      for (let i = removedIdx; i < playerCount; i++) {
        const newPid = `P${i+1}`;
        const th = headerRow.children[i + 2];
        if (th) {
          const nm = localStorage.getItem(LS.name(newPid)) || newPid;
          th.setAttribute('data-player', newPid);
          th.innerHTML = `
            <span class="player-name" data-full="${nm}" title="${nm}">${nm}</span>
            <div id="total${newPid}"></div>
            <div class="to-par-line" id="toPar${newPid}"></div>
          `;
          th.addEventListener('click', onHeaderClick);
        }

        rows.forEach(row => {
          const first = row.firstElementChild;
          const label = first?.textContent?.trim() || '';
          const cell = row.children[i + 2];
          if (!cell) return;

          if (row.classList.contains('summary-row')) {
            if (label === 'OUT') cell.setAttribute('data-sum', `out-${newPid}`);
            if (label === 'IN')  cell.setAttribute('data-sum', `in-${newPid}`);
          } else {
            cell.setAttribute('data-player', newPid);
          }
        });
      }

      fitRowsToViewport();
      updateAllTotals();
      applySortByRankIfHoleComplete(null, true);
      updateRanks();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
      attachDragListeners();
      return true;
    }

    function applyPlayerName(pid, newName) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
      if (!header) return;

      let nameEl = header.querySelector('.player-name');
      if (nameEl) {
        nameEl.textContent = newName;
        nameEl.setAttribute('data-full', newName);
        nameEl.setAttribute('title', newName);
      } else {
        const totalDiv = header.querySelector(`div[id^="total"]`);
        const toParDiv = header.querySelector('.to-par-line');
        const totalHTML = totalDiv ? totalDiv.outerHTML : `<div id="total${pid}"></div>`;
        const toParHTML = toParDiv ? toParDiv.outerHTML : `<div class="to-par-line" id="toPar${pid}"></div>`;
        header.innerHTML = `<span class="player-name" data-full="${newName}" title="${newName}">${newName}</span>${totalHTML}${toParHTML}`;
      }

      header.setAttribute('data-player', pid);
      localStorage.setItem(LS.name(pid), newName);
      clipPlayerNamesToCell();
      updatePlaceholdersForPlayer(pid);
      updateRanks();
    }

    function closePlayerNameModal() {
      const modal = document.getElementById('playerNameModal');
      const btn = modal.querySelector('button[onclick^="handleRemovePlayer"]');
      if (btn) { btn.textContent = 'Remove'; btn.dataset.state = 'initial'; }
      modal.style.display = 'none';
      hideOverlay();
    }

    function attachEmojiGridInteractions() {
      const modal = document.getElementById('playerNameModal');
      const buttons = Array.from(modal.querySelectorAll('.emoji-pick'));
      const bulkBar = modal.querySelector('#bulkEmojiActions');
      const seg = modal.querySelector('.segmented-control');
      const emojiInput = modal.querySelector('#emojiNameInput');
      let bulkEmojiMode = false;
      let bulkEmojiSelection = [];
      const bulkMaxPlayers = 8;

      const enterBulk = () => {
        if (bulkEmojiMode) return;
        bulkEmojiMode = true; bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'block';
        if (seg) seg.style.display = 'none';
        if (emojiInput) emojiInput.style.display = 'none';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.add('bulk-mode');
      };
      const exitBulk = () => {
        bulkEmojiMode = false; bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'none';
        if (seg) seg.style.display = '';
        if (emojiInput) emojiInput.style.display = '';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.remove('bulk-mode');
      };
      const renumber = () => {
        buttons.forEach(b => { if (b.classList.contains('selected')) b.setAttribute('data-order', ''); });
        bulkEmojiSelection.forEach((emoji, i) => {
          const b = buttons.find(btn => btn.getAttribute('data-emoji') === emoji);
          if (b) b.setAttribute('data-order', String(i + 1));
        });
      };
      const toggleSel = (btn) => {
        const emoji = btn.getAttribute('data-emoji');
        const idx = bulkEmojiSelection.indexOf(emoji);
        if (idx !== -1) { bulkEmojiSelection.splice(idx, 1); btn.classList.remove('selected'); btn.removeAttribute('data-order'); }
        else {
          if (bulkEmojiSelection.length >= bulkMaxPlayers) return;
          bulkEmojiSelection.push(emoji); btn.classList.add('selected');
        }
        renumber();
      };
      const applyBulk = (selected) => {
        const targetCount = Math.min(bulkMaxPlayers, selected.length);
        if (targetCount < 1) return;
        emojiModeEnabled = true;
        localStorage.setItem(LS.emojiMode, 'true');

        const pcSel = document.getElementById('playerCount');
        pcSel.value = String(targetCount);
        updatePlayerCount();

        for (let i = 1; i <= targetCount; i++) applyPlayerName(`P${i}`, selected[i - 1]);
        exitBulk();
        closePlayerNameModal();
      };

      const cancelBtn = modal.querySelector('#bulkCancelBtn');
      const applyBtn = modal.querySelector('#bulkApplyBtn');
      if (cancelBtn) cancelBtn.addEventListener('click', () => exitBulk());
      if (applyBtn) applyBtn.addEventListener('click', () => { if (bulkEmojiSelection.length > 0) applyBulk(bulkEmojiSelection); });

      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (bulkEmojiMode) toggleSel(btn);
          else {
            const emoji = btn.getAttribute('data-emoji');
            if (emoji && window.currentPlayer) {
              applyPlayerName(window.currentPlayer, emoji);
              closePlayerNameModal();
            }
          }
        });
        let pressTimer = null;
        const start = () => {
          if (bulkEmojiMode) return;
          clearTimeout(pressTimer);
          pressTimer = setTimeout(() => enterBulk(), 500);
        };
        const cancel = () => { clearTimeout(pressTimer); pressTimer = null; }
        btn.addEventListener('pointerdown', start);
        btn.addEventListener('pointerup', cancel);
        btn.addEventListener('pointerleave', cancel);
        btn.addEventListener('touchstart', start, { passive: true });
        btn.addEventListener('touchend', cancel);
        btn.addEventListener('touchcancel', cancel);
        btn.addEventListener('mousedown', start);
        btn.addEventListener('mouseup', cancel);
        btn.addEventListener('mouseleave', cancel);
      });
    }

    function syncDefaultNamesToMode() {
      for (let i = 1; i <= playerCount; i++) {
        const pid = `P${i}`;
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (!header) continue;
        const displayed = (header.getAttribute('data-full') || header.textContent || '').trim();
        const stored = localStorage.getItem(LS.name(pid));
        const current = stored != null ? stored : displayed;
        let newName = current;

        if (emojiModeEnabled) {
          const m = /^P(\d{1,2})$/i.exec(current);
          if (m) {
            const n = parseInt(m[1], 10);
            if (n >= 0 && n <= 9) newName = numberToKeycap(n);
          } else if (stored == null && i <= 9) {
            newName = numberToKeycap(i);
          }
        } else {
          const n = keycapToNumber(current);
          if (n !== null) newName = `P${n}`;
        }

        if (newName !== current) {
          applyPlayerName(pid, newName);
        } else if (stored == null) {
          localStorage.setItem(LS.name(pid), current);
        }
      }
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    /* ---------------- Totals / ranks / layout ---------------- */
    function fitRowsToViewport() {
      const rowsCount = document.querySelectorAll('#scoreBody tr').length;
      if (rowsCount <= 0) return;

      const tableEl = document.getElementById('scoreTable');
      const thead = tableEl ? tableEl.querySelector('thead') : null;
      const headerH = thead ? Math.round(thead.getBoundingClientRect().height) : 0;
      const containerH = tableEl ? tableEl.clientHeight : Math.max(window.innerHeight, document.documentElement.clientHeight || 0);

      // Account for 1px bottom border per body row
      const approxBorders = rowsCount;

      const avail = Math.max(1, containerH - headerH - approxBorders);
      const rowH = Math.max(20, Math.floor(avail / rowsCount));
      document.documentElement.style.setProperty('--row-h', rowH + 'px');
    }

    function getPar(h) {
      const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
      const v = parseInt(cell?.textContent || '3', 10);
      return Number.isFinite(v) ? v : 3;
    }
    function getScore(player, h) {
      const td = document.querySelector(`td.score-cell[data-player="${player}"][data-hole="H${h}"]`);
      const v = parseInt(td?.textContent || '', 10);
      return Number.isFinite(v) ? v : null;
    }
    function hasAnyEntry() {
      return Array.from(document.querySelectorAll('.score-cell')).some(td => td.textContent.trim() !== '');
    }

    function updateScoreColors() {
      const { h: H, s: S } = getThemeHS(themeColor);
      const themeText = (l = 40) => `hsl(${H}, ${S}%, ${l}%)`;
      const grey = '#808080';
      document.querySelectorAll('#scoreBody td.score-cell').forEach(td => {
        const txt = td.textContent.trim();
        if (!txt) { td.style.color = ''; return; }
        const score = parseInt(txt, 10);
        if (!Number.isFinite(score)) { td.style.color = ''; return; }
        const holeAttr = td.getAttribute('data-hole') || '';
        const hole = parseInt(holeAttr.replace('H',''), 10);
        const par = Number.isFinite(hole) ? getPar(hole) : 3;
        if (score < par) td.style.color = themeText(40);
        else if (score > par) td.style.color = grey;
        else td.style.color = '#000000';
      });
    }

    function updateAllTotals() {
      const outRange = [...Array(Math.min(9, holesCount)).keys()].map(i => i + 1);
      const inRange  = (holesCount > 9) ? [...Array(holesCount - 9).keys()].map(i => i + 10) : [];

      const parOut = outRange.reduce((s, h) => s + getPar(h), 0);
      const parIn  = inRange.reduce((s, h) => s + getPar(h), 0);

      const setSumCell = (key, val) => {
        const el = document.querySelector(`[data-sum="${key}"]`);
        if (el) el.textContent = String(val);
      };
      setSumCell('out-par', parOut);
      if (holesCount > 9) setSumCell('in-par', parIn);

      const any = hasAnyEntry();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const sumOut = outRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const sumIn  = inRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const played = [...outRange, ...inRange];
        let playedPar = 0, playedStrokes = 0, hasScore = false;
        for (const h of played) {
          const sc = getScore(pid, h);
          if (sc != null) { hasScore = true; playedStrokes += sc; playedPar += getPar(h); }
        }
        setSumCell(`out-${pid}`, sumOut);
        if (holesCount > 9) setSumCell(`in-${pid}`, sumIn);

        const totalDiv = document.getElementById(`total${pid}`);
        const toParDiv = document.getElementById(`toPar${pid}`);
        if (!totalDiv || !toParDiv) continue;

        if (hasScore) {
          const toPar = (playedPar === 0) ? 0 : (playedStrokes - playedPar);
          const tp = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);

          totalDiv.innerHTML = `<span class="strokes">${playedStrokes}</span>`;
          toParDiv.innerHTML = `<span class="to-par-badge" data-value="${toPar}">${tp}</span>`;
        } else {
          if (any) {
            totalDiv.innerHTML = `<span class="strokes">0</span>`;
            toParDiv.innerHTML = `<span class="to-par-badge" data-value="0">E</span>`;
          } else {
            totalDiv.innerHTML = '';
            toParDiv.innerHTML = '';
          }
        }
      }

      updateScoreColors();
      updateToParBadgeColors();
    }

    function updateToParBadgeColors() {
      const { h: H, s: S } = getThemeHS(themeColor);
      const themeText = `hsl(${H}, ${S}%, 40%)`;
      const grey = '#808080';

      document.querySelectorAll('#scoreTable thead th .to-par-badge').forEach(badge => {
        const raw = badge.getAttribute('data-value');
        const val = raw != null ? parseInt(raw, 10) : NaN;

        if (!Number.isFinite(val) || val === 0) {
          badge.style.color = '#000000';
        } else if (val > 0) {
          badge.style.color = grey;
        } else {
          badge.style.color = themeText;
        }
      });
    }

    function updateRanks() {
      const table = document.getElementById('scoreTable');
      const headers = Array.from(table.querySelectorAll('thead th')).slice(2);
      const count = headers.length;

      if (count >= 7) table.classList.add('small-scores');
      else table.classList.remove('small-scores');

      headers.forEach(h => {
        h.style.background = '';
        h.querySelectorAll('small').forEach(s => s.remove());
      });

      const any = hasAnyEntry();
      if (!any) { clipPlayerNamesToCell(); return; }

      const totals = headers.map(h => {
        const pid = h.getAttribute('data-player');
        let sum = 0, hasScore = false;
        for (let i = 1; i <= holesCount; i++) {
          const sc = getScore(pid, i);
          if (sc != null) { hasScore = true; sum += sc; }
        }
        const rankValue = hasScore ? sum : Number.POSITIVE_INFINITY;
        return { h, pid, sum, hasScore, rankValue };
      });

      const sorted = [...totals].sort((a, b) => a.rankValue - b.rankValue);

      const groups = [];
      for (const item of sorted) {
        const last = groups[groups.length - 1];
        if (!last || last.score !== item.rankValue) groups.push({ score: item.rankValue, members: [item.pid] });
        else last.members.push(item.pid);
      }

      const { h: H, s: S } = getThemeHS(themeColor);
      const Lmax = 82, minRange = 18, maxRange = 44;
      const effective = groups.length;
      const normalized = Math.min(1, Math.max(0, (effective - 1) / (8 - 1)));
      const range = Math.round(minRange + (maxRange - minRange) * normalized);
      const Lmin = Math.max(28, Lmax - range);

      groups.forEach((group, g) => {
        const ratio = (effective === 1) ? 0 : g / (effective - 1);
        const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
        const Ltop = Math.max(18, L - 10);
        const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
        group.members.forEach(pid => {
          const th = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
          if (th) th.style.background = gradient;
        });
      });

      clipPlayerNamesToCell();
    }

    function ordinalSuffixOf(i) {
      const j = i % 10, k = i % 100;
      if (j === 1 && k !== 11) return i + "st";
      if (j === 2 && k !== 12) return i + "nd";
      if (j === 3 && k !== 13) return i + "rd";
      return i + "th";
    }

    function clipPlayerNamesToCell() {
      const seg = (typeof Intl !== 'undefined' && Intl.Segmenter)
        ? new Intl.Segmenter('en', { granularity: 'grapheme' })
        : null;
      const els = document.querySelectorAll('#scoreTable thead th .player-name');
      els.forEach(el => {
        const full = el.getAttribute('data-full') ?? el.textContent;
        el.setAttribute('data-full', full);
        el.textContent = full;

        if (el.scrollWidth > el.clientWidth) {
          const clusters = seg ? Array.from(seg.segment(full), s => s.segment) : Array.from(full);
          let low = 0, high = clusters.length, best = 0;
          while (low <= high) {
            const mid = Math.floor((low + high) / 2);
            el.textContent = clusters.slice(0, mid).join('');
            if (el.scrollWidth <= el.clientWidth) { best = mid; low = mid + 1; }
            else high = mid - 1;
          }
          el.textContent = clusters.slice(0, best).join('');
        }

        const th = el.closest('th[data-player]');
        const pid = th?.getAttribute('data-player');
        if (pid) updatePlaceholdersForPlayer(pid);
      });
    }

    /* ---------------- Resort gating ---------------- */
    function isHoleComplete(h) {
      if (!h || h < 1 || h > holesCount) return false;
      for (let p = 1; p <= playerCount; p++) {
        if (getScore(`P${p}`, h) == null) return false;
      }
      return true;
    }
    function isAnyHoleComplete() {
      for (let h = 1; h <= holesCount; h++) {
        if (isHoleComplete(h)) return true;
      }
      return false;
    }
    function applySortByRankIfHoleComplete(targetHole = null, silent = true) {
      if (!sortByRankEnabled) return;
      if (targetHole != null) {
        if (!isHoleComplete(targetHole)) return;
      } else {
        if (!isAnyHoleComplete()) return;
      }
      applySortByRank(silent);
    }

    /* ---------------- Sort by rank ---------------- */
    function applySortByRank(silent = false) {
      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));
      const headers = Array.from(headerRow.children).slice(2);
      if (headers.length <= 1 || !hasAnyEntry()) return;

      const players = headers.map((th, idx) => {
        const pid = th.getAttribute('data-player');
        let sum = 0, hasScore = false;
        for (let h = 1; h <= holesCount; h++) {
          const sc = getScore(pid, h);
          if (sc != null) { hasScore = true; sum += sc; }
        }
        const rankValue = hasScore ? sum : Number.POSITIVE_INFINITY;
        return { idx, pid, rankValue };
      });

      const order = [...players].sort((a,b) => a.rankValue - b.rankValue || a.idx - b.idx).map(p => p.idx);
      if (order.every((v, i) => v === i)) { if (!silent) updateRanks(); return; }

      const playerData = [];
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        const name = localStorage.getItem(LS.name(pid)) ||
          (document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`)?.textContent?.trim() || pid);
        const scores = {};
        for (let h = 1; h <= holesCount; h++) {
          const v = localStorage.getItem(LS.score(pid, h));
          scores[h] = (v != null) ? v : null;
        }
        playerData.push({ name, scores });
      }

      const fixed = Array.from(headerRow.children).slice(0,2);
      const moving = Array.from(headerRow.children).slice(2);
      headerRow.innerHTML = '';
      fixed.forEach(n => headerRow.appendChild(n));
      order.forEach(i => headerRow.appendChild(moving[i]));

      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixed2 = cells.slice(0,2);
        const movingCells = cells.slice(2);
        tr.innerHTML = '';
        fixed2.forEach(c => tr.appendChild(c));
        order.forEach(i => tr.appendChild(movingCells[i]));
      });

      const newData = order.map(i => playerData[i]);

      for (let i = 0; i < playerCount; i++) {
        const newPid = `P${i+1}`;
        const th = headerRow.children[i + 2];

        const strokesText = th.querySelector('div[id^="total"]')?.textContent || '';
        th.setAttribute('data-player', newPid);
        th.innerHTML = `
          <span class="player-name" data-full="${newData[i].name}" title="${newData[i].name}">${newData[i].name}</span>
          <div id="total${newPid}">${strokesText}</div>
          <div class="to-par-line" id="toPar${newPid}"></div>
        `;
        th.addEventListener('click', onHeaderClick);

        rows.forEach(row => {
          const first = row.firstElementChild;
          const label = first?.textContent?.trim() || '';
          const cell = row.children[i + 2];
          if (!cell) return;
          if (!row.classList.contains('summary-row')) {
            cell.setAttribute('data-player', newPid);
          } else {
            if (label === 'OUT') cell.setAttribute('data-sum', `out-${newPid}`);
            if (label === 'IN')  cell.setAttribute('data-sum', `in-${newPid}`);
          }
        });
      }

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        localStorage.removeItem(LS.name(pid));
        for (let h = 1; h <= holesCount; h++) localStorage.removeItem(LS.score(pid, h));
      }
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        localStorage.setItem(LS.name(pid), newData[i].name);
        for (let h = 1; h <= holesCount; h++) {
          const v = newData[i].scores[h];
          if (v != null) localStorage.setItem(LS.score(pid, h), v);
        }
      }

      attachDragListeners();
      updateAllTotals();
      if (!silent) updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    /* ---------------- Rebuild preserving ---------------- */
    function rebuildPreserving() {
      const names = {};
      for (let p = 1; p <= 8; p++) {
        const k = LS.name(`P${p}`);
        const v = localStorage.getItem(k);
        if (v != null) names[`P${p}`] = v;
      }
      const pars = {};
      for (let h = 1; h <= 18; h++) {
        const k = LS.par(h);
               const v = localStorage.getItem(k);
        if (v != null) pars[h] = v;
      }
      const scores = {};
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) {
          const k = LS.score(`P${p}`, h);
          const v = localStorage.getItem(k);
          if (v != null) scores[`${p}-${h}`] = v;
        }
      }

      buildTable();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const nm = names[pid] || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        localStorage.setItem(LS.name(pid), nm);
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (header) {
          header.textContent = nm;
          header.setAttribute('data-full', nm);
          header.setAttribute('title', nm);
        }
        const th = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
        if (th) th.addEventListener('click', onHeaderClick);
      }
      for (let h = 1; h <= holesCount; h++) {
        const v = pars[h] ?? '3';
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) {
          cell.textContent = v;
          localStorage.setItem(LS.par(h), v);
        }
      }
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const key = `${p}-${h}`;
          const v = scores[key];
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && v != null) {
            td.textContent = v;
            localStorage.setItem(LS.score(`P${p}`, h), v);
          }
        }
      }

      updateAllPlaceholders();
      updateAllTotals();
      applySortByRankIfHoleComplete(null, true);
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      attachDragListeners();
    }

    /* ---------------- Drag & Drop ---------------- */
    function attachDragListeners() {
      const headers = document.querySelectorAll('#scoreTable thead th[data-player]');
      headers.forEach((header, index) => {
        header.draggable = true;

        header.removeEventListener('dragstart', header._dragStartHandler);
        header.removeEventListener('dragover', header._dragOverHandler);
        header.removeEventListener('drop', header._dropHandler);
        header.removeEventListener('dragend', header._dragEndHandler);

        header._dragStartHandler = (event) => handleDragStart(event, index);
        header._dragOverHandler = (event) => handleDragOver(event);
        header._dropHandler = (event) => handleDrop(event, index);
        header._dragEndHandler = (event) => handleDragEnd(event);

        header.addEventListener('dragstart', header._dragStartHandler);
        header.addEventListener('dragover', header._dragOverHandler);
        header.addEventListener('drop', header._dropHandler);
        header.addEventListener('dragend', header._dragEndHandler);
      });
    }

    function handleDragStart(event, index) {
      draggedIndex = index;
      event.currentTarget.classList.add('dragging');
      if (event.dataTransfer) {
        event.dataTransfer.effectAllowed = 'move';
        try { event.dataTransfer.setData('text/plain', ''); } catch (_) {}
      }
    }

    function handleDragOver(event) {
      event.preventDefault();
      if (event.dataTransfer) event.dataTransfer.dropEffect = 'move';
    }

    function handleDrop(event, dropIndex) {
      event.preventDefault();

      if (sortByRankEnabled) {
        draggedIndex = -1;
        return;
      }

      if (draggedIndex === -1 || draggedIndex === dropIndex) {
        draggedIndex = -1;
        return;
      }

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      const playerData = [];
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        const name = localStorage.getItem(LS.name(pid)) ||
          (document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`)?.textContent?.trim() || pid);
        const scores = {};
        for (let h = 1; h <= holesCount; h++) {
          const v = localStorage.getItem(LS.score(pid, h));
          scores[h] = (v != null) ? v : null;
        }
        playerData.push({ name, scores });
      }

      const fixed = Array.from(headerRow.children).slice(0,2);
      const playerHeaders = Array.from(headerRow.children).slice(2);
      const [draggedHeader] = playerHeaders.splice(draggedIndex, 1);
      playerHeaders.splice(dropIndex, 0, draggedHeader);
      headerRow.innerHTML = '';
      fixed.forEach(h => headerRow.appendChild(h));
      playerHeaders.forEach(h => headerRow.appendChild(h));

      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixedCells = cells.slice(0, 2);
        const playerCells = cells.slice(2);
        const [draggedCell] = playerCells.splice(draggedIndex, 1);
        playerCells.splice(dropIndex, 0, draggedCell);
        tr.innerHTML = '';
        fixedCells.forEach(c => tr.appendChild(c));
        playerCells.forEach(c => tr.appendChild(c));
      });

      const [draggedData] = playerData.splice(draggedIndex, 1);
      playerData.splice(dropIndex, 0, draggedData);

      for (let i = 0; i < playerCount; i++) {
        const newPid = `P${i+1}`;
        const th = headerRow.children[i + 2];
        const strokesText = th.querySelector('div[id^="total"]')?.textContent || '';

        th.setAttribute('data-player', newPid);
        const nm = playerData[i].name;
        th.innerHTML = `
          <span class="player-name" data-full="${nm}" title="${nm}">${nm}</span>
          <div id="total${newPid}">${strokesText}</div>
          <div class="to-par-line" id="toPar${newPid}"></div>
        `;
        th.addEventListener('click', onHeaderClick);

        rows.forEach(row => {
          const first = row.firstElementChild;
          const label = first?.textContent?.trim() || '';
          const cell = row.children[i + 2];
          if (!cell) return;
          if (!row.classList.contains('summary-row')) {
            cell.setAttribute('data-player', newPid);
          } else {
            if (label === 'OUT') cell.setAttribute('data-sum', `out-${newPid}`);
            if (label === 'IN')  cell.setAttribute('data-sum', `in-${newPid}`);
          }
        });
      }

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        localStorage.removeItem(LS.name(pid));
        for (let h = 1; h <= holesCount; h++) localStorage.removeItem(LS.score(pid, h));
      }
      for (let i = 0; i < playerCount; i++) {
        const pid = `P${i+1}`;
        localStorage.setItem(LS.name(pid), playerData[i].name);
        for (let h = 1; h <= holesCount; h++) {
          const v = playerData[i].scores[h];
          if (v != null) localStorage.setItem(LS.score(pid, h), v);
        }
      }

      draggedIndex = -1;
      attachDragListeners();
      updateAllTotals();
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      updateAllPlaceholders();
    }

    function handleDragEnd(event) {
      event.currentTarget.classList.remove('dragging');
      draggedIndex = -1;
    }

    /* ---------------- Pars popup ---------------- */
    function showParResetPopup() {
      const modal = document.getElementById('popupModal');
      const title = document.getElementById('popupTitle');
      const options = document.getElementById('popupOptions');

      title.textContent = 'Par';
      options.innerHTML = `
        <button id="resetParsBtn"
                style="width: 100%; height: auto; padding: 10px 20px; font-size: 24px; grid-column: 1 / -1;">
          Reset Pars
        </button>
      `;

      document.getElementById('resetParsBtn').onclick = () => {
        resetAllParsToThree();
        closePopupModal();
      };

      modal.style.display = 'block';
      showOverlay();
    }

    function resetAllParsToThree() {
      for (let h = 1; h <= holesCount; h++) {
        localStorage.setItem(LS.par(h), '3');
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = '3';
      }
      updateAllTotals();
    }

    function closePopupModal() {
      const modal = document.getElementById('popupModal');
      modal.style.display = 'none';
      hideOverlay();
    }

    /* ---------------- Overlay ---------------- */
    function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
    function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }
    document.getElementById('overlay').addEventListener('click', () => {
      closeRoundManagement();
      closePlayerNameModal();
      closePopupModal();
      if (activeInput) {
        applyInlineEdit(activeInput.value, false);
      } else {
        endInlineEdit(true);
      }
    });
  </script>
</body>
</html>