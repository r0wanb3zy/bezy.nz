<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disc Golf Scorecard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">

  <style>
    /* Base (match reference app) */
    html, body { height: 100%; margin: 0; }
    body {
      font-family: 'Economica', sans-serif;
      font-size: 22px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      min-height: 100vh;
      background-size: cover;
    }

    :root {
      --hole-w: 30px;
      --par-w: 30px;
      --row-h: 34px; /* JS will set this so all rows fit exactly in the viewport */
    }

    /* Table base */
    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 20px;
      table-layout: fixed;
      font-family: 'Economica', sans-serif;
    }
    table, table th, table td { font-weight: bold; }

    /* Score table shell (match reference) */
    #scoreTable {
      height: 100vh;   /* legacy fallback */
      height: 100dvh;  /* modern browsers use dynamic viewport height */
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
    }

    /* Orientation-specific scrolling (match reference) */
    @media screen and (orientation: portrait) {
      html, body { overflow: hidden; touch-action: none; }
      #scoreTable { overflow-y: hidden; }
    }
    @media screen and (orientation: landscape) {
      html, body { overflow: auto; touch-action: auto; }
      #scoreTable { overflow-y: auto; }
    }

    /* Header row */
    table th {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white;
      border-bottom: none;
    }
    #scoreTable thead th {
      height: 80px;
      font-size: 22px;
    }

    /* Top-left settings cell: solid dark bg + divider to Par */
    #scoreTable thead th:first-child {
      background: #3b3b3b;
      color: #fff;
      border-right: 1px solid #666; /* divider between settings and Par */
      border-bottom: 1px solid #666;
    }

    /* Table cells (light borders for content like reference) */
    table th, table td {
      text-align: center;
      padding: 5px;
      word-wrap: break-word;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      vertical-align: middle;
      border-bottom: 1px solid rgba(200, 200, 200, 0.3);
    }
    table td { border-right: 1px solid rgba(200, 200, 200, 0.3); }
    table td:last-child { border-right: none; }
    table tr:last-child td { border-bottom: none; }

    /* First two columns: sticky + darker borders */
    th.hole-header, td.hole-cell {
      position: sticky; left: 0; z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--hole-w); min-width: var(--hole-w); max-width: var(--hole-w);
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
      cursor: default;
    }
    /* Make the entire top-left settings header clickable */
    th.hole-header { cursor: pointer; }

    th.par-header, td.par-cell {
      position: sticky;
      left: calc(var(--hole-w) + 1px);
      z-index: 2;
      background: #3b3b3b; color: #fff; /* solid, no gradient */
      width: var(--par-w); min-width: var(--par-w); max-width: var(--par-w);
      border-right: 1px solid #666;
      border-bottom: 1px solid #666;
    }
    /* Remove right border on TOP Par header only */
    th.par-header { border-right: none; }

    /* Make all body rows rock-solid height */
    #scoreTable tbody td, #scoreTable tbody th {
      height: var(--row-h);
      line-height: var(--row-h);
      padding-top: 0;
      padding-bottom: 0;
      font-variant-numeric: tabular-nums;
    }

    /* Summary rows (OUT/IN) darker like reference */
    .summary-row td {
      background: #3b3b3b; color: white;
      border-bottom: 1px solid #666; border-right: 1px solid #666;
    }
    .summary-row td:last-child { border-right: none; }

    /* Header player content — matched to Yahtzee spacing */
    #scoreTable thead th .player-name {
      display: block;
      max-width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: clip;
      text-align: center;
      line-height: normal; /* match Yahtzee */
      margin: 0;
    }
    #scoreTable thead th div[id^="total"] {
      font-size: 22px; /* match Yahtzee */
      color: rgba(255, 255, 255, 0.9);
      margin: 0;
    }
    #scoreTable thead th small {
      font-size: 16px; /* match Yahtzee */
      color: rgba(255, 255, 255, 0.8);
    }
    #scoreTable.small-scores thead th .player-name {
      font-size: 18px; line-height: 1.1;
    }

    /* Gear icon inherits pointer from header */
    .gear {
      font-size: 20px; cursor: inherit; color: #fff; background: none; border: none;
    }

    /* Inline cell editing (no popup for scores) */
    #scoreBody td.editing {
      box-shadow: inset 0 0 0 2px #000;
    }
    #scoreBody td.score-cell.editing {
      position: relative;
    }
    .inline-number {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      border: none;
      outline: none;
      background: transparent;
      text-align: center;
      font: inherit;
      color: inherit;
      line-height: var(--row-h);
      padding: 0;
      margin: 0;
      -moz-appearance: textfield;
      appearance: textfield;
    }
    .inline-number::-webkit-outer-spin-button,
    .inline-number::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

    /* Reference popup styling (kept for parity) */
    #popupModal {
      display: none;
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 12px 20px;
      z-index: 1000; text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
      font-family: 'Economica', sans-serif;
    }
    #popupModal h2 { margin: 15px 0; padding: 0; }
    #popupModal button {
      font-size: 24px; padding: 10px 20px; margin: 2px; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s;
    }
    #popupOptions {
      display: grid; grid-template-columns: repeat(5, 40px); gap: 5px; justify-content: center;
      padding: 10px 0; box-sizing: border-box;
    }
    #popupOptions .popup-spacer {
      width: 40px; height: 40px; visibility: hidden; pointer-events: none;
    }
    #popupOptions button {
      width: 40px; height: 40px; font-size: 24px; padding: 0; margin: 0; box-sizing: border-box;
      cursor: pointer; font-family: 'Economica', sans-serif, Arial; display: flex; justify-content: center; align-items: center;
      text-align: center; overflow: hidden; white-space: nowrap;
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s ease;
      -webkit-appearance: none; appearance: none; line-height: 1; outline: none;
    }

    /* Close button (X) */
    .close-btn {
      position: absolute; top: 0px; right: 0px;
      font-size: 48px; color: #000000; cursor: pointer; background: none; border: none;
      padding: 0; line-height: 1; width: 40px; height: 40px; text-align: center; transition: color 0.2s ease;
    }

    /* Round management modal */
    #roundManagementModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px; text-align: center;
    }
    #roundManagementModal select {
      font-size: 24px; padding: 10px; margin: 5px 0;
      font-family: 'Economica', sans-serif; border: 1px solid #333; border-radius: 6px;
      background: #f8f9fa; width: 100%; box-sizing: border-box;
      text-align: center; text-align-last: center; -moz-text-align-last: center;
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; padding-right: 12px;
    }
    #roundManagementModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #roundManagementModal button#sortByRankBtn {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }
    #roundManagementModal button#sortByRankBtn.active {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #ffffff; border: 1px solid #262626;
    }
    #roundManagementModal button#resetButton[data-confirm="true"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }

    /* Player Name Modal */
    #playerNameModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; text-align: center; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
    }
    #playerNameModal h2 { margin: 15px 0; padding: 0; }
    #playerNameModal input[type="text"] {
      font-size: 24px; padding: 10px; width: 100%; box-sizing: border-box; margin: 5px 0; text-align: center;
      font-family: 'Economica', sans-serif; border: 1px solid #d0d7de; border-radius: 6px; background: #ffffff;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); transition: border-color 0.2s ease;
    }
    #playerNameModal input[type="text"]:focus { outline: none; border: 1px solid #262626; }
    #playerNameModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #playerNameModal button[data-state="confirm"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }
    #playerNameModal button.light {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }

    /* Segmented control */
    .segmented-control {
      display: flex; width: 100%; box-sizing: border-box; margin: 5px 0;
      background: #f8f9fa; border-radius: 6px; overflow: hidden; border: 1px solid #262626;
      -webkit-background-clip: padding-box; background-clip: padding-box;
    }
    .segmented-control input[type="radio"] { display: none; }
    .segmented-control label {
      flex: 1 1 0; padding: 10px 0; text-align: center; font-size: 24px; font-family: 'Economica', sans-serif;
      cursor: pointer; user-select: none; background: #f8f9fa; margin: 0;
    }
    .segmented-control input[type="radio"]:checked + label {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff;
    }

    /* Emoji grid (reference) */
    .emoji-grid {
      --emoji-gap: 8px;
      display: grid; grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: var(--emoji-gap); padding: 0; margin: 5px 0; width: 100%; box-sizing: border-box;
      user-select: none; -webkit-user-select: none;
    }
    #playerNameModal .emoji-grid .emoji-pick {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: #ffffff; border: none; border-radius: 6px;
      font-family: 'Economica', sans-serif; font-size: 22px;
      display: grid; place-items: center;
      width: 100%; aspect-ratio: 1 / 1; padding: 0; margin: 0;
      line-height: 1; cursor: pointer;
      transition: transform 0.05s ease, filter 0.1s ease;
      box-sizing: border-box; position: relative;
      -webkit-appearance: none; appearance: none; outline: none;
    }
    #playerNameModal .emoji-grid .emoji-pick:active { transform: scale(0.95); filter: brightness(1.05); }
    .emoji-grid .emoji-pick.selected { box-shadow: 0 0 0 2px #262626 inset; }
    .emoji-grid .emoji-pick.selected::before {
      content: ""; position: absolute; inset: 0; background: rgba(0, 0, 0, 0.35);
      border-radius: 6px; pointer-events: none; z-index: 1;
    }
    .emoji-grid .emoji-pick.selected::after {
      content: attr(data-order); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%);
      font-size: 28px; font-weight: 700; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 3px rgba(0,0,0,0.7);
      pointer-events: none; z-index: 2;
    }
    .bulk-actions { display: none; margin: 5px 0 0 0; width: 100%; }
    .bulk-actions .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: center; width: 100%; }

    /* Overlay */
    #overlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999; cursor: pointer;
    }

    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <!-- Score Table -->
  <table id="scoreTable">
    <thead>
      <tr id="playerRow">
        <th class="hole-header" onclick="showRoundManagement()">
          <button class="gear" title="Round settings">☰</button>
        </th>
        <th class="par-header">Par</th>
        <!-- Player headers injected -->
      </tr>
    </thead>
    <tbody id="scoreBody"></tbody>
  </table>

  <!-- Popup kept for parity (exact reference styling) -->
  <div id="popupModal">
    <h2 id="popupTitle">Select</h2>
    <span class="close-btn" onclick="document.getElementById('popupModal').style.display='none'">×</span>
    <div id="popupOptions"></div>
  </div>

  <!-- Round Management -->
  <div id="roundManagementModal">
    <h2>Round</h2>
    <span class="close-btn" onclick="closeRoundManagement()">×</span>

    <select id="playerCount" onchange="updatePlayerCount()">
      <option value="1">1 Players</option>
      <option value="2">2 Players</option>
      <option value="3">3 Players</option>
      <option value="4">4 Players</option>
      <option value="5">5 Players</option>
      <option value="6">6 Players</option>
      <option value="7">7 Players</option>
      <option value="8">8 Players</option>
    </select>

    <!-- 9/18 Holes segmented control -->
    <div class="segmented-control" id="holesSegment">
      <input type="radio" id="holes9" name="holesCount" value="9" onchange="setHolesCount(9)">
      <label for="holes9">9 Holes</label>
      <input type="radio" id="holes18" name="holesCount" value="18" onchange="setHolesCount(18)">
      <label for="holes18">18 Holes</label>
    </div>

    <button id="sortByRankBtn" onclick="toggleSortByRank()">Sort by Rank</button>
    <select id="themeColorSelect" onchange="setThemeColor(this.value)">
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="pink">Pink</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="green">Green</option>
      <option value="grey">Grey</option>
    </select>
    <button id="resetButton" onclick="handleResetClick()">Reset</button>
  </div>

  <!-- Player Name Modal -->
  <div id="playerNameModal"></div>

  <!-- Overlay -->
  <div id="overlay"></div>

  <script>
    /* ---------------- State / storage ---------------- */
    const LS = {
      holesCount: 'dg-holesCount',
      playerCount: 'dg-playerCount',
      themeColor: 'dg-themeColor',
      sort: 'dg-sortByRankEnabled',
      emojiMode: 'dg-emojiModeEnabled',
      name: (p) => `dg-playerName-${p}`,
      par:  (h) => `dg-par-H${h}`,
      score:(p,h)=> `dg-${p}-H${h}`,
    };

    const THEME_MAP = {
      blue:   { h: 210, s: 85 },
      red:    { h:   0, s: 78 },
      green:  { h: 120, s: 50 },
      pink:   { h: 330, s: 70 },
      purple: { h: 268, s: 70 },
      yellow: { h:  45, s: 90 },
      grey:   { h: 210, s:  0 }
    };
    function getThemeHS(key) { return THEME_MAP[key] || THEME_MAP.blue; }

    const KEYCAP_DIGITS = ["0️⃣","1️⃣","2️⃣","3️⃣","4️⃣","5️⃣","6️⃣","7️⃣","8️⃣","9️⃣"];
    function numberToKeycap(n) { return KEYCAP_DIGITS[n] || String(n); }
    function keycapToNumber(str) {
      const idx = KEYCAP_DIGITS.indexOf(str);
      return idx === -1 ? null : idx;
    }
    function extractEmojis(str) {
      if (!str) return '';
      let segments;
      if (typeof Intl !== 'undefined' && Intl.Segmenter) {
        segments = Array.from(new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(str), s => s.segment);
      } else { segments = Array.from(str); }
      const rePict = /\p{Extended_Pictographic}/u;
      const reRI = /[\u{1F1E6}-\u{1F1FF}]/u;
      const reKeycap = /[#*0-9]\uFE0F?\u20E3/u;
      const reVS16 = /\uFE0F/u;
      const reTagFlag = /\u{1F3F4}[\u{E0061}-\u{E007A}]{1,14}\u{E007F}/u;
      return segments.filter(seg =>
        rePict.test(seg) || reRI.test(seg) || reKeycap.test(seg) || reVS16.test(seg) || reTagFlag.test(seg)
      ).join('');
    }

    let themeColor = localStorage.getItem(LS.themeColor) || 'blue';
    let holesCount = [9,18].includes(parseInt(localStorage.getItem(LS.holesCount),10)) ? parseInt(localStorage.getItem(LS.holesCount),10) : 18;
    let playerCount = Math.min(8, Math.max(1, parseInt(localStorage.getItem(LS.playerCount) || '4', 10)));
    let sortByRankEnabled = localStorage.getItem(LS.sort) === 'true';
    let emojiModeEnabled = localStorage.getItem(LS.emojiMode) === 'true';

    // Inline edit state
    let activeCell = null;
    let activeInput = null;
    let activeMode = null; // 'score' | 'par'
    let resetConfirm = false;

    // New flags to manage seamless Next + outside tap
    let suppressNextCellEditClick = false;
    let suppressClickTimeout = null;
    let isApplyingInline = false;

    /* ---------------- Height sync ---------------- */
    function setFullHeight() {
      const table = document.getElementById('scoreTable');
      if (table) table.style.height = `${window.innerHeight}px`;
    }

    /* ---------------- Init ---------------- */
    document.addEventListener('DOMContentLoaded', () => {
      // Preload selects
      const pcSel = document.getElementById('playerCount');
      if (pcSel) pcSel.value = String(playerCount);
      const themeSel = document.getElementById('themeColorSelect');
      if (themeSel) themeSel.value = themeColor;

      // Set holes segmented toggle
      const holes9 = document.getElementById('holes9');
      const holes18 = document.getElementById('holes18');
      if (holes9 && holes18) {
        holes9.checked = holesCount === 9;
        holes18.checked = holesCount === 18;
      }

      buildTable();
      loadFromStorage();
      updateAllTotals();
      updateRanks();
      fitRowsToViewport();
      setFullHeight();
      clipPlayerNamesToCell();

      const sortBtn = document.getElementById('sortByRankBtn');
      if (sortBtn) sortBtn.classList.toggle('active', sortByRankEnabled);
    });

    // Keep in sync on resize/orientation like reference
    window.addEventListener('resize', () => { setFullHeight(); clipPlayerNamesToCell(); fitRowsToViewport(); });
    window.addEventListener('orientationchange', () => {
      setTimeout(() => {
        setFullHeight();
        fitRowsToViewport();
      }, 250);
    });

    /* ---------------- Build ---------------- */
    function buildTable() {
      const headerRow = document.getElementById('playerRow');
      headerRow.innerHTML = `
        <th class="hole-header" onclick="showRoundManagement()"><button class="gear" title="Round settings">☰</button></th>
        <th class="par-header">Par</th>
      `;

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        const th = document.createElement('th');
        th.setAttribute('data-player', pid);
        th.title = savedName;
        th.innerHTML = `
          <span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span>
          <div id="total${pid}"></div>
        `;
        th.addEventListener('click', () => { window.currentPlayer = pid; openPlayerModalForHeader(pid); });
        headerRow.appendChild(th);
      }

      const body = document.getElementById('scoreBody');
      body.innerHTML = '';

      const firstNine = Math.min(9, holesCount);
      for (let h = 1; h <= firstNine; h++) body.appendChild(makeHoleRow(h));

      // OUT summary
      const trOut = document.createElement('tr');
      trOut.className = 'summary-row';
      trOut.appendChild(makeStickyCell('hole-cell', 'OUT'));
      const outPar = document.createElement('td'); outPar.className = 'par-cell'; outPar.setAttribute('data-sum', 'out-par');
      trOut.appendChild(outPar);
      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td'); td.setAttribute('data-sum', `out-P${p}`); trOut.appendChild(td);
      }
      body.appendChild(trOut);

      if (holesCount > 9) {
        for (let h = 10; h <= holesCount; h++) body.appendChild(makeHoleRow(h));
        // IN summary
        const trIn = document.createElement('tr');
        trIn.className = 'summary-row';
        trIn.appendChild(makeStickyCell('hole-cell', 'IN'));
        const inPar = document.createElement('td'); inPar.className = 'par-cell'; inPar.setAttribute('data-sum', 'in-par');
        trIn.appendChild(inPar);
        for (let p = 1; p <= playerCount; p++) {
          const td = document.createElement('td'); td.setAttribute('data-sum', `in-P${p}`); trIn.appendChild(td);
        }
        body.appendChild(trIn);
      }
    }
    function makeStickyCell(cls, text) {
      const td = document.createElement('td');
      td.className = cls;
      td.textContent = text;
      return td;
    }
    function makeHoleRow(h) {
      const tr = document.createElement('tr');

      const tdHole = document.createElement('td');
      tdHole.className = 'hole-cell';
      tdHole.textContent = String(h);
      tr.appendChild(tdHole);

      const tdPar = document.createElement('td');
      tdPar.className = 'par-cell';
      tdPar.setAttribute('data-hole', `H${h}`);
      tdPar.addEventListener('click', () => startInlineEdit(tdPar, 'par'));
      tdPar.textContent = '3';
      tr.appendChild(tdPar);

      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.className = 'score-cell';
        td.setAttribute('data-player', `P${p}`);
        td.setAttribute('data-hole', `H${h}`);
        td.addEventListener('click', () => startInlineEdit(td, 'score'));
        tr.appendChild(td);
      }
      return tr;
    }

    /* ---------------- Storage load ---------------- */
    function loadFromStorage() {
      // Pars
      for (let h = 1; h <= holesCount; h++) {
        const savedPar = parseInt(localStorage.getItem(LS.par(h)) || '3', 10);
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = String(savedPar);
      }
      // Scores
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const saved = localStorage.getItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && saved != null) td.textContent = saved;
        }
      }
      // Names
      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const headerName = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        const savedName = localStorage.getItem(LS.name(pid));
        if (headerName && savedName) {
          headerName.textContent = savedName;
          headerName.setAttribute('data-full', savedName);
          headerName.setAttribute('title', savedName);
        }
      }
    }

    /* ---------------- Inline editing (no popup) ---------------- */
    function startInlineEdit(td, mode, options = {}) {
      const preserveKeyboard = !!options.preserveKeyboard;
      const prevCell = activeCell;
      const prevInput = activeInput;

      if (!preserveKeyboard) {
        endInlineEdit(true);
      }

      activeCell = td;
      activeMode = mode;

      const input = document.createElement('input');
      input.type = 'number';
      input.className = 'inline-number';
      input.inputMode = 'numeric';
      input.autocomplete = 'off';
      input.autocorrect = 'off';
      input.spellcheck = false;
      input.value = td.textContent.trim();
      input.setAttribute('enterkeyhint', mode === 'score' ? 'next' : 'done');

      td.dataset.prev = td.textContent;
      td.textContent = '';
      td.classList.add('editing');
      td.appendChild(input);

      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyInlineEdit(input.value, true);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          cancelInlineEdit();
        }
      });
      input.addEventListener('blur', () => {
        if (input !== activeInput) return;
        applyInlineEdit(input.value, false);
      });

      activeInput = input;

      setTimeout(() => {
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        input.select();

        if (preserveKeyboard && prevInput && prevCell) {
          prevCell.classList.remove('editing');
          delete prevCell.dataset.prev;
          if (prevInput.parentElement) prevInput.parentElement.removeChild(prevInput);
          if ('prevDisplayText' in options) prevCell.textContent = options.prevDisplayText;
        }
      }, 0);
    }

    function getNextScoreCell(currentTd) {
      const cells = Array.from(document.querySelectorAll('#scoreBody td.score-cell'));
      const idx = cells.indexOf(currentTd);
      if (idx !== -1) {
        return cells[idx + 1] || null;
      }
      return null;
    }

    function applyInlineEdit(val, advanceOnEnter) {
      if (!activeCell || !activeInput || isApplyingInline) return;
      isApplyingInline = true;

      const td = activeCell;
      const mode = activeMode;
      const hole = parseInt(td.getAttribute('data-hole')?.replace('H','') || '0', 10) || null;
      const player = td.getAttribute('data-player') || null;
      const trimmed = String(val ?? '').trim();

      let displayText = '';
      if (mode === 'score') {
        if (trimmed === '') {
          displayText = '';
          if (player && hole) localStorage.removeItem(LS.score(player, hole));
        } else {
          const n = Math.max(0, parseInt(trimmed, 10) || 0);
          displayText = String(n);
          if (player && hole) localStorage.setItem(LS.score(player, hole), displayText);
        }
      } else if (mode === 'par') {
        if (trimmed === '') {
          displayText = '3';
          if (hole) localStorage.setItem(LS.par(hole), '3');
        } else {
          const n = Math.max(1, parseInt(trimmed, 10) || 3);
          displayText = String(n);
          if (hole) localStorage.setItem(LS.par(hole), displayText);
        }
      }

      const shouldAdvance = advanceOnEnter && mode === 'score';
      const nextCell = shouldAdvance ? getNextScoreCell(td) : null;

      if (nextCell) {
        startInlineEdit(nextCell, 'score', { preserveKeyboard: true, prevDisplayText: displayText });
        updateAllTotals();
        if (sortByRankEnabled) applySortByRank(true);
        updateRanks();
        isApplyingInline = false;
        return;
      }

      td.textContent = displayText;
      endInlineEdit(false);
      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
      isApplyingInline = false;
    }

    function cancelInlineEdit() {
      if (!activeCell) return;
      if (activeCell.dataset.prev != null) activeCell.textContent = activeCell.dataset.prev;
      endInlineEdit(false);
    }

    function endInlineEdit(clearOnly) {
      if (activeCell) {
        activeCell.classList.remove('editing');
        delete activeCell.dataset.prev;
      }
      if (activeInput && activeInput.parentElement) activeInput.parentElement.removeChild(activeInput);
      activeCell = null; activeInput = null; activeMode = null;
      if (!clearOnly) fitRowsToViewport();
    }

    /* ---------------- Outside tap handling ---------------- */
    document.addEventListener('pointerdown', (e) => {
      if (activeInput && !activeInput.contains(e.target)) {
        const cellHit = e.target.closest('td.score-cell, td.par-cell');
        if (cellHit) {
          suppressNextCellEditClick = true;
          clearTimeout(suppressClickTimeout);
          suppressClickTimeout = setTimeout(() => { suppressNextCellEditClick = false; }, 300);
        }
        applyInlineEdit(activeInput.value, false);
      }
    }, true);

    document.addEventListener('click', (e) => {
      if (suppressNextCellEditClick && e.target.closest('td.score-cell, td.par-cell')) {
        e.stopPropagation();
        e.stopImmediatePropagation();
        suppressNextCellEditClick = false;
      }
    }, true);

    /* ---------------- Round Management ---------------- */
    function showRoundManagement() {
      const pcSel = document.getElementById('playerCount');
      const themeSel = document.getElementById('themeColorSelect');
      const sortBtn = document.getElementById('sortByRankBtn');

      pcSel.value = String(playerCount);
      themeSel.value = themeColor;
      sortBtn.classList.toggle('active', sortByRankEnabled);

      // Sync holes segmented control
      const holes9 = document.getElementById('holes9');
      const holes18 = document.getElementById('holes18');
      if (holes9 && holes18) {
        holes9.checked = holesCount === 9;
        holes18.checked = holesCount === 18;
      }

      document.getElementById('roundManagementModal').style.display = 'block';
      showOverlay();
      resetButtonState();
    }
    function closeRoundManagement() {
      resetButtonState();
      document.getElementById('roundManagementModal').style.display = 'none';
      hideOverlay();
    }

    function handleResetClick() {
      const btn = document.getElementById('resetButton');
      if (!resetConfirm) {
        resetConfirm = true;
        btn.textContent = 'Confirm';
        btn.setAttribute('data-confirm', 'true');
      } else {
        resetScores();
        resetButtonState();
      }
    }
    function resetButtonState() {
      resetConfirm = false;
      const btn = document.getElementById('resetButton');
      if (btn) { btn.textContent = 'Reset'; btn.removeAttribute('data-confirm'); }
    }

    /* Add/remove players without full rebuild */
    function updatePlayerCount() {
      const val = parseInt(document.getElementById('playerCount').value, 10);
      const newCount = Math.min(8, Math.max(1, val));

      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));
      const existing = headerRow.children.length - 2; // exclude hole + par

      // Remove extra players
      if (newCount < existing) {
        for (let i = existing; i > newCount; i--) {
          const pid = `P${i}`;
          if (headerRow.lastElementChild) headerRow.removeChild(headerRow.lastElementChild);
          rows.forEach(tr => { if (tr.lastElementChild) tr.removeChild(tr.lastElementChild); });
          localStorage.removeItem(LS.name(pid));
          for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(pid, h));
        }
      }

      // Add players
      if (newCount > existing) {
        for (let i = existing + 1; i <= newCount; i++) {
          const pid = `P${i}`;
          const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && i <= 9 ? numberToKeycap(i) : pid);

          const th = document.createElement('th');
          th.setAttribute('data-player', pid);
          th.title = savedName;
          th.innerHTML = `<span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span><div id="total${pid}"></div>`;
          th.addEventListener('click', () => { window.currentPlayer = pid; openPlayerModalForHeader(pid); });
          headerRow.appendChild(th);

          rows.forEach(tr => {
            const first = tr.firstElementChild;
            const isSummary = tr.classList.contains('summary-row');
            const td = document.createElement('td');
            if (!isSummary) {
              const holeNo = parseInt(tr.querySelector('.hole-cell')?.textContent || '0', 10);
              td.className = 'score-cell';
              td.setAttribute('data-player', pid);
              td.setAttribute('data-hole', `H${holeNo}`);
              td.addEventListener('click', () => startInlineEdit(td, 'score'));
              const saved = localStorage.getItem(LS.score(pid, holeNo));
              if (saved != null) td.textContent = saved;
            } else {
              const label = first?.textContent?.trim() || '';
              if (label === 'OUT') td.setAttribute('data-sum', `out-${pid}`);
              if (label === 'IN') td.setAttribute('data-sum', `in-${pid}`);
            }
            tr.appendChild(td);
          });
        }
      }

      playerCount = newCount;
      localStorage.setItem(LS.playerCount, String(playerCount));
      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
      closeRoundManagement();
    }

    // Segmented holes toggle
    function setHolesCount(val) {
      const n = parseInt(val, 10);
      holesCount = [9, 18].includes(n) ? n : 18;
      localStorage.setItem(LS.holesCount, String(holesCount));
      rebuildPreserving();
      updateRanks();
    }

    function toggleSortByRank() {
      sortByRankEnabled = !sortByRankEnabled;
      localStorage.setItem(LS.sort, String(sortByRankEnabled));
      const btn = document.getElementById('sortByRankBtn');
      if (btn) btn.classList.toggle('active', sortByRankEnabled);
      if (sortByRankEnabled) applySortByRank();
      updateRanks();
    }
    function setThemeColor(value) {
      themeColor = value || 'blue';
      localStorage.setItem(LS.themeColor, themeColor);
      updateScoreColors(); // recolor under-par cells with new theme
      updateRanks();
    }

    function resetScores() {
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(`P${p}`, h));
      }
      for (let h = 1; h <= 18; h++) localStorage.setItem(LS.par(h), '3');

      document.querySelectorAll('#scoreBody td.score-cell').forEach(td => td.textContent = '');
      document.querySelectorAll('#scoreBody .par-cell[data-hole]').forEach(td => td.textContent = '3');

      updateAllTotals();
      updateRanks();
      closeRoundManagement();
    }

    /* ---------------- Player naming ---------------- */
    function openPlayerModalForHeader(pid) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      const currentName = header?.getAttribute('data-full') || header?.textContent || pid;
      window.currentPlayer = pid;
      if (emojiModeEnabled) openEmojiPlayerModal(currentName);
      else openTextPlayerModal(currentName);
    }

    function openTextPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">×</span>
        <input type="text" id="playerNameInput"
               value="${(currentName || '').toUpperCase()}"
               autocapitalize="characters"
               inputmode="text"
               autocomplete="off" autocorrect="off" spellcheck="false"
               style="text-transform: uppercase;">
        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      const input = document.getElementById('playerNameInput');
      let primed = false;
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => { try { input.select(); } catch (_) {} });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', e => e.preventDefault());
      input.addEventListener('contextmenu', e => e.preventDefault());
      input.addEventListener('input', function(){ this.value = this.value.toUpperCase(); });
      input.addEventListener('keydown', function(e){
        if (e.key === 'Enter') {
          e.preventDefault();
          const newName = (this.value || '').trim().toUpperCase();
          if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
          closePlayerNameModal();
        }
      });
      input.addEventListener('blur', function(){
        const newName = (this.value || '').trim().toUpperCase();
        if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
      });
    }

    function openEmojiPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      const favEmojis = [
        "🍔","🩰","🌹","🌰","🔔",
        "👑","🎣","🌻","🏏","🦈",
        "🤸🏼‍♀️","🎁","🕊️","🧶","🛠️",
        "🏃"
      ];
      const grid = favEmojis.map(e => `<button type="button" class="emoji-pick" data-emoji="${e}">${e}</button>`).join('');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">×</span>
        <input type="text" id="emojiNameInput" value="${currentName || ''}"
               inputmode="text" placeholder="Pick an emoji" enterkeyhint="done"
               autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">
        <div class="emoji-grid">${grid}</div>

        <div id="bulkEmojiActions" class="bulk-actions">
          <div class="row">
            <button type="button" id="bulkCancelBtn" class="light">Cancel</button>
            <button type="button" id="bulkApplyBtn">Select</button>
          </div>
        </div>

        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      let primed = false;
      const input = document.getElementById('emojiNameInput');
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => { try { input.select(); } catch (_) {} });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', (e) => e.preventDefault());
      input.addEventListener('contextmenu', (e) => e.preventDefault());

      let autoClosed = false;
      input.addEventListener('input', function () {
        const sanitized = extractEmojis(this.value);
        if (sanitized !== this.value) this.value = sanitized;
        if (sanitized && !autoClosed) {
          if (window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          autoClosed = true;
          closePlayerNameModal();
        }
      });
      input.addEventListener('keypress', function (e) {
        if (e.key === 'Enter') {
          const sanitized = extractEmojis((this.value || '').trim());
          if (sanitized && window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          closePlayerNameModal();
        }
      });

      attachEmojiGridInteractions();
    }

    function setEmojiMode(enabled, reopenForPlayerId = null) {
      emojiModeEnabled = !!enabled;
      localStorage.setItem(LS.emojiMode, emojiModeEnabled ? 'true' : 'false');
      syncDefaultNamesToMode();
      if (reopenForPlayerId) openPlayerModalForHeader(reopenForPlayerId);
      updateRanks();
    }
    function toggleEmojiMode() { setEmojiMode(!emojiModeEnabled); }

    function handleRemovePlayer(button) {
      if (button.dataset.state === 'initial') {
        button.textContent = 'Confirm';
        button.dataset.state = 'confirm';
      } else {
        if (window.currentPlayer) {
          removePlayer(window.currentPlayer);
          closePlayerNameModal();
        }
      }
    }

    function removePlayer(pid) {
      const idx = parseInt(pid.replace('P',''), 10) - 1;
      if (playerCount <= 1) { alert('At least one player must remain.'); return false; }

      const headerRow = document.getElementById('playerRow');
      if (headerRow.children[idx + 2]) headerRow.removeChild(headerRow.children[idx + 2]);

      document.querySelectorAll('#scoreBody tr').forEach(row => {
        if (row.children[idx + 2]) row.removeChild(row.children[idx + 2]);
      });

      // Reindex storage and DOM attributes for players to the right
      for (let p = idx + 2; p <= playerCount; p++) {
        const oldPid = `P${p}`, newPid = `P${p-1}`;
        const name = localStorage.getItem(LS.name(oldPid));
        if (name != null) { localStorage.setItem(LS.name(newPid), name); localStorage.removeItem(LS.name(oldPid)); }
        for (let h = 1; h <= holesCount; h++) {
          const v = localStorage.getItem(LS.score(oldPid, h));
          if (v != null) { localStorage.setItem(LS.score(newPid, h), v); localStorage.removeItem(LS.score(oldPid, h)); }
        }
      }
      // Clean removed player's storage
      localStorage.removeItem(LS.name(pid));
      for (let h = 1; h <= 18; h++) localStorage.removeItem(LS.score(pid, h));

      playerCount -= 1;
      localStorage.setItem(LS.playerCount, String(playerCount));
      fitRowsToViewport();
      updateAllTotals();
      updateRanks();
      return true;
    }

    // Preserve rank badge (small) when renaming (like Yahtzee)
    function applyPlayerName(pid, newName) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
      if (!header) return;
      const totalDiv = header.querySelector('div[id^="total"]');
      const totalTxt = totalDiv ? totalDiv.textContent : '';
      const rankEl = header.querySelector('small');
      const rankHTML = rankEl ? rankEl.outerHTML : '';
      header.innerHTML = `<span class="player-name" data-full="${newName}" title="${newName}">${newName}</span><div id="total${pid}">${totalTxt}</div>${rankHTML}`;
      header.setAttribute('data-player', pid);
      localStorage.setItem(LS.name(pid), newName);
      clipPlayerNamesToCell();
      updateRanks();
    }

    function closePlayerNameModal() {
      const modal = document.getElementById('playerNameModal');
      const btn = modal.querySelector('button[onclick^="handleRemovePlayer"]');
      if (btn) { btn.textContent = 'Remove'; btn.dataset.state = 'initial'; }
      modal.style.display = 'none';
      hideOverlay();
    }

    function attachEmojiGridInteractions() {
      const modal = document.getElementById('playerNameModal');
      const buttons = Array.from(modal.querySelectorAll('.emoji-pick'));
      const bulkBar = modal.querySelector('#bulkEmojiActions');
      const seg = modal.querySelector('.segmented-control');
      const emojiInput = modal.querySelector('#emojiNameInput');
      let bulkEmojiMode = false;
      let bulkEmojiSelection = [];
      const bulkMaxPlayers = 8;

      const enterBulk = () => {
        if (bulkEmojiMode) return;
        bulkEmojiMode = true; bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'block';
        if (seg) seg.style.display = 'none';
        if (emojiInput) emojiInput.style.display = 'none';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.add('bulk-mode');
      };
      const exitBulk = () => {
        bulkEmojiMode = false; bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'none';
        if (seg) seg.style.display = '';
        if (emojiInput) emojiInput.style.display = '';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.remove('bulk-mode');
      };
      const renumber = () => {
        buttons.forEach(b => { if (b.classList.contains('selected')) b.setAttribute('data-order', ''); });
        bulkEmojiSelection.forEach((emoji, i) => {
          const b = buttons.find(btn => btn.getAttribute('data-emoji') === emoji);
          if (b) b.setAttribute('data-order', String(i + 1));
        });
      };
      const toggleSel = (btn) => {
        const emoji = btn.getAttribute('data-emoji');
        const idx = bulkEmojiSelection.indexOf(emoji);
        if (idx !== -1) { bulkEmojiSelection.splice(idx, 1); btn.classList.remove('selected'); btn.removeAttribute('data-order'); }
        else {
          if (bulkEmojiSelection.length >= bulkMaxPlayers) return;
          bulkEmojiSelection.push(emoji); btn.classList.add('selected');
        }
        renumber();
      };
      const applyBulk = (selected) => {
        const targetCount = Math.min(bulkMaxPlayers, selected.length);
        if (targetCount < 1) return;
        emojiModeEnabled = true;
        localStorage.setItem(LS.emojiMode, 'true');

        const pcSel = document.getElementById('playerCount');
        pcSel.value = String(targetCount);
        updatePlayerCount();

        for (let i = 1; i <= targetCount; i++) applyPlayerName(`P${i}`, selected[i - 1]);
        exitBulk();
        closePlayerNameModal();
      };

      const cancelBtn = modal.querySelector('#bulkCancelBtn');
      const applyBtn = modal.querySelector('#bulkApplyBtn');
      if (cancelBtn) cancelBtn.addEventListener('click', () => exitBulk());
      if (applyBtn) applyBtn.addEventListener('click', () => { if (bulkEmojiSelection.length > 0) applyBulk(bulkEmojiSelection); });

      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (bulkEmojiMode) toggleSel(btn);
          else {
            const emoji = btn.getAttribute('data-emoji');
            if (emoji && window.currentPlayer) {
              applyPlayerName(window.currentPlayer, emoji);
              closePlayerNameModal();
            }
          }
        });
        // Long-press to enter bulk (500ms)
        let pressTimer = null;
        const start = () => {
          if (bulkEmojiMode) return;
          clearTimeout(pressTimer);
          pressTimer = setTimeout(() => enterBulk(), 500);
        };
        const cancel = () => { clearTimeout(pressTimer); pressTimer = null; };
        btn.addEventListener('pointerdown', start);
        btn.addEventListener('pointerup', cancel);
        btn.addEventListener('pointerleave', cancel);
        btn.addEventListener('touchstart', start, { passive: true });
        btn.addEventListener('touchend', cancel);
        btn.addEventListener('touchcancel', cancel);
        btn.addEventListener('mousedown', start);
        btn.addEventListener('mouseup', cancel);
        btn.addEventListener('mouseleave', cancel);
      });
    }

    function syncDefaultNamesToMode() {
      for (let i = 1; i <= playerCount; i++) {
        const pid = `P${i}`;
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (!header) continue;
        const displayed = (header.getAttribute('data-full') || header.textContent || '').trim();
        const stored = localStorage.getItem(LS.name(pid));
        const current = stored != null ? stored : displayed;
        let newName = current;

        if (emojiModeEnabled) {
          const m = /^P(\d{1,2})$/i.exec(current);
          if (m) {
            const n = parseInt(m[1], 10);
            if (n >= 0 && n <= 9) newName = numberToKeycap(n);
          } else if (stored == null && i <= 9) {
            newName = numberToKeycap(i);
          }
        } else {
          const n = keycapToNumber(current);
          if (n !== null) newName = `P${n}`;
        }

        if (newName !== current) {
          applyPlayerName(pid, newName);
        } else if (stored == null) {
          localStorage.setItem(LS.name(pid), current);
        }
      }
      clipPlayerNamesToCell();
    }

    /* ---------------- Totals / ranks / layout ---------------- */
    function fitRowsToViewport() {
      const table = document.getElementById('scoreTable');
      const header = table.querySelector('thead');
      const headerH = header ? header.getBoundingClientRect().height : 0;
      const rows = document.querySelectorAll('#scoreBody tr').length;
      const viewportH = Math.max(window.innerHeight, document.documentElement.clientHeight || 0);
      if (rows > 0) {
        const approxBorders = rows; /* 1px per row bottom border */
        const avail = Math.max(1, viewportH - headerH);
        const rowH = Math.max(20, Math.floor((avail - approxBorders) / rows));
        document.documentElement.style.setProperty('--row-h', rowH + 'px');
      }
    }

    function getPar(h) {
      const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
      const v = parseInt(cell?.textContent || '3', 10);
      return Number.isFinite(v) ? v : 3;
    }
    function getScore(player, h) {
      const td = document.querySelector(`td.score-cell[data-player="${player}"][data-hole="H${h}"]`);
      const v = parseInt(td?.textContent || '', 10);
      return Number.isFinite(v) ? v : null;
    }
    function hasAnyEntry() {
      return Array.from(document.querySelectorAll('.score-cell')).some(td => td.textContent.trim() !== '');
    }

    // Color score numbers: par=black, over=grey, under=theme color
    function updateScoreColors() {
      const { h: H, s: S } = getThemeHS(themeColor);
      const themeText = (l = 40) => `hsl(${H}, ${S}%, ${l}%)`;
      const grey = '#808080';
      document.querySelectorAll('#scoreBody td.score-cell').forEach(td => {
        const txt = td.textContent.trim();
        if (!txt) { td.style.color = ''; return; }
        const score = parseInt(txt, 10);
        if (!Number.isFinite(score)) { td.style.color = ''; return; }
        const holeAttr = td.getAttribute('data-hole') || '';
        const hole = parseInt(holeAttr.replace('H',''), 10);
        const par = Number.isFinite(hole) ? getPar(hole) : 3;
        if (score < par) td.style.color = themeText(40);
        else if (score > par) td.style.color = grey;
        else td.style.color = '#000000';
      });
    }

    function updateAllTotals() {
      const outRange = [...Array(Math.min(9, holesCount)).keys()].map(i => i + 1);
      const inRange  = (holesCount > 9) ? [...Array(holesCount - 9).keys()].map(i => i + 10) : [];

      const parOut = outRange.reduce((s, h) => s + getPar(h), 0);
      const parIn  = inRange.reduce((s, h) => s + getPar(h), 0);

      const setSumCell = (key, val) => {
        const el = document.querySelector(`[data-sum="${key}"]`);
        if (el) el.textContent = String(val);
      };
      setSumCell('out-par', parOut);
      if (holesCount > 9) setSumCell('in-par', parIn);

      const any = hasAnyEntry();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const sumOut = outRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const sumIn  = inRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const played = [...outRange, ...inRange];
        let playedPar = 0, playedStrokes = 0, hasScore = false;
        for (const h of played) {
          const sc = getScore(pid, h);
          if (sc != null) { hasScore = true; playedStrokes += sc; playedPar += getPar(h); }
        }
        setSumCell(`out-${pid}`, sumOut);
        if (holesCount > 9) setSumCell(`in-${pid}`, sumIn);

        const totalDiv = document.getElementById(`total${pid}`);
        if (totalDiv) {
          if (hasScore) {
            const toPar = (playedPar === 0) ? 0 : (playedStrokes - playedPar);
            const tp = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
            totalDiv.textContent = `${playedStrokes} (${tp})`;
          } else {
            totalDiv.textContent = any ? '0 (E)' : '';
          }
        }
      }

      updateScoreColors();
    }

    function updateRanks() {
      const table = document.getElementById('scoreTable');
      const headers = Array.from(table.querySelectorAll('thead th')).slice(2);
      const count = headers.length;

      if (count >= 7) table.classList.add('small-scores');
      else table.classList.remove('small-scores');

      // Clear bg + old ranks
      headers.forEach(h => { h.style.background = ''; h.querySelectorAll('small').forEach(s => s.remove()); });

      const any = hasAnyEntry();
      if (!any) { clipPlayerNamesToCell(); return; }

      const totals = headers.map(h => {
        const pid = h.getAttribute('data-player');
        let sum = 0, hasScore = false;
        for (let i = 1; i <= holesCount; i++) {
          const sc = getScore(pid, i);
          if (sc != null) { hasScore = true; sum += sc; }
        }
        const rankValue = hasScore ? sum : Number.POSITIVE_INFINITY;
        return { h, pid, sum, hasScore, rankValue };
      });

      const sorted = [...totals].sort((a, b) => a.rankValue - b.rankValue);

      const groups = [];
      for (const item of sorted) {
        const last = groups[groups.length - 1];
        if (!last || last.score !== item.rankValue) groups.push({ score: item.rankValue, members: [item.pid] });
        else last.members.push(item.pid);
      }

      const { h: H, s: S } = getThemeHS(themeColor);
      const Lmax = 82, minRange = 18, maxRange = 44;
      const effective = groups.length;
      const normalized = Math.min(1, Math.max(0, (effective - 1) / (8 - 1)));
      const range = Math.round(minRange + (maxRange - minRange) * normalized);
      const Lmin = Math.max(28, Lmax - range);

      groups.forEach((group, g) => {
        const ratio = (effective === 1) ? 0 : g / (effective - 1);
        const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
        const Ltop = Math.max(18, L - 10);
        const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
        group.members.forEach(pid => {
          const th = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
          if (th) th.style.background = gradient;
        });
      });

      // Insert rank small immediately after the total div (match Yahtzee)
      const distinctAsc = Array.from(new Set(sorted.map(s => s.rankValue)));
      const rankByVal = new Map(distinctAsc.map((v, i) => [v, i + 1]));
      totals.forEach(({ h, rankValue }) => {
        const small = document.createElement('small');
        small.textContent = ordinalSuffixOf(rankByVal.get(rankValue) || 1);
        const totalDiv = h.querySelector('div[id^="total"]');
        if (totalDiv) totalDiv.insertAdjacentElement('afterend', small);
        else h.appendChild(small);
      });

      clipPlayerNamesToCell();
    }

    function ordinalSuffixOf(i) {
      const j = i % 10, k = i % 100;
      if (j === 1 && k !== 11) return i + "st";
      if (j === 2 && k !== 12) return i + "nd";
      if (j === 3 && k !== 13) return i + "rd";
      return i + "th";
    }

    function clipPlayerNamesToCell() {
      const seg = (typeof Intl !== 'undefined' && Intl.Segmenter)
        ? new Intl.Segmenter('en', { granularity: 'grapheme' })
        : null;
      const els = document.querySelectorAll('#scoreTable thead th .player-name');
      els.forEach(el => {
        const full = el.getAttribute('data-full') ?? el.textContent;
        el.setAttribute('data-full', full);
        el.textContent = full;

        if (el.scrollWidth <= el.clientWidth) return;

        const clusters = seg ? Array.from(seg.segment(full), s => s.segment) : Array.from(full);
        let low = 0, high = clusters.length, best = 0;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          el.textContent = clusters.slice(0, mid).join('');
          if (el.scrollWidth <= el.clientWidth) { best = mid; low = mid + 1; }
          else high = mid - 1;
        }
        el.textContent = clusters.slice(0, best).join('');
      });
    }

    function applySortByRank(silent = false) {
      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      const headers = Array.from(headerRow.children).slice(2);
      if (headers.length <= 1 || !hasAnyEntry()) return;

      const players = headers.map((th, idx) => {
        const pid = th.getAttribute('data-player');
        let sum = 0, hasScore = false;
        for (let h = 1; h <= holesCount; h++) {
          const sc = getScore(pid, h);
          if (sc != null) { hasScore = true; sum += sc; }
        }
        const rankValue = hasScore ? sum : Number.POSITIVE_INFINITY;
        return { idx, pid, rankValue, th };
      });

      const order = [...players].sort((a,b) => a.rankValue - b.rankValue || a.idx - b.idx).map(p => p.idx);
      if (order.every((v, i) => v === i)) { if (!silent) updateRanks(); return; }

      // Reorder headers (keep first 2 fixed)
      const fixed = Array.from(headerRow.children).slice(0,2);
      const moving = Array.from(headerRow.children).slice(2);
      headerRow.innerHTML = '';
      fixed.forEach(n => headerRow.appendChild(n));
      order.forEach(i => headerRow.appendChild(moving[i]));

      // Reorder each body row
      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixed2 = cells.slice(0,2);
        const movingCells = cells.slice(2);
        tr.innerHTML = '';
        fixed2.forEach(c => tr.appendChild(c));
        order.forEach(i => tr.appendChild(movingCells[i]));
      });

      if (!silent) updateRanks();
      fitRowsToViewport();
    }

    /* ---------------- Rebuild preserving (used for holes toggle) ---------------- */
    function rebuildPreserving() {
      const names = {};
      for (let p = 1; p <= 8; p++) {
        const k = LS.name(`P${p}`);
        const v = localStorage.getItem(k);
        if (v != null) names[`P${p}`] = v;
      }
      const pars = {};
      for (let h = 1; h <= 18; h++) {
        const k = LS.par(h);
        const v = localStorage.getItem(k);
        if (v != null) pars[h] = v;
      }
      const scores = {};
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) {
          const k = LS.score(`P${p}`, h);
          const v = localStorage.getItem(k);
          if (v != null) scores[`${p}-${h}`] = v;
        }
      }

      buildTable();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const nm = names[pid] || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        localStorage.setItem(LS.name(pid), nm);
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (header) {
          header.textContent = nm;
          header.setAttribute('data-full', nm);
          header.setAttribute('title', nm);
        }
      }
      for (let h = 1; h <= holesCount; h++) {
        const v = pars[h] ?? '3';
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) {
          cell.textContent = v;
          localStorage.setItem(LS.par(h), v);
        }
      }
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const key = `${p}-${h}`;
          const v = scores[key];
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && v != null) {
            td.textContent = v;
            localStorage.setItem(LS.score(`P${p}`, h), v);
          }
        }
      }

      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
      fitRowsToViewport();
      clipPlayerNamesToCell();
    }

    /* ---------------- Overlay ---------------- */
    function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
    function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }
    document.getElementById('overlay').addEventListener('click', () => {
      closeRoundManagement();
      closePlayerNameModal();
      if (activeInput) {
        applyInlineEdit(activeInput.value, false);
      } else {
        endInlineEdit(true);
      }
    });
  </script>
</body>
</html>