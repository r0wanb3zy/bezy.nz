<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Disc Golf Scorecard</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">

  <style>
    /* Base: full-height, no scrolling */
    html, body { height: 100%; margin: 0; overflow: hidden; touch-action: none; }
    body {
      font-family: 'Economica', sans-serif;
      font-size: 22px;
      max-width: 1200px;
      margin-left: auto;
      margin-right: auto;
      min-height: 100vh;
      background-size: cover;
      background: linear-gradient(135deg, #f0f2f5 0%, #ffffff 100%) no-repeat;
    }

    :root {
      --hole-w: 30px; /* narrow fixed */
      --par-w: 30px;  /* narrow fixed */
      --row-h: 34px;  /* JS will size this so all rows fit 100vh */
    }

    table {
      width: 100%;
      border-collapse: collapse;
      font-size: 20px;
      table-layout: fixed;
      font-family: 'Economica', sans-serif;
    }
    table, table th, table td { font-weight: bold; }

    /* Score table shell (full viewport height) */
    #scoreTable {
      height: 100vh;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
      overflow: hidden; /* no scrolling */
    }

    /* No sticky heading (header still styled) */
    #scoreTable thead th {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white;
      height: 80px;
      font-size: 22px;
      border-bottom: none;
      position: static;
      vertical-align: middle;
    }
    #scoreTable thead th:first-child {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      border-right: none;
      border-bottom: 1px solid #666;
    }

    /* Cells */
    table th, table td {
      border: none;
      text-align: center;
      padding: 5px;
      word-wrap: break-word;
      cursor: pointer;
      overflow: hidden;
      text-overflow: ellipsis;
      border-bottom: 1px solid rgba(200, 200, 200, 0.3);
      vertical-align: middle;
    }
    table td { border-right: 1px solid rgba(200, 200, 200, 0.3); }
    table td:last-child { border-right: none; }

    /* First two columns: fixed and narrow */
    th.hole-header, td.hole-cell {
      position: sticky; left: 0; z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--hole-w); min-width: var(--hole-w); max-width: var(--hole-w);
      border-right: 1px solid #666; cursor: default;
    }
    th.par-header, td.par-cell {
      position: sticky; left: var(--hole-w); z-index: 2;
      background: #3b3b3b; color: #fff;
      width: var(--par-w); min-width: var(--par-w); max-width: var(--par-w);
      border-right: 1px solid #666; cursor: pointer;
    }

    /* Force rows to fit viewport (JS sets --row-h) */
    #scoreTable tbody td, #scoreTable tbody th {
      height: var(--row-h);
      line-height: var(--row-h);
      padding-top: 0;
      padding-bottom: 0;
    }

    /* Summary rows (OUT/IN) */
    .summary-row td {
      background: #f6f7f8;
      font-weight: 700;
    }
    .summary-row td.hole-cell, .summary-row td.par-cell {
      background: #3b3b3b; color: white;
    }

    /* Header player content */
    #scoreTable thead th .player-name {
      display: block;
      max-width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: clip; /* JS clips properly */
    }
    #scoreTable thead th div[id^="total"] {
      font-size: 18px;
      color: rgba(255,255,255,0.9);
    }
    #scoreTable thead th small {
      font-size: 16px;
      font-family: 'Economica', sans-serif;
      color: rgba(255, 255, 255, 0.8);
    }
    #scoreTable.small-scores thead th .player-name {
      font-size: 18px;
      line-height: 1.1;
    }

    /* Gear button */
    .gear {
      font-size: 20px; cursor: pointer; color: #fff; background: none; border: none;
    }

    /* Popup (match reference) */
    #popupModal {
      display: none;
      position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 12px 20px;
      z-index: 1000; font-family: 'Economica', sans-serif; text-align: center;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
      width: 240px; max-width: 90%;
    }
    #popupModal h2 { margin: 15px 0; padding: 0; }

    /* Close X matches reference (use <span>) */
    .close-btn {
      position: absolute; top: 0px; right: 0px;
      font-size: 48px; color: #000000; cursor: pointer; background: none; border: none;
      padding: 0; line-height: 1; width: 40px; height: 40px; text-align: center; transition: color 0.2s ease;
    }

    /* Popup numeric input */
    #popupOptions { padding: 8px 0 0; }
    #popupOptions input[type="number"] {
      width: 100%;
      box-sizing: border-box;
      height: 44px;
      line-height: 44px;
      padding: 0 8px;
      text-align: center;
      font-size: 22px;
      font-family: 'Economica', sans-serif;
      border: 1px solid #d0d7de;
      border-radius: 6px;
      background: #ffffff;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
      -moz-appearance: textfield;
      appearance: textfield;
    }
    #popupOptions input[type="number"]::-webkit-outer-spin-button,
    #popupOptions input[type="number"]::-webkit-inner-spin-button { -webkit-appearance: none; margin: 0; }

    /* Round management (match reference) */
    #roundManagementModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px; text-align: center;
    }
    #roundManagementModal h2 { margin: 15px 0; padding: 0; }
    #roundManagementModal select {
      font-size: 24px; padding: 10px; margin: 5px 0;
      font-family: 'Economica', sans-serif; border: 1px solid #333; border-radius: 6px;
      background: #f8f9fa; width: 100%; box-sizing: border-box;
      text-align: center; text-align-last: center; -moz-text-align-last: center;
      -webkit-appearance: none; -moz-appearance: none; appearance: none;
      background-image: none !important; padding-right: 12px;
    }
    #roundManagementModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #roundManagementModal button#sortByRankBtn {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }
    #roundManagementModal button#sortByRankBtn.active {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #ffffff; border: 1px solid #262626;
    }

    /* Player Name Modal (match reference) */
    #playerNameModal {
      display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
      background: #ffffff; border: none; padding: 5px 20px 20px 20px; z-index: 1001;
      width: 200px; max-width: 90%; text-align: center; font-family: 'Economica', sans-serif;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1); border-radius: 10px;
    }
    #playerNameModal h2 { margin: 15px 0; padding: 0; }
    #playerNameModal input[type="text"] {
      font-size: 24px; padding: 10px; width: 100%; box-sizing: border-box; margin: 5px 0; text-align: center;
      font-family: 'Economica', sans-serif; border: 1px solid #d0d7de; border-radius: 6px; background: #ffffff;
      box-shadow: inset 0 1px 2px rgba(0,0,0,0.05); transition: border-color 0.2s ease;
    }
    #playerNameModal input[type="text"]:focus { outline: none; border: 1px solid #262626; }

    /* Player modal buttons EXACT like reference */
    #playerNameModal button {
      font-size: 24px; padding: 10px 20px; margin: 5px 0; cursor: pointer;
      font-family: 'Economica', sans-serif; background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: white; border: none; border-radius: 6px; transition: background 0.2s; width: 100%; box-sizing: border-box;
    }
    #playerNameModal button[data-state="confirm"] {
      background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
    }
    #playerNameModal button.light {
      background: #f8f9fa; color: #0f172a; border: 1px solid #262626;
    }

    /* Segmented control (Name | Emoji) */
    .segmented-control {
      display: flex; width: 100%; box-sizing: border-box; margin: 5px 0;
      background: #f8f9fa; border-radius: 6px; overflow: hidden; border: 1px solid #262626;
      -webkit-background-clip: padding-box; background-clip: padding-box;
    }
    .segmented-control input[type="radio"] { display: none; }
    .segmented-control label {
      flex: 1 1 0; padding: 10px 0; text-align: center; font-size: 24px; font-family: 'Economica', sans-serif;
      cursor: pointer; user-select: none; background: #f8f9fa; margin: 0;
    }
    .segmented-control input[type="radio"]:checked + label {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%); color: #fff;
    }

    /* Emoji grid (player modal) */
    .emoji-grid {
      --emoji-gap: 8px;
      display: grid; grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: var(--emoji-gap); padding: 0; margin: 5px 0; width: 100%; box-sizing: border-box;
      user-select: none; -webkit-user-select: none;
    }
    .emoji-grid .emoji-pick {
      background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
      color: #ffffff; border: none; border-radius: 6px;
      font-family: 'Economica', sans-serif; font-size: 22px; display: grid; place-items: center;
      width: 100%; aspect-ratio: 1 / 1; padding: 0; margin: 0; line-height: 1; cursor: pointer;
      transition: transform 0.05s ease, filter 0.1s ease; box-sizing: border-box; position: relative;
    }
    .emoji-grid .emoji-pick:active { transform: scale(0.95); filter: brightness(1.05); }
    .emoji-grid .emoji-pick.selected { box-shadow: 0 0 0 2px #262626 inset; }
    .emoji-grid .emoji-pick.selected::before {
      content: ""; position: absolute; inset: 0; background: rgba(0, 0, 0, 0.35);
      border-radius: 6px; pointer-events: none; z-index: 1;
    }
    .emoji-grid .emoji-pick.selected::after {
      content: attr(data-order); position: absolute; top: 50%; left: 50%; transform: translate(-50%, -55%);
      font-size: 28px; font-weight: 700; color: #fff; text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 3px rgba(0,0,0,0.7);
      pointer-events: none; z-index: 2;
    }
    .bulk-actions { display: none; margin: 5px 0 0 0; width: 100%; }
    .bulk-actions .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; align-items: center; width: 100%; }

    /* Overlay */
    #overlay {
      display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0,0,0,0.5); z-index: 999; cursor: pointer;
    }

    /* Disable tap highlight (mobile) */
    * { -webkit-tap-highlight-color: transparent; }
  </style>
</head>
<body>
  <!-- Score Table -->
  <table id="scoreTable">
    <thead>
      <tr id="playerRow">
        <th class="hole-header">
          <button class="gear" title="Round settings" onclick="showRoundManagement()">â˜°</button>
        </th>
        <th class="par-header">Par</th>
        <!-- Player headers injected -->
      </tr>
    </thead>
    <tbody id="scoreBody">
      <!-- Rows injected -->
    </tbody>
  </table>

  <!-- Numeric popup (same frame as reference) -->
  <div id="popupModal">
    <h2 id="popupTitle">Enter value</h2>
    <span class="close-btn" onclick="closePopup()">Ã—</span>
    <div id="popupOptions"></div>
  </div>

  <!-- Round Management -->
  <div id="roundManagementModal">
    <h2>Round</h2>
    <span class="close-btn" onclick="closeRoundManagement()">Ã—</span>
    <select id="playerCount" onchange="updatePlayerCount()">
      <option value="1">1 Players</option>
      <option value="2">2 Players</option>
      <option value="3">3 Players</option>
      <option value="4">4 Players</option>
      <option value="5">5 Players</option>
      <option value="6">6 Players</option>
      <option value="7">7 Players</option>
      <option value="8">8 Players</option>
    </select>
    <select id="holesCount" onchange="updateHolesCount()">
      <option value="9">9 Holes</option>
      <option value="18">18 Holes</option>
    </select>
    <button id="sortByRankBtn" onclick="toggleSortByRank()">Sort by Rank</button>
    <select id="themeColorSelect" onchange="setThemeColor(this.value)">
      <option value="blue">Blue</option>
      <option value="purple">Purple</option>
      <option value="pink">Pink</option>
      <option value="red">Red</option>
      <option value="yellow">Yellow</option>
      <option value="green">Green</option>
      <option value="grey">Grey</option>
    </select>
    <button class="danger" onclick="resetScores()">Reset</button>
  </div>

  <!-- Player Name Modal -->
  <div id="playerNameModal"></div>

  <!-- Overlay -->
  <div id="overlay"></div>

  <script>
    /* ---------------- State / keys / theme ---------------- */
    const LS = {
      holesCount: 'dg-holesCount',
      playerCount: 'dg-playerCount',
      themeColor: 'dg-themeColor',
      sort: 'dg-sortByRankEnabled',
      emojiMode: 'dg-emojiModeEnabled',
      name: (p) => `dg-playerName-${p}`,
      par:  (h) => `dg-par-H${h}`,
      score:(p,h)=> `dg-${p}-H${h}`,
    };

    const THEME_MAP = {
      blue:   { h: 210, s: 85 },
      red:    { h:   0, s: 78 },
      green:  { h: 120, s: 50 },
      pink:   { h: 330, s: 70 },
      purple: { h: 268, s: 70 },
      yellow: { h:  45, s: 90 },
      grey:   { h: 210, s:  0 }
    };
    function getThemeHS(key) { return THEME_MAP[key] || THEME_MAP.blue; }
    function getThemeTextColor(key) {
      const t = THEME_MAP[key] || THEME_MAP.blue;
      const L = key === 'yellow' ? 32 : 34;
      return `hsl(${t.h}, ${t.s}%, ${L}%)`;
    }

    const KEYCAP_DIGITS = ["0ï¸âƒ£","1ï¸âƒ£","2ï¸âƒ£","3ï¸âƒ£","4ï¸âƒ£","5ï¸âƒ£","6ï¸âƒ£","7ï¸âƒ£","8ï¸âƒ£","9ï¸âƒ£"];
    function numberToKeycap(n) { return KEYCAP_DIGITS[n] || String(n); }
    function keycapToNumber(str) {
      const idx = KEYCAP_DIGITS.indexOf(str);
      return idx === -1 ? null : idx;
    }
    function extractEmojis(str) {
      if (!str) return '';
      let segments;
      if (typeof Intl !== 'undefined' && Intl.Segmenter) {
        segments = Array.from(new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(str), s => s.segment);
      } else {
        segments = Array.from(str);
      }
      const rePict = /\p{Extended_Pictographic}/u;
      const reRI = /[\u{1F1E6}-\u{1F1FF}]/u;
      const reKeycap = /[#*0-9]\uFE0F?\u20E3/u;
      const reVS16 = /\uFE0F/u;
      const reTagFlag = /\u{1F3F4}[\u{E0061}-\u{E007A}]{1,14}\u{E007F}/u;
      return segments.filter(seg =>
        rePict.test(seg) || reRI.test(seg) || reKeycap.test(seg) || reVS16.test(seg) || reTagFlag.test(seg)
      ).join('');
    }

    let themeColor = localStorage.getItem(LS.themeColor) || 'blue';
    let holesCount = [9,18].includes(parseInt(localStorage.getItem(LS.holesCount),10)) ? parseInt(localStorage.getItem(LS.holesCount),10) : 18;
    let playerCount = Math.min(8, Math.max(1, parseInt(localStorage.getItem(LS.playerCount) || '4', 10)));
    let sortByRankEnabled = localStorage.getItem(LS.sort) === 'true';
    let emojiModeEnabled = localStorage.getItem(LS.emojiMode) === 'true';

    // Popup context
    let currentMode = null; // 'score' | 'par'
    let currentCell = null;
    let currentHole = null;
    let currentPlayer = null;

    // Bulk emoji
    let bulkEmojiMode = false;
    let bulkEmojiSelection = [];
    const bulkMaxPlayers = 8;

    /* ---------------- Init ---------------- */
    function setFullHeight() {
      const table = document.getElementById("scoreTable");
      if (table) table.style.height = `${window.innerHeight}px`;
      fitRowsToViewport();
    }
    document.addEventListener('DOMContentLoaded', () => {
      setFullHeight();
      buildTable();
      loadFromStorage();
      updateAllTotals();
      updateRanks();
    });
    window.addEventListener('resize', () => {
      setFullHeight();
      clipPlayerNamesToCell();
    });

    /* ---------------- Build table ---------------- */
    function buildTable() {
      const headerRow = document.getElementById('playerRow');
      headerRow.innerHTML = `
        <th class="hole-header"><button class="gear" title="Round settings" onclick="showRoundManagement()">â˜°</button></th>
        <th class="par-header">Par</th>
      `;
      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const savedName = localStorage.getItem(LS.name(pid)) || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        const th = document.createElement('th');
        th.setAttribute('data-player', pid);
        th.title = savedName;
        th.innerHTML = `
          <span class="player-name" data-full="${savedName}" title="${savedName}">${savedName}</span>
          <div id="total${pid}"></div>
        `;
        th.addEventListener('click', () => { window.currentPlayer = pid; openPlayerModalForHeader(pid); });
        headerRow.appendChild(th);
      }

      const body = document.getElementById('scoreBody');
      body.innerHTML = '';

      const firstNine = Math.min(9, holesCount);
      for (let h = 1; h <= firstNine; h++) body.appendChild(makeHoleRow(h));

      // OUT summary
      const trOut = document.createElement('tr');
      trOut.className = 'summary-row';
      trOut.appendChild(makeStickyCell('hole-cell', 'OUT'));
      const outPar = document.createElement('td'); outPar.className = 'par-cell'; outPar.setAttribute('data-sum', 'out-par');
      trOut.appendChild(outPar);
      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.setAttribute('data-sum', `out-P${p}`);
        trOut.appendChild(td);
      }
      body.appendChild(trOut);

      if (holesCount > 9) {
        for (let h = 10; h <= holesCount; h++) body.appendChild(makeHoleRow(h));
        // IN summary
        const trIn = document.createElement('tr');
        trIn.className = 'summary-row';
        trIn.appendChild(makeStickyCell('hole-cell', 'IN'));
        const inPar = document.createElement('td'); inPar.className = 'par-cell'; inPar.setAttribute('data-sum', 'in-par');
        trIn.appendChild(inPar);
        for (let p = 1; p <= playerCount; p++) {
          const td = document.createElement('td');
          td.setAttribute('data-sum', `in-P${p}`);
          trIn.appendChild(td);
        }
        body.appendChild(trIn);
      }

      clipPlayerNamesToCell();
      fitRowsToViewport();
    }
    function makeStickyCell(cls, text) {
      const td = document.createElement('td');
      td.className = cls;
      td.textContent = text;
      return td;
    }
    function makeHoleRow(h) {
      const tr = document.createElement('tr');

      const tdHole = document.createElement('td');
      tdHole.className = 'hole-cell';
      tdHole.textContent = String(h);
      tr.appendChild(tdHole);

      const tdPar = document.createElement('td');
      tdPar.className = 'par-cell';
      tdPar.setAttribute('data-hole', `H${h}`);
      tdPar.addEventListener('click', () => openNumberModal('par', tdPar));
      tdPar.textContent = '3';
      tr.appendChild(tdPar);

      for (let p = 1; p <= playerCount; p++) {
        const td = document.createElement('td');
        td.className = 'score-cell';
        td.setAttribute('data-player', `P${p}`);
        td.setAttribute('data-hole', `H${h}`);
        td.addEventListener('click', () => openNumberModal('score', td));
        tr.appendChild(td);
      }
      return tr;
    }

    /* ---------------- Storage load ---------------- */
    function loadFromStorage() {
      // Pars
      for (let h = 1; h <= holesCount; h++) {
        const savedPar = parseInt(localStorage.getItem(LS.par(h)) || '3', 10);
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) cell.textContent = String(savedPar);
      }
      // Scores
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const saved = localStorage.getItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && saved != null) td.textContent = saved;
        }
      }
      // Names
      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const headerName = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        const savedName = localStorage.getItem(LS.name(pid));
        if (headerName && savedName) {
          headerName.textContent = savedName;
          headerName.setAttribute('data-full', savedName);
          headerName.setAttribute('title', savedName);
        }
      }
      fitRowsToViewport();
    }

    /* ---------------- Popup: numeric input ---------------- */
    function openNumberModal(mode, td) {
      currentMode = mode;
      currentCell = td;
      currentHole = parseInt(td.getAttribute('data-hole')?.replace('H','') || '0', 10) || null;
      currentPlayer = td.getAttribute('data-player') || null;

      const modal = document.getElementById('popupModal');
      const options = document.getElementById('popupOptions');
      options.innerHTML = '';

      let title = '';
      if (mode === 'score') {
        const par = getPar(currentHole);
        title = `Hole ${currentHole} â€¢ Par ${par}`;
      } else {
        title = `Set Par â€¢ Hole ${currentHole}`;
      }
      document.getElementById('popupTitle').textContent = title;

      const currentVal = td.textContent.trim();
      const input = document.createElement('input');
      input.type = 'number';
      input.inputMode = 'numeric';
      input.autocomplete = 'off';
      input.autocorrect = 'off';
      input.spellcheck = false;
      input.value = currentVal;
      input.setAttribute('enterkeyhint', mode === 'score' ? 'next' : 'done');

      input.addEventListener('keydown', function(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          applyNumberEdit(this.value);
        }
      });
      input.addEventListener('blur', function() { applyNumberEdit(this.value); });
      options.appendChild(input);

      modal.style.display = 'block';
      showOverlay();

      setTimeout(() => {
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        try { input.select(); } catch (_) {}
      }, 0);
    }

    function applyNumberEdit(val) {
      if (!currentCell || !currentMode) return;

      const hole = currentHole;
      const player = currentPlayer;
      const trimmed = String(val ?? '').trim();

      if (currentMode === 'score') {
        if (trimmed === '') {
          currentCell.textContent = '';
          localStorage.removeItem(LS.score(player, hole));
        } else {
          const n = Math.max(0, parseInt(trimmed, 10) || 0);
          currentCell.textContent = String(n);
          localStorage.setItem(LS.score(player, hole), String(n));
        }
      } else if (currentMode === 'par') {
        if (trimmed === '') {
          currentCell.textContent = '3';
          localStorage.setItem(LS.par(hole), '3');
        } else {
          const n = Math.max(1, parseInt(trimmed, 10) || 3);
          currentCell.textContent = String(n);
          localStorage.setItem(LS.par(hole), String(n));
        }
      }

      closePopup();
      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
    }

    function closePopup() {
      document.getElementById('popupModal').style.display = 'none';
      hideOverlay();
      currentCell = null; currentHole = null; currentPlayer = null; currentMode = null;
    }

    /* ---------------- Round management ---------------- */
    function showRoundManagement() {
      const pcSel = document.getElementById('playerCount');
      const holesSel = document.getElementById('holesCount');
      const themeSel = document.getElementById('themeColorSelect');
      const sortBtn = document.getElementById('sortByRankBtn');

      pcSel.value = String(playerCount);
      holesSel.value = String(holesCount);
      themeSel.value = themeColor;
      sortBtn.classList.toggle('active', sortByRankEnabled);

      themeSel.style.color = getThemeTextColor(themeColor);
      Array.from(themeSel.options).forEach(opt => opt.style.color = getThemeTextColor(opt.value));

      document.getElementById('roundManagementModal').style.display = 'block';
      showOverlay();
    }
    function closeRoundManagement() {
      document.getElementById('roundManagementModal').style.display = 'none';
      hideOverlay();
    }
    function updatePlayerCount() {
      const val = parseInt(document.getElementById('playerCount').value, 10);
      playerCount = Math.min(8, Math.max(1, val));
      localStorage.setItem(LS.playerCount, String(playerCount));
      rebuildPreserving();
      updateRanks();
    }
    function updateHolesCount() {
      const val = parseInt(document.getElementById('holesCount').value, 10);
      holesCount = [9,18].includes(val) ? val : 18;
      localStorage.setItem(LS.holesCount, String(holesCount));
      rebuildPreserving();
      updateRanks();
    }
    function toggleSortByRank() {
      sortByRankEnabled = !sortByRankEnabled;
      localStorage.setItem(LS.sort, String(sortByRankEnabled));
      const btn = document.getElementById('sortByRankBtn');
      if (btn) btn.classList.toggle('active', sortByRankEnabled);
      if (sortByRankEnabled) applySortByRank();
      updateRanks();
    }
    function setThemeColor(value) {
      themeColor = value || 'blue';
      localStorage.setItem(LS.themeColor, themeColor);
      const themeSel = document.getElementById('themeColorSelect');
      if (themeSel) {
        themeSel.style.color = getThemeTextColor(themeColor);
        Array.from(themeSel.options).forEach(opt => opt.style.color = getThemeTextColor(opt.value));
      }
      updateRanks();
    }
    function resetScores() {
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          localStorage.removeItem(LS.score(`P${p}`, h));
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td) td.textContent = '';
        }
      }
      for (let h = 1; h <= holesCount; h++) {
        localStorage.setItem(LS.par(h), '3');
        const parCell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (parCell) parCell.textContent = '3';
      }
      updateAllTotals();
      updateRanks();
      closeRoundManagement();
    }

    /* ---------------- Player naming (Name | Emoji) ---------------- */
    function openPlayerModalForHeader(pid) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
      const currentName = header?.getAttribute('data-full') || header?.textContent || pid;
      window.currentPlayer = pid;
      if (emojiModeEnabled) openEmojiPlayerModal(currentName);
      else openTextPlayerModal(currentName);
    }

    function openTextPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">Ã—</span>
        <input type="text" id="playerNameInput"
               value="${(currentName || '').toUpperCase()}"
               autocapitalize="characters"
               inputmode="text"
               autocomplete="off" autocorrect="off" spellcheck="false"
               style="text-transform: uppercase;">
        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      const input = document.getElementById('playerNameInput');
      let primed = false;
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => {
          try { input.select(); } catch (_) {}
          try { input.setSelectionRange(0, input.value.length); } catch (_) {}
        });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', e => e.preventDefault());
      input.addEventListener('contextmenu', e => e.preventDefault());
      input.addEventListener('input', function(){ this.value = this.value.toUpperCase(); });
      input.addEventListener('keydown', function(e){
        if (e.key === 'Enter') {
          e.preventDefault();
          const newName = (this.value || '').trim().toUpperCase();
          if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
          closePlayerNameModal();
        }
      });
      input.addEventListener('blur', function(){
        const newName = (this.value || '').trim().toUpperCase();
        if (newName && window.currentPlayer) applyPlayerName(window.currentPlayer, newName);
      });
    }

    function openEmojiPlayerModal(currentName) {
      const modal = document.getElementById('playerNameModal');
      const favEmojis = [
        "ðŸ”","ðŸ©°","ðŸŒ¹","ðŸŒ°","ðŸ””",
        "ðŸ‘‘","ðŸŽ£","ðŸŒ»","ðŸ","ðŸ¦ˆ",
        "ðŸ¤¸ðŸ¼â€â™€ï¸","ðŸŽ","ðŸ•Šï¸","ðŸ§¶","ðŸ› ï¸",
        "ðŸƒâ€âž¡ï¸"
      ];
      const grid = favEmojis.map(e => `<button type="button" class="emoji-pick" data-emoji="${e}">${e}</button>`).join('');
      modal.innerHTML = `
        <h2>Player</h2>
        <span class="close-btn" onclick="closePlayerNameModal()">Ã—</span>
        <input type="text" id="emojiNameInput" value="${currentName || ''}"
               inputmode="text" placeholder="Pick an emoji" enterkeyhint="done"
               autocapitalize="off" autocomplete="off" autocorrect="off" spellcheck="false">
        <div class="emoji-grid">${grid}</div>
        <div id="bulkEmojiActions" class="bulk-actions">
          <div class="row">
            <button type="button" id="bulkCancelBtn" class="light">Cancel</button>
            <button type="button" id="bulkApplyBtn">Select</button>
          </div>
        </div>
        <div class="segmented-control">
          <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, window.currentPlayer)">
          <label for="playerMode-name">Name</label>
          <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, window.currentPlayer)">
          <label for="playerMode-emoji">Emoji</label>
        </div>
        <button onclick="handleRemovePlayer(this)" data-state="initial">Remove</button>
      `;
      modal.style.display = 'block';
      showOverlay();

      bulkEmojiMode = false;
      bulkEmojiSelection = [];
      modal.classList.remove('bulk-mode');

      const input = document.getElementById('emojiNameInput');

      let primed = false;
      const primeFocus = (e) => {
        if (primed) return;
        primed = true;
        e.preventDefault();
        try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
        requestAnimationFrame(() => {
          try { input.select(); } catch (_) {}
          try { input.setSelectionRange(0, input.value.length); } catch (_) {}
        });
      };
      input.addEventListener('pointerdown', primeFocus, { passive: false });
      input.addEventListener('touchstart', primeFocus, { passive: false });
      input.addEventListener('mousedown', primeFocus);
      input.addEventListener('mouseup', (e) => e.preventDefault());
      input.addEventListener('contextmenu', (e) => e.preventDefault());

      let autoClosed = false;
      input.addEventListener('input', function () {
        const sanitized = extractEmojis(this.value);
        if (sanitized !== this.value) this.value = sanitized;
        if (sanitized && !autoClosed && !bulkEmojiMode) {
          if (window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          autoClosed = true;
          closePlayerNameModal();
        }
      });
      input.addEventListener('keypress', function (e) {
        if (e.key === 'Enter' && !bulkEmojiMode) {
          const sanitized = extractEmojis((this.value || '').trim());
          if (sanitized && window.currentPlayer) applyPlayerName(window.currentPlayer, sanitized);
          closePlayerNameModal();
        }
      });

      attachEmojiGridInteractions();
    }

    function setEmojiMode(enabled, reopenForPlayerId = null) {
      emojiModeEnabled = !!enabled;
      localStorage.setItem(LS.emojiMode, emojiModeEnabled ? 'true' : 'false');
      syncDefaultNamesToMode();
      if (reopenForPlayerId) openPlayerModalForHeader(reopenForPlayerId);
      updateRanks();
    }
    function toggleEmojiMode() { setEmojiMode(!emojiModeEnabled); }

    function handleRemovePlayer(button) {
      if (button.dataset.state === 'initial') {
        button.textContent = 'Confirm';
        button.dataset.state = 'confirm';
      } else {
        if (window.currentPlayer) {
          removePlayer(window.currentPlayer);
          closePlayerNameModal();
        }
      }
    }

    function removePlayer(pid) {
      const idx = parseInt(pid.replace('P',''), 10) - 1;
      if (playerCount <= 1) { alert('At least one player must remain.'); return false; }

      // Remove header col
      const headerRow = document.getElementById('playerRow');
      if (headerRow.children[idx + 2]) headerRow.removeChild(headerRow.children[idx + 2]);
      // Remove body cells
      document.querySelectorAll('#scoreBody tr').forEach(row => {
        if (row.children[idx + 2]) row.removeChild(row.children[idx + 2]);
      });

      // Shift storage P(i+1)->Pi
      for (let p = idx + 2; p <= playerCount; p++) {
        const oldPid = `P${p}`, newPid = `P${p-1}`;
        const name = localStorage.getItem(LS.name(oldPid));
        if (name != null) { localStorage.setItem(LS.name(newPid), name); localStorage.removeItem(LS.name(oldPid)); }
        for (let h = 1; h <= holesCount; h++) {
          const v = localStorage.getItem(LS.score(oldPid, h));
          if (v != null) { localStorage.setItem(LS.score(newPid, h), v); localStorage.removeItem(LS.score(oldPid, h)); }
        }
      }
      playerCount -= 1;
      localStorage.setItem(LS.playerCount, String(playerCount));
      fitRowsToViewport();
      updateAllTotals();
      updateRanks();
      return true;
    }

    function applyPlayerName(pid, newName) {
      const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
      if (!header) return;
      const totalDiv = header.querySelector('div[id^="total"]');
      const totalTxt = totalDiv ? totalDiv.textContent : '';
      const rankEl = header.querySelector('small');
      const rankHTML = rankEl ? rankEl.outerHTML : '';
      header.innerHTML = `<span class="player-name" data-full="${newName}" title="${newName}">${newName}</span><div id="total${pid}">${totalTxt}</div>${rankHTML}`;
      header.setAttribute('data-player', pid);
      localStorage.setItem(LS.name(pid), newName);
      clipPlayerNamesToCell();
      updateRanks();
    }

    function closePlayerNameModal() {
      const modal = document.getElementById('playerNameModal');
      // Reset remove button state
      const btn = modal.querySelector('button[onclick^="handleRemovePlayer"]');
      if (btn) { btn.textContent = 'Remove'; btn.dataset.state = 'initial'; }
      modal.style.display = 'none';
      hideOverlay();
    }

    function attachEmojiGridInteractions() {
      const modal = document.getElementById('playerNameModal');
      const buttons = Array.from(modal.querySelectorAll('.emoji-pick'));
      const bulkBar = modal.querySelector('#bulkEmojiActions');
      const seg = modal.querySelector('.segmented-control');
      const emojiInput = modal.querySelector('#emojiNameInput');

      const enterBulkEmojiMode = () => {
        if (bulkEmojiMode) return;
        bulkEmojiMode = true;
        bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'block';
        if (seg) seg.style.display = 'none';
        if (emojiInput) emojiInput.style.display = 'none';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.add('bulk-mode');
      };
      const exitBulkEmojiMode = () => {
        bulkEmojiMode = false;
        bulkEmojiSelection = [];
        if (bulkBar) bulkBar.style.display = 'none';
        if (seg) seg.style.display = '';
        if (emojiInput) emojiInput.style.display = '';
        buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
        modal.classList.remove('bulk-mode');
      };
      const renumberSelection = () => {
        buttons.forEach(b => { if (b.classList.contains('selected')) b.setAttribute('data-order', ''); });
        bulkEmojiSelection.forEach((emoji, i) => {
          const b = buttons.find(btn => btn.getAttribute('data-emoji') === emoji);
          if (b) b.setAttribute('data-order', String(i + 1));
        });
      };
      const toggleEmojiSelection = (btn) => {
        const emoji = btn.getAttribute('data-emoji');
        const idx = bulkEmojiSelection.indexOf(emoji);
        if (idx !== -1) {
          bulkEmojiSelection.splice(idx, 1);
          btn.classList.remove('selected');
          btn.removeAttribute('data-order');
        } else {
          if (bulkEmojiSelection.length >= bulkMaxPlayers) return;
          bulkEmojiSelection.push(emoji);
          btn.classList.add('selected');
        }
        renumberSelection();
      };
      const applyBulkEmojiPlayers = (selected) => {
        const targetCount = Math.min(bulkMaxPlayers, selected.length);
        if (targetCount < 1) return;
        emojiModeEnabled = true;
        localStorage.setItem(LS.emojiMode, 'true');
        playerCount = targetCount;
        localStorage.setItem(LS.playerCount, String(playerCount));
        rebuildPreserving();
        for (let i = 1; i <= targetCount; i++) {
          applyPlayerName(`P${i}`, selected[i - 1]);
        }
        exitBulkEmojiMode();
        closePlayerNameModal();
      };

      const cancelBtn = modal.querySelector('#bulkCancelBtn');
      const applyBtn = modal.querySelector('#bulkApplyBtn');
      if (cancelBtn) cancelBtn.addEventListener('click', () => exitBulkEmojiMode());
      if (applyBtn) applyBtn.addEventListener('click', () => {
        if (bulkEmojiSelection.length > 0) applyBulkEmojiPlayers(bulkEmojiSelection);
      });

      buttons.forEach(btn => {
        btn.addEventListener('click', () => {
          if (bulkEmojiMode) toggleEmojiSelection(btn);
          else {
            const emoji = btn.getAttribute('data-emoji');
            if (emoji && window.currentPlayer) {
              applyPlayerName(window.currentPlayer, emoji);
              closePlayerNameModal();
            }
          }
        });
        // Long-press to enter bulk (500ms)
        let pressTimer = null;
        const start = () => {
          if (bulkEmojiMode) return;
          clearTimeout(pressTimer);
          pressTimer = setTimeout(() => enterBulkEmojiMode(), 500);
        };
        const cancel = () => { clearTimeout(presstimer); };
        btn.addEventListener('pointerdown', start);
        btn.addEventListener('pointerup', cancel);
        btn.addEventListener('pointerleave', cancel);
        btn.addEventListener('touchstart', start, { passive: true });
        btn.addEventListener('touchend', cancel);
        btn.addEventListener('touchcancel', cancel);
        btn.addEventListener('mousedown', start);
        btn.addEventListener('mouseup', cancel);
        btn.addEventListener('mouseleave', cancel);
      });
    }

    function syncDefaultNamesToMode() {
      for (let i = 1; i <= playerCount; i++) {
        const pid = `P${i}`;
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (!header) continue;
        const displayed = (header.getAttribute('data-full') || header.textContent || '').trim();
        const stored = localStorage.getItem(LS.name(pid));
        const current = stored != null ? stored : displayed;
        let newName = current;

        if (emojiModeEnabled) {
          const m = /^P(\d{1,2})$/i.exec(current);
          if (m) {
            const n = parseInt(m[1], 10);
            if (n >= 0 && n <= 9) newName = numberToKeycap(n);
          } else if (stored == null && i <= 9) {
            newName = numberToKeycap(i);
          }
        } else {
          const n = keycapToNumber(current);
          if (n !== null) newName = `P${n}`;
        }

        if (newName !== current) {
          applyPlayerName(pid, newName);
        } else if (stored == null) {
          localStorage.setItem(LS.name(pid), current);
        }
      }
      clipPlayerNamesToCell();
    }

    /* ---------------- Helpers: fit rows, totals, ranks ---------------- */
    function fitRowsToViewport() {
      const table = document.getElementById('scoreTable');
      const header = table.querySelector('thead');
      const headerH = header ? header.getBoundingClientRect().height : 0;
      const rows = document.querySelectorAll('#scoreBody tr').length;
      const viewportH = window.innerHeight;
      if (rows > 0) {
        const avail = Math.max(1, viewportH - headerH - 1);
        const rowH = Math.max(24, Math.floor(avail / rows));
        document.documentElement.style.setProperty('--row-h', rowH + 'px');
      }
    }

    function getPar(h) {
      const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
      const v = parseInt(cell?.textContent || '3', 10);
      return Number.isFinite(v) ? v : 3;
    }
    function getScore(player, h) {
      const td = document.querySelector(`td.score-cell[data-player="${player}"][data-hole="H${h}"]`);
      const v = parseInt(td?.textContent || '', 10);
      return Number.isFinite(v) ? v : null;
    }
    function hasAnyEntry() {
      return Array.from(document.querySelectorAll('.score-cell')).some(td => td.textContent.trim() !== '');
    }

    function updateAllTotals() {
      const outRange = [...Array(Math.min(9, holesCount)).keys()].map(i => i + 1);
      const inRange  = (holesCount > 9) ? [...Array(holesCount - 9).keys()].map(i => i + 10) : [];

      const parOut = outRange.reduce((s, h) => s + getPar(h), 0);
      const parIn  = inRange.reduce((s, h) => s + getPar(h), 0);

      const setSumCell = (key, val) => {
        const el = document.querySelector(`[data-sum="${key}"]`);
        if (el) el.textContent = String(val);
      };
      setSumCell('out-par', parOut);
      if (holesCount > 9) setSumCell('in-par', parIn);

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const sumOut = outRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const sumIn  = inRange.reduce((s, h) => s + (getScore(pid, h) ?? 0), 0);
        const played = [...outRange, ...inRange];
        let playedPar = 0, playedStrokes = 0;
        for (const h of played) {
          const sc = getScore(pid, h);
          if (sc != null) { playedStrokes += sc; playedPar += getPar(h); }
        }
        setSumCell(`out-${pid}`, sumOut);
        if (holesCount > 9) setSumCell(`in-${pid}`, sumIn);

        const totalDiv = document.getElementById(`total${pid}`);
        if (totalDiv) {
          if (playedStrokes > 0) {
            const toPar = (playedPar === 0) ? 0 : (playedStrokes - playedPar);
            const tp = toPar === 0 ? 'E' : (toPar > 0 ? `+${toPar}` : `${toPar}`);
            totalDiv.textContent = `${playedStrokes} (${tp})`;
          } else {
            totalDiv.textContent = '';
          }
        }
      }
    }

    function updateRanks() {
      const table = document.getElementById('scoreTable');
      const headers = Array.from(table.querySelectorAll('thead th')).slice(2);
      const count = headers.length;

      if (count >= 7) table.classList.add('small-scores');
      else table.classList.remove('small-scores');

      // Clear backgrounds and ranks
      headers.forEach(h => { h.style.background = ''; });
      headers.forEach(h => {
        let next = h.querySelector('div[id^="total"]')?.nextSibling;
        while (next && next.nodeName === 'SMALL') {
          const rm = next; next = next.nextSibling; rm.parentElement.removeChild(rm);
        }
      });

      if (!hasAnyEntry()) { clipPlayerNamesToCell(); return; }

      if (sortByRankEnabled && count > 1) applySortByRank(true);

      const hdrs = Array.from(table.querySelectorAll('thead th')).slice(2);
      const totals = hdrs.map(h => {
        const pid = h.getAttribute('data-player');
        let played = 0;
        for (let i = 1; i <= holesCount; i++) {
          const sc = getScore(pid, i);
          if (sc != null) played += sc;
        }
        return { h, pid, played };
      });

      // Lowest score = best
      const sorted = [...totals].sort((a, b) => a.played - b.played);
      const groups = [];
      for (const item of sorted) {
        const last = groups[groups.length - 1];
        if (!last || last.score !== item.played) groups.push({ score: item.played, members: [item.pid] });
        else last.members.push(item.pid);
      }

      const { h: H, s: S } = getThemeHS(themeColor);
      const Lmax = 82, minRange = 18, maxRange = 44;
      const effective = groups.length;
      const normalized = Math.min(1, Math.max(0, (effective - 1) / (8 - 1)));
      const range = Math.round(minRange + (maxRange - minRange) * normalized);
      const Lmin = Math.max(28, Lmax - range);

      groups.forEach((group, g) => {
        const ratio = (effective === 1) ? 0 : g / (effective - 1); // best group -> darkest
        const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
        const Ltop = Math.max(18, L - 10);
        const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
        group.members.forEach(pid => {
          const th = document.querySelector(`#scoreTable thead th[data-player="${pid}"]`);
          if (th) th.style.background = gradient;
        });
      });

      // Rank labels
      const uniqueScoresAsc = Array.from(new Set(sorted.map(s => s.played)));
      const rankByScore = new Map(uniqueScoresAsc.map((score, i) => [score, i + 1]));
      totals.forEach(({ h, played }) => {
        const small = document.createElement('small');
        small.textContent = ordinalSuffixOf(rankByScore.get(played) || 1);
        h.appendChild(small);
      });

      clipPlayerNamesToCell();
    }

    function ordinalSuffixOf(i) {
      const j = i % 10, k = i % 100;
      if (j === 1 && k !== 11) return i + "st";
      if (j === 2 && k !== 12) return i + "nd";
      if (j === 3 && k !== 13) return i + "rd";
      return i + "th";
    }

    function clipPlayerNamesToCell() {
      const seg = (typeof Intl !== 'undefined' && Intl.Segmenter)
        ? new Intl.Segmenter('en', { granularity: 'grapheme' })
        : null;
      const els = document.querySelectorAll('#scoreTable thead th .player-name');
      els.forEach(el => {
        const full = el.getAttribute('data-full') ?? el.textContent;
        el.setAttribute('data-full', full);
        el.textContent = full;

        if (el.scrollWidth <= el.clientWidth) return;

        const clusters = seg ? Array.from(seg.segment(full), s => s.segment) : Array.from(full);
        let low = 0, high = clusters.length, best = 0;
        while (low <= high) {
          const mid = Math.floor((low + high) / 2);
          el.textContent = clusters.slice(0, mid).join('');
          if (el.scrollWidth <= el.clientWidth) { best = mid; low = mid + 1; }
          else high = mid - 1;
        }
        el.textContent = clusters.slice(0, best).join('');
      });
    }

    function applySortByRank(silent = false) {
      const headerRow = document.getElementById('playerRow');
      const rows = Array.from(document.querySelectorAll('#scoreBody tr'));

      const headers = Array.from(headerRow.children).slice(2);
      if (headers.length <= 1 || !hasAnyEntry()) return;

      const players = headers.map((th, idx) => {
        const pid = th.getAttribute('data-player');
        let played = 0;
        for (let h = 1; h <= holesCount; h++) {
          const sc = getScore(pid, h);
          if (sc != null) played += sc;
        }
        return { idx, pid, played, th };
      });

      const order = [...players].sort((a,b) => a.played - b.played || a.idx - b.idx).map(p => p.idx);
      if (order.every((v, i) => v === i)) { if (!silent) updateRanks(); return; }

      // Reorder headers (keep first 2 fixed)
      const fixed = Array.from(headerRow.children).slice(0,2);
      const moving = Array.from(headerRow.children).slice(2);
      headerRow.innerHTML = '';
      fixed.forEach(n => headerRow.appendChild(n));
      order.forEach(i => headerRow.appendChild(moving[i]));

      // Reorder each body row
      rows.forEach(tr => {
        const cells = Array.from(tr.children);
        const fixed2 = cells.slice(0,2);
        const movingCells = cells.slice(2);
        tr.innerHTML = '';
        fixed2.forEach(c => tr.appendChild(c));
        order.forEach(i => tr.appendChild(movingCells[i]));
      });

      if (!silent) updateRanks();
      fitRowsToViewport();
    }

    /* ---------------- Rebuild preserving ---------------- */
    function rebuildPreserving() {
      const names = {};
      for (let p = 1; p <= 8; p++) {
        const k = LS.name(`P${p}`);
        const v = localStorage.getItem(k);
        if (v != null) names[`P${p}`] = v;
      }
      const pars = {};
      for (let h = 1; h <= 18; h++) {
        const k = LS.par(h);
        const v = localStorage.getItem(k);
        if (v != null) pars[h] = v;
      }
      const scores = {};
      for (let p = 1; p <= 8; p++) {
        for (let h = 1; h <= 18; h++) {
          const k = LS.score(`P${p}`, h);
          const v = localStorage.getItem(k);
          if (v != null) scores[`${p}-${h}`] = v;
        }
      }

      buildTable();

      for (let p = 1; p <= playerCount; p++) {
        const pid = `P${p}`;
        const nm = names[pid] || (emojiModeEnabled && p <= 9 ? numberToKeycap(p) : pid);
        localStorage.setItem(LS.name(pid), nm);
        const header = document.querySelector(`#scoreTable thead th[data-player="${pid}"] .player-name`);
        if (header) {
          header.textContent = nm;
          header.setAttribute('data-full', nm);
          header.setAttribute('title', nm);
        }
      }
      for (let h = 1; h <= holesCount; h++) {
        const v = pars[h] ?? '3';
        const cell = document.querySelector(`.par-cell[data-hole="H${h}"]`);
        if (cell) {
          cell.textContent = v;
          localStorage.setItem(LS.par(h), v);
        }
      }
      for (let p = 1; p <= playerCount; p++) {
        for (let h = 1; h <= holesCount; h++) {
          const key = `${p}-${h}`;
          const v = scores[key];
          const td = document.querySelector(`td.score-cell[data-player="P${p}"][data-hole="H${h}"]`);
          if (td && v != null) {
            td.textContent = v;
            localStorage.setItem(LS.score(`P${p}`, h), v);
          }
        }
      }

      updateAllTotals();
      if (sortByRankEnabled) applySortByRank(true);
      updateRanks();
      fitRowsToViewport();
    }

    /* ---------------- Overlay ---------------- */
    function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
    function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }
    document.getElementById('overlay').addEventListener('click', () => {
      closeRoundManagement();
      closePlayerNameModal();
      closePopup();
    });
  </script>
</body>
</html>