<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Meta -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- Title + Font -->
    <title>Scorecard</title>
    <link href="https://fonts.googleapis.com/css?family=Economica&display=swap" rel="stylesheet">

<style>
  /* --------------------------------------- Base / Layout --------------------------------------- */
  html,
  body {
    height: 100%;
    margin: 0;
    padding: 0;
    overflow: hidden; /* keep table area scrollable, not page */
  }

  body {
    font-family: 'Economica', sans-serif;
    font-size: 22px;
    max-width: 1200px;
    margin-left: auto;
    margin-right: auto;
    background: linear-gradient(135deg, #f0f2f5 0%, #ffffff 100%) no-repeat;
    background-size: cover;
    display: flex;
    flex-direction: column;
  }

  h1 {
    text-align: center;
  }

  /* Scrollable area for score rows (header stays sticky) */
  .score-container {
    flex: 1;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
  }

  /* --------------------------------------- Table --------------------------------------- */
  table {
    width: 100%;
    table-layout: fixed;
    border-collapse: collapse;
    font-size: 20px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  }

  table th,
  table td {
    border: none;
    text-align: center;
    padding: 5px;
    word-wrap: break-word;
    cursor: pointer;
    border-bottom: 1px solid rgba(200, 200, 200, 0.3);
  }

  table th {
    background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
    color: white;
  }

  /* Round number / header control column */
  table th:first-child {
    background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
    font-weight: bold;
    width: 30px;
    min-width: 30px;
    max-width: 30px;
    overflow: hidden;
    color: white;
    border-bottom: 1px solid #666;
  }

  table td:first-child {
    background: #3b3b3b;
    font-weight: bold;
    width: 30px;
    min-width: 30px;
    max-width: 30px;
    overflow: hidden;
    color: white;
    border-bottom: 1px solid #666;
  }

  /* Header metrics */
  .sticky-header th {
    height: 80px;
    font-family: 'Economica', sans-serif;
    font-size: 22px;
  }

  .sticky-header th span.score {
    font-size: 22px;
    font-family: 'Economica', sans-serif;
  }

  .sticky-header th small {
    font-size: 16px;
    font-family: 'Economica', sans-serif;
    color: rgba(255, 255, 255, 0.8);
  }

  /* Removed the zero-height, zero line-height rule that was collapsing cells and misaligning numbers */
  #scoreBody tr td:not(:first-child) {
    font-weight: bold;
    vertical-align: middle; /* ensure cells align content vertically */
  }

  /* --------------------------------------- Inputs --------------------------------------- */
  table input {
    width: 100%;
    box-sizing: border-box;
    padding: 8px;
    text-align: center;
    font-size: inherit;
    font-family: 'Economica', sans-serif;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    background: #ffffff;
    box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.05);
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  /* Default placeholders: slightly larger (now vertically centered) */
  table input::placeholder {
    font-family: 'Economica', sans-serif;
    font-size: 18px; /* keep a touch larger */
    line-height: inherit; /* match input line-height for perfect vertical centering */
    text-align: center;
    color: #6b7280;
    opacity: 0.8;
  }

  /* Vendor placeholders to ensure vertical centering everywhere */
  table input::-webkit-input-placeholder {
    line-height: inherit;
  }

  table input::-moz-placeholder {
    line-height: inherit;
  }

  table input:-ms-input-placeholder {
    line-height: inherit;
  }

  table input::-ms-input-placeholder {
    line-height: inherit;
  }

  table input:focus {
    outline: none;
    border-color: #262626;
    box-shadow: 0 0 5px rgba(51, 51, 51, 0.5);
  }

  /* Remove spinners for number inputs on webkit */
  table input[type="number"]::-webkit-outer-spin-button,
  table input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }

  /* Fixed height for number inputs */
  table input[type="number"] {
    width: 100%;
    box-sizing: border-box;
    height: 40px;
    line-height: 40px; /* makes entered text and placeholder vertically centered */
    padding: 0 8px;
    text-align: center;
    font-size: inherit;
    font-family: 'Economica', sans-serif;
    border: 1px solid #d0d7de;
    border-radius: 6px;
    background: #ffffff;
    box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
  }

  /* Number input placeholder metrics (inherit line-height for centering) */
  table input[type="number"]::placeholder {
    font-family: 'Economica', sans-serif;
    font-size: 18px;
    line-height: inherit; /* critical for vertical centering */
    text-align: center;
    color: #6b7280;
    opacity: 0.8;
  }

  /* Vendor versions */
  table input[type="number"]::-webkit-input-placeholder {
    line-height: inherit;
  }

  table input[type="number"]::-moz-placeholder {
    line-height: inherit;
  }

  table input[type="number"]:-ms-input-placeholder {
    line-height: inherit;
  }

  table input[type="number"]::-ms-input-placeholder {
    line-height: inherit;
  }

  /* Sticky header inputs: match old input metrics */
  .sticky-header #inputRow input[type="number"] {
    height: 40px;
    line-height: 40px;
    padding: 0 8px;
    font-size: inherit; /* table font-size is 20px */
  }

  /* Sticky header placeholders: larger but still “light” (and centered) */
  .sticky-header #inputRow input[type="number"]::placeholder {
    font-family: 'Economica', sans-serif;
    color: rgba(107, 114, 128, 0.5);
    opacity: 0.5;
    line-height: inherit; /* ensure centering here too */
  }

  .sticky-header #inputRow input[type="number"]::-webkit-input-placeholder {
    opacity: 0.5;
    color: rgba(107, 114, 128, 0.5);
    line-height: inherit;
  }

  .sticky-header #inputRow input[type="number"]::-moz-placeholder {
    opacity: 0.5;
    color: rgba(107, 114, 128, 0.5);
    line-height: inherit;
  }

  .sticky-header #inputRow input[type="number"]:-ms-input-placeholder {
    opacity: 0.5;
    color: rgba(107, 114, 128, 0.5);
    line-height: inherit;
  }

  .sticky-header #inputRow input[type="number"]::-ms-input-placeholder {
    opacity: 0.5;
    color: rgba(107, 114, 128, 0.5);
    line-height: inherit;
  }

  /* --------------------------------------- Modals / Overlay --------------------------------------- */
  .popup-modal {
    display: none;
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: #ffffff;
    border: none;
    padding: 5px 20px 20px 20px;
    z-index: 1000;
    width: 200px;
    max-width: 90%;
    text-align: center;
    font-family: 'Economica', sans-serif;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
    border-radius: 10px;
  }

  /* Ensure player modal is centered like the others */
  #playerManagementModal {
    top: 50%;
    transform: translate(-50%, -50%);
  }

  .popup-modal input[type="text"] {
    font-size: 24px;
    padding: 10px;
    width: 100%;
    box-sizing: border-box;
    margin: 5px 0;
    text-align: center;
    font-family: 'Economica', sans-serif;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: #f8f9fa;
  }

  .popup-modal input[type="text"]:focus {
    outline: none;
    border: 1px solid #262626;
  }

  .popup-modal select {
    font-size: 24px;
    padding: 10px;
    margin: 5px 0;
    font-family: 'Economica', sans-serif;
    border: 1px solid #ddd;
    border-radius: 6px;
    background: #f8f9fa;
    width: 100%;
    box-sizing: border-box;
  }

  /* Slightly stronger border for round-management select */
  #roundManagementModal select {
    border: 1px solid #333;
  }

  .popup-modal button {
    font-size: 24px;
    padding: 10px 20px;
    margin: 5px 0;
    cursor: pointer;
    font-family: 'Economica', sans-serif;
    background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
    color: white;
    border: none;
    border-radius: 6px;
    transition: background 0.2s;
    width: 100%;
    box-sizing: border-box;
  }

  /* Destructive confirm state */
  .popup-modal button[data-state="confirm"] {
    background: linear-gradient(to bottom, #e63946 0%, #c62835 100%);
  }

  /* Light variant (Cancel / toggle-like) */
  .popup-modal button.light {
    background: #f8f9fa;
    color: #0f172a;
    border: 1px solid #262626;
  }

  /* Sort-by-rank button styles + active state */
  #roundManagementModal button#sortByRankBtn {
    background: #f8f9fa;
    color: #0f172a;
    border: 1px solid #262626;
  }

  #roundManagementModal button#sortByRankBtn.active {
    background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
    color: #ffffff;
    border: 1px solid #262626;
  }

  /* Modal headings spacing */
  #playerManagementModal h2,
  #roundManagementModal h2,
  #deleteRoundModal h2 {
    margin-top: 15px;
    margin-bottom: 15px;
    padding: 0;
  }

  /* --------------------------------------- Segmented control (Name/Emoji, Low/High) --------------------------------------- */
  .segmented-control {
    display: flex;
    width: 100%;
    box-sizing: border-box;
    margin: 5px 0;
    background: #f8f9fa;
    border-radius: 6px;
    overflow: hidden;
    border: 1px solid #262626; /* crisp border without seams */
    box-shadow: none;
    -webkit-background-clip: padding-box;
    background-clip: padding-box;
  }

  .segmented-control input[type="radio"] {
    display: none;
  }

  .segmented-control label {
    flex: 1 1 0;
    padding: 10px 0;
    text-align: center;
    font-size: 24px;
    font-family: 'Economica', sans-serif;
    cursor: pointer;
    user-select: none;
    background: #f8f9fa;
    margin: 0;
  }

  .segmented-control input[type="radio"]:checked + label {
    background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
    color: #fff;
  }

  /* Close X button */
  .close-btn {
    position: absolute;
    top: 0px;
    right: 0px;
    font-size: 48px;
    color: #000000;
    cursor: pointer;
    background: none;
    border: none;
    padding: 0;
    line-height: 1;
    width: 40px;
    height: 40px;
    text-align: center;
    transition: color 0.2s ease;
  }

  /* Emoji scaling helper (if needed) */
  .scaled-emoji {
    transform: scale(.75);
    transform-origin: center;
    display: inline-block;
  }

  /* Remove tap highlight (mobile) */
  * {
    -webkit-tap-highlight-color: transparent;
  }

  /* Overlay behind modals */
  #overlay {
    display: none;
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.5);
    z-index: 999;
    cursor: pointer;
  }

  /* --------------------------------------- Sticky header --------------------------------------- */
  .sticky-header {
    position: sticky;
    top: 0;
    z-index: 10;
    background: #fff;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
  }

  .sticky-header table {
    margin-bottom: 0;
  }

  /* Make main table flush to header */
  #scoreTable {
    margin-top: 0;
  }

  /* Drag feedback */
  th.dragging {
    opacity: 0.5;
    background: rgba(0, 0, 0, 0.2);
  }

  th.drag-over {
    border-left: 2px solid #333;
  }

  /* --------------------------------------- Emoji grid (player emoji picker) --------------------------------------- */
  .emoji-grid {
    --emoji-gap: 8px;
    display: grid;
    grid-template-columns: repeat(4, minmax(0, 1fr));
    gap: var(--emoji-gap);
    padding: 0;
    margin: 5px 0;
    width: 100%;
    box-sizing: border-box;
    user-select: none;
    -webkit-user-select: none;
  }

  .emoji-grid .emoji-pick {
    background: linear-gradient(to bottom, #262626 0%, #3b3b3b 100%);
    color: #ffffff;
    border: none;
    border-radius: 6px;
    font-family: 'Economica', sans-serif;
    font-size: 22px;
    display: grid;
    place-items: center;
    width: 100%;
    aspect-ratio: 1 / 1;
    padding: 0;
    margin: 0;
    line-height: 1;
    cursor: pointer;
    transition: transform 0.05s ease, filter 0.1s ease;
    box-sizing: border-box;
    position: relative;
  }

  .emoji-grid .emoji-pick:active {
    transform: scale(0.95);
    filter: brightness(1.05);
  }

  /* Selected state with dim overlay (number sits above) */
  .emoji-grid .emoji-pick.selected {
    box-shadow: 0 0 0 2px #262626 inset;
  }

  .emoji-grid .emoji-pick.selected::before {
    content: "";
    position: absolute;
    inset: 0;
    background: rgba(0, 0, 0, 0.35);
    border-radius: 6px;
    pointer-events: none;
    z-index: 1;
  }

  .emoji-grid .emoji-pick.selected::after {
    content: attr(data-order);
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -55%);
    font-size: 28px;
    font-weight: 700;
    color: #fff;
    text-shadow: 0 2px 8px rgba(0,0,0,0.7), 0 0 3px rgba(0,0,0,0.7);
    pointer-events: none;
    z-index: 2;
  }

  /* Bulk actions (shown during emoji multi-select) */
  .bulk-actions {
    display: none;
    margin: 5px 0 0 0;
    width: 100%;
  }

  .bulk-actions .row {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
    align-items: center;
    width: 100%;
  }

  /* Suppress iOS callout on these text inputs */
  #emojiNameInput {
    -webkit-touch-callout: none;
  }

  #playerNameInput {
    -webkit-touch-callout: none;
  }

  /* --------------------------------------- Responsive: small score font for many players --------------------------------------- */
  @media (max-width: 480px) {
    .sticky-header.small-scores th span.score {
      font-size: 18px;
      line-height: 1.2;
    }

    #scoreTable.small-scores thead th {
      padding: 3px;
    }

    #scoreTable.small-scores thead th span.score {
      font-size: 16px;
      line-height: 1.2;
    }

    #scoreTable.small-scores thead th small {
      font-size: 12px;
    }

    #scoreTable.small-scores tbody td {
      font-size: 16px;
    }

    /* Sticky header inputs compact (7–8 players) */
    .sticky-header.small-scores #inputRow input[type="number"] {
      font-size: 14px;
      height: 40px;
      line-height: 40px;
      padding: 0 6px;
    }

    .sticky-header.small-scores #inputRow input[type="number"]::placeholder {
      font: inherit;
      line-height: inherit; /* keep centered on compact size */
    }

    .sticky-header.small-scores th small {
      font-size: 16px;
    }

    /* Smaller zero SVG for 7–8 players on mobile (stay centered) */
    #scoreTable.small-scores tbody td .zero-icon {
      width: 13px;
      height: 13px;
    }
  }

  /* Center text + remove native arrow for Players dropdown */
  #roundManagementModal select#playerCount {
    text-align: center;
    text-align-last: center;
    -moz-text-align-last: center;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image: none !important;
    background-color: #f8f9fa;
    padding-right: 12px;
  }

  #roundManagementModal select#playerCount::-ms-expand {
    display: none;
  }

  #roundManagementModal select#playerCount option {
    text-align: center;
  }

  /* Center text + remove native arrow for Theme Colour dropdown */
  #roundManagementModal select#themeColorSelect {
    text-align: center;
    text-align-last: center;
    -moz-text-align-last: center;
    -webkit-appearance: none;
    -moz-appearance: none;
    appearance: none;
    background-image: none !important;
    background-color: #f8f9fa;
    padding-right: 12px;
  }

  #roundManagementModal select#themeColorSelect::-ms-expand {
    display: none;
  }

  #roundManagementModal select#themeColorSelect option {
    text-align: center; /* fixed stray period */
  }

  /* Spacing tweaks inside player modal for bulk mode */
  #playerManagementModal .segmented-control {
    margin-top: 5px;
  }

  #playerManagementModal .emoji-grid {
    margin: 5px 0 10px;
  }

  #playerManagementModal.bulk-mode .emoji-grid {
    margin-bottom: 5px;
  }

  #playerManagementModal .bulk-actions {
    margin-top: 0;
  }

  /* Truncate long player names (header only): no ellipsis, no half glyphs (JS clips) */
  #playerRow th .player-name {
    display: block;
    max-width: 100%;
    overflow: hidden;
    white-space: nowrap;
    text-overflow: clip; /* no "..." */
  }

  /* Only shrink player names when 7+ players (JS adds .small-scores on header/table) */
  .sticky-header.small-scores #playerRow th .player-name {
    font-size: 18px;
    line-height: 1.1;
  }

  /* --------------------------------------- Inline score edit visuals --------------------------------------- */
#scoreBody td.score-cell {
  position: relative;
  user-select: none;
  -webkit-user-select: none;
  -ms-user-select: none;
  -moz-user-select: none;
  -webkit-touch-callout: none;
  vertical-align: middle;
  padding: 0; /* Remove padding to prevent offset */
  height: 35px; /* Fixed height for consistency */
  min-height: 35px; /* Ensure consistent height */
  line-height: 35px; /* Match height for text alignment */
}

  /* Perfect centering of score text/icon when not editing (no translate) */
  #scoreBody td.score-cell .score-display {
    position: static;
    transform: none;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: max-content;
    max-width: 100%;
  }

  /* Zero SVG base size + centering */
  #scoreBody td.score-cell .zero-icon {
    display: block;
    width: 15px;
    height: 15px;
  }

  #scoreBody td.score-cell.score-edit-selected {
    outline: 2px solid #000;
    outline-offset: -2px;
  }

  #scoreBody td.score-cell .inline-score-input {
    position: absolute;
    inset: 0;
    z-index: 2; /* sits above score-display; we keep display visible and mirror into it */
    width: 100%;
    height: 100%;
    border: none;
    outline: none;
    background: transparent; /* show display underneath */
    font: inherit;
    text-align: center;
    padding: 0;
    margin: 0;
    /* Hide input glyphs so only the perfectly-centered display is visible */
    color: transparent;
    caret-color: transparent;
    user-select: none;
    -webkit-user-select: none;
    -moz-appearance: textfield;
  }

  #scoreBody td.score-cell .inline-score-input::-webkit-outer-spin-button,
  #scoreBody td.score-cell .inline-score-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
</style>
</head>
<body>
    <!-- Hidden form (lets mobile Go/Done submit when all inputs filled) -->
    <form id="roundForm" onsubmit="handleRoundFormSubmit(event)" style="position:absolute; left:-9999px; width:1px; height:1px; overflow:hidden;">
        <button type="submit" tabindex="-1" aria-hidden="true"></button>
    </form>

    <!-- Sticky header with player names + input row -->
    <div class="sticky-header">
        <table>
            <thead>
                <tr id="playerRow">
                    <th>#</th>
                </tr>
            </thead>
            <tbody>
                <tr id="inputRow">
                    <td>＋</td>
                </tr>
            </tbody>
        </table>
    </div>

    <!-- Scrollable scores table -->
    <div class="score-container">
        <table id="scoreTable">
            <tbody id="scoreBody"></tbody>
        </table>
    </div>

    <!-- Modals -->
    <div id="playerManagementModal" class="popup-modal"></div>
    <div id="roundManagementModal" class="popup-modal"></div>
    <div id="deleteRoundModal" class="popup-modal"></div>

    <!-- Overlay -->
    <div id="overlay"></div>

    <script>
        /* ---------------------------------------
           Globals / Bootstrapping
        --------------------------------------- */
        let players = [];
        let rounds = [];

        if (!localStorage.getItem('initialized')) {
            players = [
                { name: "P1", totalScore: 0, roundScores: [] },
                { name: "P2", totalScore: 0, roundScores: [] },
                { name: "P3", totalScore: 0, roundScores: [] },
                { name: "P4", totalScore: 0, roundScores: [] }
            ].map(p => ({ ...p, name: p.name.toUpperCase() }));
            rounds = [];
            localStorage.setItem('initialized', 'true');
            localStorage.setItem('players', JSON.stringify(players));
            localStorage.setItem('rounds', JSON.stringify(rounds));
        } else {
            players = JSON.parse(localStorage.getItem('players')) || [];
            rounds = JSON.parse(localStorage.getItem('rounds')) || [];
        }

        let scoringMode = localStorage.getItem('scoringMode') || 'lowest';
        let unsubmittedScores = JSON.parse(localStorage.getItem('unsubmittedScores')) || {};
        let sortByRankEnabled = localStorage.getItem('sortByRankEnabled') === 'true';
        let emojiModeEnabled = localStorage.getItem('emojiModeEnabled') === 'true';
        let themeColor = localStorage.getItem('themeColor') || 'blue';

        let bulkEmojiMode = false;
        let bulkEmojiSelection = [];
        const bulkMaxPlayers = 8;

        // Prevent double-submit
        let isSubmittingRound = false;

        // Inline score edit state
        let activeScoreEditCell = null;
        let activeScoreEditIndices = null;

        /* ---------------------------------------
           Helpers (Keycap digits / Theme)
        --------------------------------------- */
        const KEYCAP_DIGITS = ["0️⃣","1️⃣","2️⃣","3️⃣","4️⃣","5️⃣","6️⃣","7️⃣","8️⃣","9️⃣"];
        function numberToKeycap(n) { return KEYCAP_DIGITS[n] || String(n); }
        function keycapToNumber(str) {
            const idx = KEYCAP_DIGITS.indexOf(str);
            return idx === -1 ? null : idx;
        }

        const THEME_MAP = {
            blue:   { h: 210, s: 85 },
            red:    { h:   0, s: 78 },
            green:  { h: 120, s: 50 },
            pink:   { h: 330, s: 70 },
            purple: { h: 268, s: 70 },
            yellow: { h:  45, s: 90 },
            grey:   { h: 210, s:  0 }
        };
        function getThemeHS() {
            return THEME_MAP[themeColor] || THEME_MAP.blue;
        }
        function getThemeTextColor(key) {
            const t = THEME_MAP[key] || THEME_MAP.blue;
            const L = key === 'yellow' ? 32 : 34;
            return `hsl(${t.h}, ${t.s}%, ${L}%)`;
        }
        function setThemeColor(value) {
            themeColor = value || 'blue';
            localStorage.setItem('themeColor', themeColor);
            updateUI();
            applyThemeSelectColors();
        }
        function applyThemeSelectColors() {
            const select = document.querySelector('#roundManagementModal select#themeColorSelect');
            if (!select) return;
            select.style.color = getThemeTextColor(themeColor);
            Array.from(select.options).forEach(opt => {
                opt.style.color = getThemeTextColor(opt.value);
            });
        }

        /* ---------------------------------------
           Zero icon html (shared)
        --------------------------------------- */
        const ZERO_ICON_HTML = '<img class="zero-icon" src="https://r0wanb3zy.github.io/bezy.nz/score/assets/images/scorecard-icon-01.svg" alt="Zero Score">';

        /* ---------------------------------------
           Persistence
        --------------------------------------- */
        function saveData() {
            localStorage.setItem('players', JSON.stringify(players));
            localStorage.setItem('rounds', JSON.stringify(rounds));
            localStorage.setItem('scoringMode', scoringMode);
            localStorage.setItem('sortByRankEnabled', sortByRankEnabled);
            localStorage.setItem('emojiModeEnabled', emojiModeEnabled);
            localStorage.setItem('themeColor', themeColor);
        }

        function saveUnsubmittedScores() {
            const inputs = document.querySelectorAll("#inputRow input[type='number']");
            unsubmittedScores = {};
            inputs.forEach((input, index) => {
                unsubmittedScores[players[index].name] = input.value;
            });
            localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
        }

        /* ---------------------------------------
           Keyboard / Scroll helpers
        --------------------------------------- */
        function dismissKeyboard() {
            const active = document.activeElement;
            if (active && typeof active.blur === 'function') {
                active.blur();
            }
            document.querySelectorAll('#inputRow input').forEach(inp => {
                if (typeof inp.blur === 'function') inp.blur();
            });
        }

        function scrollScoresToBottom(smooth = true) {
            const sc = document.querySelector('.score-container');
            if (!sc) return;
            try {
                sc.scrollTo({ top: sc.scrollHeight, behavior: smooth ? 'smooth' : 'auto' });
            } catch (_) {
                sc.scrollTop = sc.scrollHeight;
            }
        }

        function allInputsFilled(inputs) {
            return Array.from(inputs).every(input => input.value.trim() !== '');
        }
        function firstEmptyInput(inputs) {
            return Array.from(inputs).find(inp => inp.value.trim() === '');
        }

        function updateEnterKeyHints() {
            const inputs = document.querySelectorAll("#inputRow input[type='number']");
            const filled = allInputsFilled(inputs);
            inputs.forEach(inp => {
                inp.setAttribute('enterkeyhint', filled ? 'done' : 'next');
            });
        }

        /* ---------------------------------------
           Players / Names / Emoji
        --------------------------------------- */
        function syncDefaultNamesToMode() {
            let changed = false;
            players.forEach((p) => {
                const name = (p.name || '').trim();

                if (emojiModeEnabled) {
                    const m = /^P(\d{1,2})$/i.exec(name);
                    if (m) {
                        const n = parseInt(m[1], 10);
                        if (n >= 0 && n <= 9) {
                            const emoji = numberToKeycap(n);
                            if (name !== emoji) {
                                if (unsubmittedScores[name] !== undefined) {
                                    unsubmittedScores[emoji] = unsubmittedScores[name];
                                    delete unsubmittedScores[name];
                                }
                                p.name = emoji;
                                changed = true;
                            }
                        }
                    }
                } else {
                    const n = keycapToNumber(name);
                    if (n !== null) {
                        const pn = `P${n}`.toUpperCase();
                        if (name !== pn) {
                            if (unsubmittedScores[name] !== undefined) {
                                unsubmittedScores[pn] = unsubmittedScores[name];
                                delete unsubmittedScores[name];
                            }
                            p.name = pn;
                            changed = true;
                        }
                    }
                }
            });
            if (changed) {
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
                saveData();
            }
        }

        function renamePlayer(index, newName) {
            const oldName = players[index].name;
            players[index].name = newName;
            if (unsubmittedScores[oldName] !== undefined) {
                unsubmittedScores[newName] = unsubmittedScores[oldName];
                delete unsubmittedScores[oldName];
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));
            }
            saveData();
            updateUI();
        }

        function removePlayer(index) {
            if (players.length <= 1) {
                alert("At least one player must remain.");
                return false;
            }
            players.splice(index, 1);
            rounds.forEach(round => round.splice(index, 1));
            saveData();
            updateUI();
            return true;
        }

        function setEmojiMode(enabled, reopenIndex = null) {
            emojiModeEnabled = !!enabled;
            localStorage.setItem('emojiModeEnabled', emojiModeEnabled);
            syncDefaultNamesToMode();
            saveData();
            updateUI();

            if (reopenIndex !== null) {
                if (emojiModeEnabled) createEmojiPlayerDialog(reopenIndex);
                else createPlayerManagementDialog(reopenIndex);
            }
        }
        function toggleEmojiMode() { setEmojiMode(!emojiModeEnabled); }

        /* ---------------------------------------
           Rounds / Scores
        --------------------------------------- */
        function addRoundScores() {
            // Always dismiss keyboard on submission
            dismissKeyboard();

            const scores = [];
            const inputs = document.querySelectorAll("#inputRow input[type='number']");

            inputs.forEach((input, index) => {
                const score = parseInt(input.value) || 0;
                scores[index] = score;
                players[index].roundScores.push(score);
                players[index].totalScore = players[index].roundScores.reduce((a, b) => a + b, 0);
            });

            rounds.push(scores);
            saveData();

            // Clear inputs after submission
            unsubmittedScores = {};
            localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));

            updateUI();

            // Scroll to bottom
            requestAnimationFrame(() => scrollScoresToBottom(true));
        }

        function updateScore(roundIndex, playerIndex, newScore) {
            const score = parseInt(newScore) || 0;

            if (rounds[roundIndex] && rounds[roundIndex][playerIndex] !== undefined) {
                rounds[roundIndex][playerIndex] = score;

                if (players[playerIndex] && players[playerIndex].roundScores[roundIndex] !== undefined) {
                    players[playerIndex].roundScores[roundIndex] = score;
                    players[playerIndex].totalScore = players[playerIndex].roundScores.reduce((a, b) => a + b, 0);
                }
            }
            saveData();
            updateUI();
        }

        function handleResetScores(button) {
            if (button.dataset.state === 'initial') {
                button.textContent = 'Confirm';
                button.dataset.state = 'confirm';
            } else {
                players.forEach(player => {
                    player.roundScores = [];
                    player.totalScore = 0;
                    player.name = player.name.toUpperCase();
                });
                rounds = [];
                unsubmittedScores = {};
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));

                syncDefaultNamesToMode();

                saveData();
                updateUI();
                closePopup('roundManagementModal');
            }
        }

        function deleteRound(roundIndex) {
            rounds.splice(roundIndex, 1);
            players.forEach(player => {
                player.roundScores.splice(roundIndex, 1);
                player.totalScore = player.roundScores.reduce((a, b) => a + b, 0);
            });
            saveData();
            updateUI();
            closePopup('deleteRoundModal');
        }

        /* ---------------------------------------
           Sorting / Ranking / Theme shading
        --------------------------------------- */
        function applySortByRank(silent = false) {
            if (players.length <= 1 || rounds.length === 0) {
                if (!silent) updateUI();
                return;
            }

            const indices = players
                .map((p, i) => ({ i, score: p.totalScore }))
                .sort((a, b) => scoringMode === "highest" ? (b.score - a.score) : (a.score - b.score))
                .map(o => o.i);

            players = indices.map(i => players[i]);
            rounds = rounds.map(round => indices.map(i => round[i] ?? 0));

            saveData();
            if (!silent) updateUI();
        }

        function getRank(score) {
            if (players.length === 1) return "1st";
            const sortedPlayers = [...players];
            if (scoringMode === "highest") {
                sortedPlayers.sort((a, b) => b.totalScore - a.totalScore);
            } else {
                sortedPlayers.sort((a, b) => a.totalScore - b.totalScore);
            }
            const rank = sortedPlayers.findIndex(player => player.totalScore === score) + 1;
            let suffix = 'th';
            if (rank % 10 === 1 && rank % 100 !== 11) suffix = 'st';
            if (rank % 10 === 2 && rank % 100 !== 12) suffix = 'nd';
            if (rank % 10 === 3 && rank % 100 !== 13) suffix = 'rd';
            return rank + suffix;
        }

        function updateRankings() {
            const playerRow = document.getElementById("playerRow");
            const columns = Array.from(playerRow.children).slice(1);

            columns.forEach((th) => { th.style.background = ''; });

            const { h: H, s: S } = getThemeHS();

            if (players.length === 1) {
                if (rounds.length > 0) {
                    const Lmax = 82, range = 36;
                    const Lmin = Lmax - range;
                    const L = Lmin;
                    const Ltop = Math.max(18, L - 10);
                    const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
                    if (columns[0]) columns[0].style.background = gradient;
                }
                return;
            }

            if (rounds.length === 0) return;

            const scored = players.map((p, i) => ({ index: i, score: p.totalScore }))
                                  .sort((a, b) => scoringMode === "highest" ? (b.score - a.score) : (a.score - b.score));
            const groups = [];
            for (const item of scored) {
                const last = groups[groups.length - 1];
                if (!last || last.score !== item.score) {
                    groups.push({ score: item.score, members: [item.index] });
                } else {
                    last.members.push(item.index);
                }
            }

            const Lmax = 82;
            const minRange = 18;
            const maxRange = 44;
            const effectiveRanks = groups.length;

            if (effectiveRanks === 1) {
                const darkestL = Math.max(28, Lmax - maxRange);
                const Ltop = Math.max(18, darkestL - 10);
                const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${darkestL}%) 100%)`;
                columns.forEach(th => th.style.background = gradient);
                return;
            }

            const maxRanksForScaling = 8;
            const normalized = Math.min(1, Math.max(0, (effectiveRanks - 1) / (maxRanksForScaling - 1)));
            const range = Math.round(minRange + (maxRange - minRange) * normalized);
            const Lmin = Math.max(28, Lmax - range);

            groups.forEach((group, g) => {
                const ratio = g / (effectiveRanks - 1);
                const L = Math.round(Lmin + (Lmax - Lmin) * ratio);
                const Ltop = Math.max(18, L - 10);
                const gradient = `linear-gradient(to bottom, hsl(${H}, ${S}%, ${Ltop}%) 0%, hsl(${H}, ${S}%, ${L}%) 100%)`;
                group.members.forEach(idx => {
                    const th = columns[idx];
                    if (th) th.style.background = gradient;
                });
            });
        }

        /* ---------------------------------------
           UI Building
        --------------------------------------- */
        function clipPlayerNamesToCell() {
            const seg = (typeof Intl !== 'undefined' && Intl.Segmenter)
                ? new Intl.Segmenter('en', { granularity: 'grapheme' })
                : null;

            const els = document.querySelectorAll('#playerRow th .player-name');
            els.forEach(el => {
                const full = el.getAttribute('data-full') ?? el.textContent;
                el.setAttribute('data-full', full);
                el.textContent = full;

                if (el.scrollWidth <= el.clientWidth) return;

                const clusters = seg
                    ? Array.from(seg.segment(full), s => s.segment)
                    : Array.from(full);

                let low = 0, high = clusters.length, best = 0;
                while (low <= high) {
                    const mid = Math.floor((low + high) / 2);
                    el.textContent = clusters.slice(0, mid).join('');
                    if (el.scrollWidth <= el.clientWidth) {
                        best = mid;
                        low = mid + 1;
                    } else {
                        high = mid - 1;
                    }
                }
                el.textContent = clusters.slice(0, best).join('');
            });
        }

        function updateUI() {
            if (sortByRankEnabled && players.length > 1 && rounds.length > 0) {
                applySortByRank(true);
            }

            const playerRow = document.getElementById("playerRow");
            const inputRow = document.getElementById("inputRow");
            const scoreTable = document.getElementById("scoreTable");
            const stickyHeader = document.querySelector(".sticky-header");

            if (players.length >= 7) {
                scoreTable.classList.add("small-scores");
                stickyHeader.classList.add("small-scores");
            } else {
                scoreTable.classList.remove("small-scores");
                stickyHeader.classList.remove("small-scores");
            }

            playerRow.innerHTML = `<th onclick="event.stopPropagation(); createRoundManagementDialog()">☰</th>`;

            players.forEach((player, index) => {
                playerRow.innerHTML += `
                    <th draggable="true" 
                        ondragstart="handleDragStart(event, ${index})"
                        ondragover="handleDragOver(event)"
                        ondrop="handleDrop(event, ${index})"
                        ondragend="handleDragEnd(event)"
                        onclick="handlePlayerNameClick(event, ${index})"
                        title="${player.name}">
                        <span class="player-name">${player.name}</span>
                        <span class="score">${player.totalScore === 0 && rounds.length === 0 ? '' : (player.totalScore === 0 ? '0' : player.totalScore)}</span>
                        ${rounds.length > 0 ? `<br><small>${getRank(player.totalScore)}</small>` : ''}
                    </th>
                `;
            });

            // Input row: ＋ submits immediately (zeros allowed)
            if (inputRow) {
                inputRow.innerHTML = `<td onclick="addRoundScores()">＋</td>`;
                players.forEach((player) => {
                    const savedValue = unsubmittedScores[player.name] || '';
                    inputRow.innerHTML += `
                        <td>
                          <input type="number"
                                 placeholder="${player.name}"
                                 inputmode="numeric"
                                 enterkeyhint="next"
                                 autocomplete="off"
                                 autocorrect="off"
                                 spellcheck="false"
                                 value="${savedValue}"
                                 form="roundForm" />
                        </td>`;
                });
            }

            const scoreBody = document.getElementById("scoreBody");
            scoreBody.innerHTML = "";

            rounds.forEach((round, roundIndex) => {
                const row = document.createElement("tr");
                row.innerHTML = `<td onclick="createDeleteRoundDialog(${roundIndex})">${roundIndex + 1}</td>`;

                players.forEach((_, playerIndex) => {
                    const isZero = round[playerIndex] === 0 || round[playerIndex] === undefined;
                    const displayScore = isZero
                        ? ZERO_ICON_HTML
                        : round[playerIndex];

                    row.innerHTML += `
                        <td class="score-cell"
                            data-round-index="${roundIndex}"
                            data-player-index="${playerIndex}">
                            <span class="score-display">${displayScore}</span>
                        </td>`;
                });

                scoreBody.appendChild(row);
            });

            updateRankings();
            clipPlayerNamesToCell();

            // Wire edit handlers (double tap)
            attachScoreCellEditHandlers();

            // Wire sticky header inputs
            const inputs = document.querySelectorAll("#inputRow input[type='number']");

            inputs.forEach(input => {
                input.addEventListener('input', () => {
                    saveUnsubmittedScores();
                    updateEnterKeyHints();
                });
            });

            // Enter/Go: submit if all filled; else focus first empty
            inputs.forEach(() => {
                document.addEventListener('keydown', function onKey(e) {
                    if (e.key === 'Enter' || e.keyCode === 13) {
                        const inps = document.querySelectorAll("#inputRow input[type='number']");
                        if (inps.length === 0) return;
                        e.preventDefault();
                        if (allInputsFilled(inps)) {
                            if (!isSubmittingRound) {
                                isSubmittingRound = true;
                                addRoundScores();
                                setTimeout(() => { isSubmittingRound = false; }, 200);
                            }
                        } else {
                            const empty = firstEmptyInput(inps);
                            if (empty) empty.focus({ preventScroll: true });
                        }
                    }
                }, { once: true });
            });

            // Update the action key label
            updateEnterKeyHints();
        }

        /* ---------------------------------------
           Modals
        --------------------------------------- */
        function createPlayerManagementDialog(index) {
            const modal = document.getElementById('playerManagementModal');
            modal.innerHTML = `
                <h2>Player</h2>
                <span class="close-btn" onclick="closePopup('playerManagementModal')">×</span>
                <input
                    type="text"
                    id="playerNameInput"
                    value="${players[index].name}"
                    autocapitalize="characters"
                    inputmode="text"
                    style="text-transform: uppercase;"
                    autocomplete="off"
                    autocorrect="off"
                    spellcheck="false"
                >
                <div class="segmented-control">
                    <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, ${index})">
                    <label for="playerMode-name">Name</label>
                    <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, ${index})">
                    <label for="playerMode-emoji">Emoji</label>
                </div>
                <button onclick="handleRemovePlayer(this, ${index})" data-state="initial">Remove</button>
            `;
            modal.style.display = 'block';
            showOverlay();

            const input = modal.querySelector('#playerNameInput');

            input.addEventListener('focus', function () {
                try { this.select(); } catch (_) {}
                try { this.setSelectionRange(0, this.value.length); } catch (_) {}
            });

            let primed = false;
            const primeFocus = (e) => {
                if (primed) return;
                primed = true;
                e.preventDefault();
                try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
                requestAnimationFrame(() => {
                    try { input.select(); } catch (_) {}
                    try { input.setSelectionRange(0, input.value.length); } catch (_) {}
                });
            };
            input.addEventListener('pointerdown', primeFocus, { passive: false });
            input.addEventListener('touchstart', primeFocus, { passive: false });
            input.addEventListener('mousedown', primeFocus);

            input.addEventListener('contextmenu', (e) => e.preventDefault());
            input.addEventListener('mouseup', (e) => e.preventDefault());

            input.addEventListener('input', function () {
                this.value = this.value.toUpperCase();
            });

            input.addEventListener('keydown', function (e) {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    const newName = (input.value || '').trim().toUpperCase();
                    if (newName && newName !== players[index].name) renamePlayer(index, newName);
                    closePopup('playerManagementModal');
                }
            });

            input.addEventListener('blur', function () {
                const newName = (input.value || '').trim().toUpperCase();
                if (newName && newName !== players[index].name) renamePlayer(index, newName);
            });
        }

        function createEmojiPlayerDialog(index) {
            const modal = document.getElementById('playerManagementModal');
            const favEmojis = [
                "🍔","🩰","🌹","🌰","🔔",
                "👑","🎣","🌻","🏏","🦈",
                "🤸🏼‍♀️","🎁","🕊️","🧶","🛠️",
                "🏃‍➡️"
            ];
            const grid = favEmojis.map(e => `<button type="button" class="emoji-pick" data-emoji="${e}">${e}</button>`).join('');

            modal.innerHTML = `
                <h2>Player</h2>
                <span class="close-btn" onclick="closePopup('playerManagementModal')">×</span>
                <input
                    type="text"
                    id="emojiNameInput"
                    value="${players[index].name}"
                    inputmode="text"
                    placeholder="Pick an emoji"
                    enterkeyhint="done"
                    autocapitalize="off"
                    autocomplete="off"
                    autocorrect="off"
                    spellcheck="false"
                >
                <div class="emoji-grid">${grid}</div>

                <div id="bulkEmojiActions" class="bulk-actions">
                  <div class="row">
                    <button type="button" id="bulkCancelBtn" class="light">Cancel</button>
                    <button type="button" id="bulkApplyBtn">Select</button>
                  </div>
                </div>

                <div class="segmented-control">
                    <input type="radio" id="playerMode-name" name="playerModeSwitch" value="name" ${!emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(false, ${index})">
                    <label for="playerMode-name">Name</label>
                    <input type="radio" id="playerMode-emoji" name="playerModeSwitch" value="emoji" ${emojiModeEnabled ? 'checked' : ''} onchange="setEmojiMode(true, ${index})">
                    <label for="playerMode-emoji">Emoji</label>
                </div>
                <button onclick="handleRemovePlayer(this, ${index})" data-state="initial">Remove</button>
            `;
            modal.style.display = 'block';
            showOverlay();

            bulkEmojiMode = false;
            bulkEmojiSelection = [];
            modal.classList.remove('bulk-mode');

            const input = modal.querySelector('#emojiNameInput');

            let primed = false;
            const primeFocus = (e) => {
                if (primed) return;
                primed = true;
                e.preventDefault();
                try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
                requestAnimationFrame(() => {
                    try { input.select(); } catch (_) {}
                    try { input.setSelectionRange(0, input.value.length); } catch (_) {}
                });
            };
            input.addEventListener('pointerdown', primeFocus, { passive: false });
            input.addEventListener('touchstart', primeFocus, { passive: false });
            input.addEventListener('mousedown', primeFocus);

            input.addEventListener('mouseup', (e) => e.preventDefault());
            input.addEventListener('contextmenu', (e) => e.preventDefault());

            let autoClosed = false;
            input.addEventListener('input', function () {
                const sanitized = extractEmojis(this.value);
                if (sanitized !== this.value) this.value = sanitized;
                if (sanitized && !autoClosed && !bulkEmojiMode) {
                    renamePlayer(index, sanitized);
                    autoClosed = true;
                    closePopup('playerManagementModal');
                }
            });

            input.addEventListener('keypress', function (e) {
                if (e.key === 'Enter' && !bulkEmojiMode) {
                    updatePlayerNameEmoji(index);
                }
            });

            attachEmojiGridInteractions(index);
        }

        function extractEmojis(str) {
            if (!str) return '';
            let segments;
            if (typeof Intl !== 'undefined' && Intl.Segmenter) {
                segments = Array.from(new Intl.Segmenter('en', { granularity: 'grapheme' }).segment(str), s => s.segment);
            } else {
                segments = Array.from(str);
            }
            const rePict = /\p{Extended_Pictographic}/u;
            const reRI = /[\u{1F1E6}-\u{1F1FF}]/u;
            const reKeycap = /[#*0-9]\uFE0F?\u20E3/u;
            const reVS16 = /\uFE0F/u;
            const reTagFlag = /\u{1F3F4}[\u{E0061}-\u{E007A}]{1,14}\u{E007F}/u;

            return segments
                .filter(seg => rePict.test(seg) || reRI.test(seg) || reKeycap.test(seg) || reVS16.test(seg) || reTagFlag.test(seg))
                .join('');
        }

        function setEmojiFromButton(btn, index) {
            const emoji = btn.getAttribute('data-emoji') || '';
            if (emoji) {
                renamePlayer(index, emoji);
                closePopup('playerManagementModal');
            }
        }

        function updatePlayerNameEmoji(index) {
            const input = document.getElementById('emojiNameInput');
            const newName = extractEmojis((input.value || '').trim());
            if (newName && newName !== players[index].name) {
                renamePlayer(index, newName);
            }
            closePopup('playerManagementModal');
        }

        function attachEmojiGridInteractions(index) {
            const modal = document.getElementById('playerManagementModal');
            const buttons = Array.from(modal.querySelectorAll('.emoji-pick'));
            const bulkBar = modal.querySelector('#bulkEmojiActions');
            const seg = modal.querySelector('.segmented-control');
            const emojiInput = modal.querySelector('#emojiNameInput');

            const enterBulkEmojiMode = () => {
                if (bulkEmojiMode) return;
                bulkEmojiMode = true;
                bulkEmojiSelection = [];
                if (bulkBar) bulkBar.style.display = 'block';
                if (seg) seg.style.display = 'none';
                if (emojiInput) emojiInput.style.display = 'none';
                buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
                modal.classList.add('bulk-mode');
            };

            const exitBulkEmojiMode = () => {
                bulkEmojiMode = false;
                bulkEmojiSelection = [];
                if (bulkBar) bulkBar.style.display = 'none';
                if (seg) seg.style.display = '';
                if (emojiInput) emojiInput.style.display = '';
                buttons.forEach(b => { b.classList.remove('selected'); b.removeAttribute('data-order'); });
                modal.classList.remove('bulk-mode');
            };

            const renumberSelection = () => {
                buttons.forEach(b => {
                    if (b.classList.contains('selected')) b.setAttribute('data-order', '');
                });
                bulkEmojiSelection.forEach((emoji, i) => {
                    const b = buttons.find(btn => btn.getAttribute('data-emoji') === emoji);
                    if (b) b.setAttribute('data-order', String(i + 1));
                });
            };

            const toggleEmojiSelection = (btn) => {
                const emoji = btn.getAttribute('data-emoji');
                const idx = bulkEmojiSelection.indexOf(emoji);
                if (idx !== -1) {
                    bulkEmojiSelection.splice(idx, 1);
                    btn.classList.remove('selected');
                    btn.removeAttribute('data-order');
                } else {
                    if (bulkEmojiSelection.length >= bulkMaxPlayers) return;
                    bulkEmojiSelection.push(emoji);
                    btn.classList.add('selected');
                }
                renumberSelection();
            };

            const applyBulkEmojiPlayers = (selected) => {
                const targetCount = Math.min(bulkMaxPlayers, selected.length);
                if (targetCount < 1) return;

                emojiModeEnabled = true;
                localStorage.setItem('emojiModeEnabled', 'true');

                const currentCount = players.length;

                if (targetCount > currentCount) {
                    for (let i = currentCount; i < targetCount; i++) {
                        const newName = selected[i] || (emojiModeEnabled ? numberToKeycap(i + 1) : `P${i + 1}`.toUpperCase());
                        players.push({
                            name: newName,
                            totalScore: 0,
                            roundScores: Array(rounds.length).fill(0)
                        });
                    }
                    rounds.forEach(round => {
                        for (let i = round.length; i < targetCount; i++) round.push(0);
                    });
                } else if (targetCount < currentCount) {
                    players = players.slice(0, targetCount);
                    rounds.forEach(round => round.length = targetCount);
                }

                const oldUnsubmitted = { ...unsubmittedScores };
                const newUnsubmitted = {};
                for (let i = 0; i < targetCount; i++) {
                    const oldName = players[i].name;
                    const newName = selected[i];
                    players[i].name = newName;
                    if (oldUnsubmitted[oldName] !== undefined) {
                        newUnsubmitted[newName] = oldUnsubmitted[oldName];
                    }
                }
                unsubmittedScores = newUnsubmitted;
                localStorage.setItem('unsubmittedScores', JSON.stringify(unsubmittedScores));

                saveData();
                updateUI();
            };

            const cancelBtn = modal.querySelector('#bulkCancelBtn');
            const applyBtn = modal.querySelector('#bulkApplyBtn');
            if (cancelBtn) cancelBtn.addEventListener('click', () => { exitBulkEmojiMode(); });
            if (applyBtn) applyBtn.addEventListener('click', () => {
                if (bulkEmojiSelection.length > 0) applyBulkEmojiPlayers(bulkEmojiSelection);
                exitBulkEmojiMode();
                closePopup('playerManagementModal');
            });

            buttons.forEach(btn => {
                btn.addEventListener('click', () => {
                    if (bulkEmojiMode) toggleEmojiSelection(btn);
                    else setEmojiFromButton(btn, index);
                });

                let pressTimer = null;
                const start = () => {
                    if (bulkEmojiMode) return;
                    clearTimeout(pressTimer);
                    pressTimer = setTimeout(() => {
                        enterBulkEmojiMode();
                    }, 500);
                };
                const cancel = () => {
                    clearTimeout(pressTimer);
                    pressTimer = null;
                };

                btn.addEventListener('pointerdown', start);
                btn.addEventListener('pointerup', cancel);
                btn.addEventListener('pointerleave', cancel);
                btn.addEventListener('touchstart', start, { passive: true });
                btn.addEventListener('touchend', cancel);
                btn.addEventListener('touchcancel', cancel);
                btn.addEventListener('mousedown', start);
                btn.addEventListener('mouseup', cancel);
                btn.addEventListener('mouseleave', cancel);
            });
        }

        function handlePlayerNameClick(event, index) {
            event.stopPropagation();
            closeAllPopups();
            if (emojiModeEnabled) createEmojiPlayerDialog(index);
            else createPlayerManagementDialog(index);
        }

        function updatePlayerName(index, closeModal = true) {
            const input = document.getElementById('playerNameInput');
            if (!input) return;
            const newName = (input.value || '').trim().toUpperCase();
            if (newName && newName !== players[index].name) renamePlayer(index, newName);
            if (closeModal) closePopup('playerManagementModal');
        }

        function createRoundManagementDialog() {
            const modal = document.getElementById('roundManagementModal');
            modal.innerHTML = `
                <h2>Round</h2>
                <span class="close-btn" onclick="closePopup('roundManagementModal')">×</span>

                <select id="playerCount" onchange="updatePlayerCount()">
                    ${[1,2,3,4,5,6,7,8].map(i => `<option value="${i}" ${players.length === i ? 'selected' : ''}>${i} Players</option>`).join('')}
                </select>

                <div class="segmented-control">
                    <input type="radio" id="lowest" name="scoringMode" value="lowest" ${scoringMode === 'lowest' ? 'checked' : ''} onchange="scoringMode = 'lowest'; saveData(); updateUI();">
                    <label for="lowest">Low</label>
                    <input type="radio" id="highest" name="scoringMode" value="highest" ${scoringMode === 'highest' ? 'checked' : ''} onchange="scoringMode = 'highest'; saveData(); updateUI();">
                    <label for="highest">High</label>
                </div>

                <button id="sortByRankBtn" class="${sortByRankEnabled ? 'active' : ''}" onclick="toggleSortByRank()">Sort by Rank</button>

                <select id="themeColorSelect" onchange="setThemeColor(this.value)">
                    ${[
                        {v:'blue', t:'Blue'},
                        {v:'purple', t:'Purple'},
                        {v:'pink', t:'Pink'},
                        {v:'red', t:'Red'},
                        {v:'yellow', t:'Yellow'},
                        {v:'green', t:'Green'},
                        {v:'grey', t:'Grey'}
                    ].map(opt => `<option value="${opt.v}" ${themeColor === opt.v ? 'selected' : ''} style="color:${getThemeTextColor(opt.v)};">${opt.t}</option>`).join('')}
                </select>

                <button onclick="handleResetScores(this)" data-state="initial">Reset</button>
            `;
            modal.style.display = 'block';
            showOverlay();
            applyThemeSelectColors();
        }

        function toggleSortByRank() {
            sortByRankEnabled = !sortByRankEnabled;
            localStorage.setItem('sortByRankEnabled', sortByRankEnabled);
            const btn = document.getElementById('sortByRankBtn');
            if (btn) btn.classList.toggle('active', sortByRankEnabled);
            if (sortByRankEnabled) applySortByRank(true);
            updateUI();
        }

        function updatePlayerCount() {
            const newCount = parseInt(document.getElementById('playerCount').value);
            if (newCount > players.length) {
                for (let i = players.length; i < newCount; i++) {
                    const newLabel = emojiModeEnabled ? numberToKeycap(i + 1) : `P${i + 1}`.toUpperCase();
                    players.push({
                        name: newLabel,
                        totalScore: 0,
                        roundScores: Array(rounds.length).fill(0)
                    });
                    rounds.forEach(round => round.push(0));
                }
            } else if (newCount < players.length) {
                players = players.slice(0, newCount);
                rounds.forEach(round => round.length = newCount);
            }
            saveData();
            updateUI();
            closePopup('roundManagementModal');
        }

        function createDeleteRoundDialog(roundIndex) {
            const modal = document.getElementById('deleteRoundModal');
            modal.innerHTML = `
                <h2>Round ${roundIndex + 1}</h2>
                <span class="close-btn" onclick="closePopup('deleteRoundModal')">×</span>
                <button onclick="deleteRound(${roundIndex})">Delete</button>
            `;
            modal.style.display = 'block';
            showOverlay();
        }

        function selectText(element) {
            const range = document.createRange();
            range.selectNodeContents(element);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
        }

        /* ---------------------------------------
           Inline Score Edit (double tap)
        --------------------------------------- */
        function attachScoreCellEditHandlers() {
            const cells = document.querySelectorAll('#scoreBody td.score-cell');
            cells.forEach(cell => {
                if (cell.dataset.tapBound === '1') return;
                cell.dataset.tapBound = '1';

                let lastTapTime = 0;
                let lastX = 0, lastY = 0;
                const tapGap = 300; // ms
                const tol = 15;     // px

                // Pointer-based double-tap detection (covers touch + pen + mouse)
                cell.addEventListener('pointerup', (e) => {
                    const now = e.timeStamp;
                    const x = e.clientX || 0, y = e.clientY || 0;
                    if (now - lastTapTime < tapGap && Math.abs(x - lastX) < tol && Math.abs(y - lastY) < tol) {
                        e.preventDefault();
                        if (!activeScoreEditCell) {
                            openInlineScoreEditForCell(cell);
                        }
                        lastTapTime = 0;
                    } else {
                        lastTapTime = now;
                        lastX = x; lastY = y;
                    }
                }, { passive: false });

                // Desktop fallback
                cell.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    if (!activeScoreEditCell) {
                        openInlineScoreEditForCell(cell);
                    }
                });
            });
        }

        function openInlineScoreEditForCell(cell) {
            closeAllPopups(); // just in case

            const roundIndex = parseInt(cell.getAttribute('data-round-index'), 10);
            const playerIndex = parseInt(cell.getAttribute('data-player-index'), 10);
            const current = (rounds[roundIndex] && rounds[roundIndex][playerIndex] !== undefined)
                ? rounds[roundIndex][playerIndex]
                : 0;

            activeScoreEditCell = cell;
            activeScoreEditIndices = { roundIndex, playerIndex };
            cell.classList.add('score-edit-selected');

            let input = cell.querySelector('input.inline-score-input');
            if (!input) {
                input = document.createElement('input');
                input.type = 'number';
                input.className = 'inline-score-input';
                input.setAttribute('inputmode', 'numeric');
                input.setAttribute('enterkeyhint', 'done');
                input.autocomplete = 'off';
                input.autocorrect = 'off';
                input.spellcheck = false;

input.addEventListener('keydown', function(e) {
    if (e.key === 'Enter') {
        e.preventDefault();
        // Close the keyboard by blurring; blur handler will apply the edit.
        try { this.blur(); } catch (_) {}
    }
});

                // Mirror typed digits into the centered display (keep display visible)
                input.addEventListener('input', function() {
                    this.dataset.changed = '1';
                    const display = cell.querySelector('.score-display');
                    if (!display) return;
                    const v = this.value.trim();
                    display.innerHTML = v === '' ? '' : (v === '0' ? ZERO_ICON_HTML : v);
                });

                input.addEventListener('blur', function() {
                    // Apply on blur as well (Done key or tap away)
                    applyInlineScoreEdit();
                });

                // Prevent events on input from re-triggering gestures
                input.addEventListener('pointerdown', e => e.stopPropagation());
                input.addEventListener('touchstart', e => e.stopPropagation(), { passive: true });
                input.addEventListener('mousedown', e => e.stopPropagation());

                cell.appendChild(input);
            }

            // Begin with empty input; show current score via display underneath
            input.value = '';
            input.dataset.originalValue = String(current);
            input.dataset.changed = '0';

            setTimeout(() => {
                try { input.focus({ preventScroll: true }); } catch (_) { input.focus(); }
            }, 0);
        }

function applyInlineScoreEdit() {
    if (!activeScoreEditCell || !activeScoreEditIndices) return;

    const input = activeScoreEditCell.querySelector('input.inline-score-input');

    // If still focused, blur first to close the keyboard
    if (input && document.activeElement === input) {
        try { input.blur(); } catch (_) {}
    }

    const changed = input && input.dataset.changed === '1';
    const val = input ? parseInt(input.value, 10) : NaN;
    const score = isNaN(val) ? 0 : val;
    const { roundIndex, playerIndex } = activeScoreEditIndices;

    // Give the OS one tick to dismiss the keyboard before removing the input
    setTimeout(() => {
        clearActiveScoreCellHighlight(); // removes the inline input
        if (changed) {
            updateScore(roundIndex, playerIndex, score); // updateUI() runs inside
        }
    }, 0);
}

        function clearActiveScoreCellHighlight() {
            if (activeScoreEditCell) {
                activeScoreEditCell.classList.remove('score-edit-selected');
                const inlineInput = activeScoreEditCell.querySelector('input.inline-score-input');
                if (inlineInput) inlineInput.remove();
            }
            activeScoreEditCell = null;
            activeScoreEditIndices = null;
        }

        /* ---------------------------------------
           Modal / Overlay helpers
        --------------------------------------- */
        function showOverlay() { document.getElementById('overlay').style.display = 'block'; }
        function hideOverlay() { document.getElementById('overlay').style.display = 'none'; }

        function closePopup(modalId) {
            document.getElementById(modalId).style.display = 'none';
            hideOverlay();
        }

        function closeAllPopups() {
            document.getElementById('playerManagementModal').style.display = 'none';
            document.getElementById('roundManagementModal').style.display = 'none';
            document.getElementById('deleteRoundModal').style.display = 'none';
            hideOverlay();
            clearActiveScoreCellHighlight();
        }

        document.getElementById('overlay').addEventListener('click', closeAllPopups);

        function handleRemovePlayer(button, index) {
            if (button.dataset.state === 'initial') {
                button.textContent = 'Confirm';
                button.dataset.state = 'confirm';
            } else {
                removePlayer(index);
                closePopup('playerManagementModal');
            }
        }

        /* ---------------------------------------
           Drag & Drop (reorder players)
        --------------------------------------- */
        let draggedIndex = -1;

        function handleDragStart(event, index) {
            draggedIndex = index;
            event.target.classList.add('dragging');
            event.dataTransfer.effectAllowed = 'move';
        }

        function handleDragOver(event) {
            event.preventDefault();
            event.dataTransfer.dropEffect = 'move';
            const target = event.target.closest('th');
            if (target && target !== event.currentTarget && !target.textContent.includes('☰')) {
                target.classList.add('drag-over');
            }
        }

        function handleDrop(event, dropIndex) {
            event.preventDefault();
            if (draggedIndex !== -1 && draggedIndex !== dropIndex) {
                const [draggedPlayer] = players.splice(draggedIndex, 1);
                players.splice(dropIndex, 0, draggedPlayer);

                rounds.forEach(round => {
                    const [draggedScore] = round.splice(draggedIndex, 1);
                    round.splice(dropIndex, 0, draggedScore);
                });

                saveData();
                updateUI();
            }
            const ths = document.querySelectorAll('#playerRow th');
            ths.forEach(th => th.classList.remove('drag-over'));
            draggedIndex = -1;
        }

        function handleDragEnd(event) {
            event.target.classList.remove('dragging');
            const ths = document.querySelectorAll('#playerRow th');
            ths.forEach(th => th.classList.remove('drag-over'));
            draggedIndex = -1;
        }

        /* ---------------------------------------
           Form submit handler (mobile Done/Go)
        --------------------------------------- */
        function handleRoundFormSubmit(e) {
            e.preventDefault();
            if (isSubmittingRound) return;

            const inputs = document.querySelectorAll("#inputRow input[type='number']");
            if (allInputsFilled(inputs)) {
                isSubmittingRound = true;
                addRoundScores();
                setTimeout(() => { isSubmittingRound = false; }, 200);
            } else {
                const empty = firstEmptyInput(inputs);
                if (empty) empty.focus({ preventScroll: true });
            }
        }

        /* ---------------------------------------
           Init
        --------------------------------------- */
        syncDefaultNamesToMode();
        updateUI();

        window.addEventListener('resize', clipPlayerNamesToCell);
        if (window.document && document.fonts && document.fonts.addEventListener) {
            document.fonts.addEventListener('loadingdone', clipPlayerNamesToCell);
        } else {
            window.addEventListener('load', clipPlayerNamesToCell);
        }
    </script>
</body>
</html>